<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>JavaScript 基础</title>
      <link href="/2022/06/21/%E5%89%8D%E7%AB%AF/JavaScript%20%E5%9F%BA%E7%A1%80/"/>
      <url>/2022/06/21/%E5%89%8D%E7%AB%AF/JavaScript%20%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<p>JavaScript（简称“JS”） 是一种具有函数优先的轻量级，解释型或即时编译型的 <strong>编程语言</strong>。虽然它是作为开发 <strong>Web</strong> 页面的 <strong>脚本语言</strong> 而出名，但是它也被用到了很多非浏览器环境中，JavaScript 基于原型编程、多范式的动态脚本语言，并且支持面向对象、命令式、声明式、函数式编程范式。</p><p>在日常使用 JavaScript 过程中，如果只是知其然，不知其所以然，就会导致项目出现各种非预期的问题，并且难以排查，所以，夯实 JavaScript 基础势在必行。</p><h2 id="数据类型容易忽略的细节"><a href="#数据类型容易忽略的细节" class="headerlink" title="数据类型容易忽略的细节"></a>数据类型容易忽略的细节</h2><h3 id="数据类型的陷阱，从表象看本质"><a href="#数据类型的陷阱，从表象看本质" class="headerlink" title="数据类型的陷阱，从表象看本质"></a>数据类型的陷阱，从表象看本质</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">isObject</span>(<span class="params">obj</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">typeof</span> obj === <span class="string">&#x27;object&#x27;</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码会不会有问题呢？当传值为 <code>null</code> 的时候，返回结果为 true。</p><p>追其原因，是早期 JavaScript 中，类型只有以下几种（数据总长度是 <strong>标记位 + 值</strong> 为 32 位）：</p><blockquote><p>000: object<br><br>001: integer<br><br>010: double<br><br>100: string<br><br>110: boolean</p></blockquote><p><code>null</code> 是一个特殊的值，为 <code>32 个 0 组成</code>。因此，开头标识为 <strong>0</strong>，也就对应 <strong>object</strong> 了。之所以不修复，是因为会涉及到很多项目，所以为了兼容性，没有进行修复，也就形成了历史的包袱。</p><h3 id="转为数字"><a href="#转为数字" class="headerlink" title="+ 转为数字"></a>+ 转为数字</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">toNumber</span>(<span class="params">val</span>) &#123;</span><br><span class="line"><span class="keyword">const</span> result = +val;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(result);</span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 传统数据类型</span></span><br><span class="line"><span class="title function_">toNumber</span>(<span class="literal">null</span>) <span class="comment">// NaN</span></span><br><span class="line"><span class="title function_">toNumber</span>(<span class="literal">undefined</span>) <span class="comment">// NaN</span></span><br><span class="line"><span class="title function_">toNumber</span>(<span class="number">1</span>) <span class="comment">// 1</span></span><br><span class="line"><span class="title function_">toNumber</span>(<span class="string">&quot;123aa&quot;</span>) <span class="comment">// NaN</span></span><br><span class="line"><span class="title function_">toNumber</span>(&#123;&#125;) <span class="comment">// NaN</span></span><br><span class="line"><span class="title function_">toNumber</span>(<span class="literal">true</span>) <span class="comment">// NaN</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 非传统数据类型</span></span><br><span class="line"><span class="title function_">toNumber</span>(<span class="number">10n</span>) <span class="comment">// 错误，BigInt 不能转换为 number</span></span><br><span class="line"><span class="title function_">toNumber</span>(<span class="title class_">Symbol</span>.<span class="title function_">for</span>(<span class="string">&quot;a&quot;</span>)) <span class="comment">// 错误，Symbol 不能转换为 number</span></span><br></pre></td></tr></table></figure><h3 id="位移转为数字"><a href="#位移转为数字" class="headerlink" title="位移转为数字"></a>位移转为数字</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">toNumber</span>(<span class="params">val</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> val &gt;&gt; <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">toNumber2</span>(<span class="params">val</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> val &gt;&gt;&gt; <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 正常数据类型</span></span><br><span class="line"><span class="title function_">toNumber</span>(<span class="literal">null</span>) <span class="comment">// 0</span></span><br><span class="line"><span class="title function_">toNumber</span>(&#123;&#125;) <span class="comment">// 0</span></span><br><span class="line"><span class="title function_">toNumber</span>(<span class="string">&quot;10x&quot;</span>) <span class="comment">// 0</span></span><br><span class="line"><span class="title function_">toNumber</span>(<span class="string">&quot;10&quot;</span>) <span class="comment">// 10</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 超大的数</span></span><br><span class="line"><span class="title function_">toNumber</span>(<span class="title class_">Number</span>.<span class="property">MAX_SAFE_INTEGER</span>) <span class="comment">// -1</span></span><br><span class="line"><span class="title function_">toNumber2</span>(<span class="title class_">Number</span>.<span class="property">MAX_SAFE_INTEGER</span>) <span class="comment">// 4294967295</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 非传统数据类型</span></span><br><span class="line"><span class="title function_">toNumber</span>(<span class="number">10n</span>) <span class="comment">// 错误，BigInt 不能转换为 number</span></span><br><span class="line"><span class="title function_">toNumber</span>(<span class="title class_">Symbol</span>.<span class="title function_">for</span>(<span class="string">&quot;a&quot;</span>)) <span class="comment">// 错误，Symbol 不能转换为 number</span></span><br></pre></td></tr></table></figure><p><code>toNumber2(Number.MAX_SAFE_INTEGER) // 4294967295</code> 原因是什么呢？简单分析一下：</p><ol><li>Number.MAX_SAFE_INTEGER.toString(2) 值如下</li><li>11111111111111111111111111111111111111111111111111111</li><li>&gt;&gt;&gt; 的计算长度为 32 位(如果数据长度小于 32 位，则不会出现问题)，因此参与运算数据为</li><li>11111111111111111111111111111111</li><li>32位长度的值为 4294967295</li></ol><p><code>toNumber(Number.MAX_SAFE_INTEGER) // -1</code> 的原因又是什么呢？先补一个小知识：</p><blockquote><p>十进制变二进制：原码 &#x3D;&gt; 反码 加一（补码）<br><br>二进制变十进制：减一 &#x3D;&gt; 反码 &#x3D; 原码</p></blockquote><p>进而分析原因：</p><ol><li>Number.MAX_SAFE_INTEGER.toString(2) 值如下</li><li>11111111111111111111111111111111111111111111111111111</li><li>&gt;&gt;&gt; 的计算长度为 32 位(如果数据长度小于 32 位，则不会出现问题)，因此参与运算数据为</li><li>11111111111111111111111111111111</li><li>减一</li><li>11111111111111111111111111111110</li><li>取反</li><li>00000000000000000000000000000001 &#x3D; 1</li><li>最高位为 1，表示负数</li><li>所以结果为 -1</li></ol><h4 id="补充知识"><a href="#补充知识" class="headerlink" title="补充知识"></a>补充知识</h4><blockquote><p><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Left_shift">Left shift (&lt;&lt;)</a></p><blockquote><p>The left shift (&lt;&lt;) operator shifts the first operand the specified number of bits, <span style="color: red;">modulo 32</span>, to the left. Excess bits shifted off to the left are discarded. Zero bits are shifted in from the right.</p></blockquote><p><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Right_shift">Right shift (&gt;&gt;)</a></p><blockquote><p>The right shift (&gt;&gt;) operator returns the signed number represented by the result of performing a sign-extending shift of the binary representation of the first operand (evaluated as a two’s complement bit string) to the right by the number of bits, <span style="color: red;">modulo 32</span> specified in the second operand. Excess bits shifted off to the right are discarded, and copies of the leftmost bit are shifted in from the left.</p></blockquote><p><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Unsigned_right_shift">Unsigned right shift (&gt;&gt;&gt;)</a></p><blockquote><p>The unsigned right shift (&gt;&gt;&gt;) (zero-fill right shift) operator evaluates the left-hand operand as an unsigned number, and shifts the binary representation of that number by the number of bits, <span style="color: red;">modulo 32</span> specified by the right-hand operand. Excess bits shifted off to the right are discarded, and zero bits are shifted in from the left. The sign bit becomes 0, so the result is always non-negative. Unlike the other bitwise operators, zero-fill right shift returns an unsigned 32-bit integer.</p></blockquote></blockquote><h3 id="字符串批量转换为整数"><a href="#字符串批量转换为整数" class="headerlink" title="字符串批量转换为整数"></a>字符串批量转换为整数</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="string">&quot;1&quot;</span>, <span class="string">&quot;2&quot;</span>, <span class="string">&quot;3&quot;</span>]</span><br><span class="line">arr.<span class="title function_">map</span>(<span class="built_in">parseInt</span>) <span class="comment">// 1 NaN NaN</span></span><br></pre></td></tr></table></figure><p>为什么没有按照预期输出呢？详细列出拆解代码即可知晓：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">parseInt</span>(<span class="string">&quot;1&quot;</span>, <span class="number">0</span>); <span class="comment">// =&gt; 1</span></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="string">&quot;2&quot;</span>, <span class="number">1</span>); <span class="comment">// =&gt; NaN，进制与值不匹配问题</span></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="string">&quot;3&quot;</span>, <span class="number">2</span>); <span class="comment">// =&gt; NaN，进制与值不匹配问题</span></span><br></pre></td></tr></table></figure><blockquote><p>parseInt(string)<br><br>parseInt(string, radix)</p><p><strong>string</strong>: The value to parse. If this argument is not a string, then it is converted to one using the ToString abstract operation. Leading whitespace in this argument is ignored.</p><p><strong>radix</strong>: An integer between <strong>2</strong> and <strong>36</strong> that represents the radix (the base in mathematical numeral systems) of the string. It is converted to a 32-bit integer; if it’s outside the range of [2, 36] after conversion, the function will always return NaN. If 0 or not provided, the radix will be inferred based on string’s value. Be careful — this does NOT always default to 10! The description below explains in more detail what happens when radix is not provided.</p><blockquote><p>The radix argument is converted to a number. If it’s unprovided, or if the value becomes 0, NaN or Infinity (undefined is coerced to NaN), JavaScript assumes the following:</p><blockquote><ol><li>If the input string, with leading whitespace and possible +&#x2F;- signs removed, begins with 0x or 0X (a zero, followed by lowercase or uppercase X), radix is assumed to be 16 and the rest of the string is parsed as a hexadecimal number.</li><li>If the input string begins with any other value, the radix is 10 (decimal).</li></ol></blockquote></blockquote></blockquote><h3 id="if-条件判断"><a href="#if-条件判断" class="headerlink" title="if 条件判断"></a>if 条件判断</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> result = &#123;&#125;</span><br><span class="line"><span class="keyword">if</span> (obj.<span class="property">name</span>) &#123;</span><br><span class="line">result.<span class="property">name</span> = obj.<span class="property">name</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> result;</span><br></pre></td></tr></table></figure><p>问题点，<code>obj.name</code> 会转换为 <strong>boolean</strong>，像 <code>null</code>、<code>undefined</code>、<code>&#39;&#39;</code>、<code>false</code>、<code>0</code>、<code>-0</code>、<code>NaN</code> 会丢失数据。</p><p>解决方案：使用 <code>Object.hasOwnProperty(xxx)</code>。</p><h3 id="宽松比较"><a href="#宽松比较" class="headerlink" title="宽松比较"></a>宽松比较</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="literal">null</span> == <span class="number">0</span> <span class="comment">// false</span></span><br><span class="line"><span class="string">&#x27;0&#x27;</span> == <span class="literal">false</span> <span class="comment">// true</span></span><br></pre></td></tr></table></figure><ol><li>NaN：与任何值都不相等，包括自身</li><li>BigInt、Symbol：要类型相同才进行后续</li><li>null、undefined：只能与 null、undefined 相等</li><li>布尔类型和其他类型的相等比较：布尔值转换为数字</li><li>数字类型和字符串类型的相等比较：会转换成数字</li><li>对象类型和原始类型的相等比较：对象转成原始数据类型</li><li>对象和对象的相等比较：比引用</li></ol><h3 id="typeof-与-instanceof-性能差距"><a href="#typeof-与-instanceof-性能差距" class="headerlink" title="typeof 与 instanceof 性能差距"></a>typeof 与 instanceof 性能差距</h3><p>在百万级别的调用中，typeof : instanceof ≈ 1 : 2</p><h3 id="null-和-undefined"><a href="#null-和-undefined" class="headerlink" title="null 和 undefined"></a>null 和 undefined</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> print = <span class="variable language_">console</span>.<span class="property">log</span>;</span><br><span class="line"><span class="title function_">print</span>(<span class="title class_">Object</span>.<span class="title function_">getOwnPropertyDescriptor</span>(<span class="variable language_">global</span>, <span class="string">&#x27;null&#x27;</span>)) <span class="comment">// undefined</span></span><br><span class="line"><span class="title function_">print</span>(<span class="title class_">Object</span>.<span class="title function_">getOwnPropertyDescriptor</span>(<span class="variable language_">global</span>, <span class="string">&#x27;undefined&#x27;</span>)) <span class="comment">// &#123;value: undefined, writable: false, enumerable: false, configurable: false&#125;</span></span><br></pre></td></tr></table></figure><h3 id="数据类型-8-种判断方式"><a href="#数据类型-8-种判断方式" class="headerlink" title="数据类型 8 种判断方式"></a>数据类型 8 种判断方式</h3><h4 id="第一种：typeof"><a href="#第一种：typeof" class="headerlink" title="第一种：typeof"></a>第一种：typeof</h4><p>主要用途：操作数的类型，只能识别基础数据类型和引用类型</p><p>特别注意：</p><ol><li>typeof null &#x3D;&gt; object</li><li>typeof NaN &#x3D;&gt; number</li><li>typeof document.all &#x3D;&gt; undefined</li></ol><p>注意事项：已经不是绝对安全（暂时性死区）</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">log</span>(<span class="params"></span>) &#123;</span><br><span class="line"><span class="keyword">typeof</span> a</span><br><span class="line"><span class="keyword">let</span> a = <span class="number">10</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">log</span>();</span><br></pre></td></tr></table></figure><h4 id="第二种：constructor"><a href="#第二种：constructor" class="headerlink" title="第二种：constructor"></a>第二种：constructor</h4><p>原理：constructor 指向创建实例对象的构造函数</p><p>注意事项：</p><ol><li>null 和 undefined</li><li>constructor 可以被改写</li></ol><h4 id="第三种：instanceof"><a href="#第三种：instanceof" class="headerlink" title="第三种：instanceof"></a>第三种：instanceof</h4><p>原理：原型链上查找，查到即是其实例</p><p>注意事项：</p><ol><li>右操作数必须是函数或者 class</li><li>多全局对象，例如多 window 之间</li></ol><h4 id="第四种：isPrototypeOf"><a href="#第四种：isPrototypeOf" class="headerlink" title="第四种：isPrototypeOf"></a>第四种：isPrototypeOf</h4><p>原理：是否出现在实例对象的原型链上</p><p>注意事项：<strong>能正常返回值</strong> 的情况，基本等同 instanceof</p><h4 id="第五种：Object-prototype-toString"><a href="#第五种：Object-prototype-toString" class="headerlink" title="第五种：Object.prototype.toString"></a>第五种：Object.prototype.toString</h4><p>原理：通过函数的动态 this 特性，返回其数据类型，示例 [object Date]</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>.<span class="title function_">call</span>(<span class="title class_">Boolean</span>.<span class="property"><span class="keyword">prototype</span></span>); <span class="comment">// =&gt; [object Boolean]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 加上 toStringTag 属性，你的类也会有自定义的类型标签了</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ValidatorClass</span> &#123;</span><br><span class="line">  get [<span class="title class_">Symbol</span>.<span class="property">toStringTag</span>]() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;Validator&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>.<span class="title function_">call</span>(<span class="keyword">new</span> <span class="title class_">ValidatorClass</span>()); <span class="comment">// &quot;[object Validator]&quot;</span></span><br></pre></td></tr></table></figure><h4 id="第六种：鸭子类型检测（候选方案）"><a href="#第六种：鸭子类型检测（候选方案）" class="headerlink" title="第六种：鸭子类型检测（候选方案）"></a>第六种：鸭子类型检测（候选方案）</h4><p>原理：检查自身，属性的类型或者执行结果的类型。</p><p>示例：kindOf 与 p-is-promise</p><h4 id="第七种：Symbol-toStringTag"><a href="#第七种：Symbol-toStringTag" class="headerlink" title="第七种：Symbol.toStringTag"></a>第七种：Symbol.toStringTag</h4><p>原理：Object.prototype.toString 会读取该值。</p><p>适用场景：需自定义类型。</p><p>注意事项：兼容性。</p><h4 id="第八种：等比较"><a href="#第八种：等比较" class="headerlink" title="第八种：等比较"></a>第八种：等比较</h4><p>原理：与某个固定值进行比较。</p><p>适用场景：undefined、window、document、null 等。</p><table><thead><tr><th align="left">方法</th><th align="left">基础数据类型</th><th align="left">引用类型</th><th align="left">注意事项</th></tr></thead><tbody><tr><td align="left">typeof</td><td align="left">✅</td><td align="left">×</td><td align="left">NaN、object、document.all</td></tr><tr><td align="left">constructor</td><td align="left">✅部分</td><td align="left">✅</td><td align="left">可以被改写</td></tr><tr><td align="left">instanceof</td><td align="left">×</td><td align="left">✅</td><td align="left">多窗口，右边构造函数或者 class</td></tr><tr><td align="left">isPrototypeOf</td><td align="left">×</td><td align="left">✅</td><td align="left">小心 null 和 undefined</td></tr><tr><td align="left">toString</td><td align="left">✅</td><td align="left">✅</td><td align="left">小心内置原型</td></tr><tr><td align="left">鸭子类型</td><td align="left">—</td><td align="left">✅</td><td align="left">不得已或者兼容</td></tr><tr><td align="left">Symbol.toStringTag</td><td align="left">×</td><td align="left">✅</td><td align="left">识别自定义对象</td></tr><tr><td align="left">等比较</td><td align="left">✅</td><td align="left">✅</td><td align="left">特殊对象</td></tr></tbody></table><h3 id="NaN-和-Number-NaN"><a href="#NaN-和-Number-NaN" class="headerlink" title="NaN 和 Number.NaN"></a>NaN 和 Number.NaN</h3><p>特点：</p><ol><li>typeof NaN &#x3D;&gt; ‘number’</li><li>NaN 与 NaN 不相等</li><li>不能被删除（ {configurable: false; enumerable: false; value: NaN; writable: false}）</li></ol><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="title class_">NaN</span>];</span><br><span class="line">arr.<span class="title function_">indexOf</span>(<span class="title class_">NaN</span>) <span class="comment">// =&gt; -1。indexOf 调用内部的 Number:: equal</span></span><br><span class="line">arr.<span class="title function_">includes</span>(<span class="title class_">NaN</span>) <span class="comment">// =&gt; true。includes 调用内部的 Number::sameValueZero</span></span><br></pre></td></tr></table></figure><h3 id="数值千分位-6-种方法、性能大比拼"><a href="#数值千分位-6-种方法、性能大比拼" class="headerlink" title="数值千分位 6 种方法、性能大比拼"></a>数值千分位 6 种方法、性能大比拼</h3><table><thead><tr><th align="left">方法</th><th align="left">描述</th><th align="left">性能</th><th align="left">备注</th></tr></thead><tbody><tr><td align="left">数值转字符串遍历</td><td align="left">数字转字符串，整数部分低位往高位遍历</td><td align="left">T2</td><td align="left"></td></tr><tr><td align="left">字符串 + substring 截取</td><td align="left">数字转字符串，整数部分高位往低位遍历，三位分组</td><td align="left">T2</td><td align="left"></td></tr><tr><td align="left">除法 + 求模</td><td align="left">求模的值添加 「,」，求余的值（是否大于 1）计算是否结束</td><td align="left">T0</td><td align="left"></td></tr><tr><td align="left">正则先行断言</td><td align="left">&#x2F;\d{1,3}(?&#x3D;(\d{3})+$)&#x2F;g</td><td align="left">T2</td><td align="left"></td></tr><tr><td align="left">Intl.NumberFormat</td><td align="left">new Intl.NumberFormat([locals[, options]])</td><td align="left">T2 或者下水道</td><td align="left">ECM-402 标准，初始化成本很大</td></tr><tr><td align="left">toLocalString</td><td align="left">把数字转为特定语言环境下的表示字符串，numObj.toLocalString([locals [, options]])</td><td align="left">T2 或者下水道</td><td align="left">设置小数位后性能变大非常大</td></tr></tbody></table><h3 id=""><a href="#" class="headerlink" title="[] + [], [] + {}, {} + [], {} + {}"></a>[] + [], [] + {}, {} + [], {} + {}</h3><h4 id="二元操作符-规则"><a href="#二元操作符-规则" class="headerlink" title="二元操作符 + 规则"></a>二元操作符 + 规则</h4><ul><li>如果操作数是对象，则对象会转换为原始值</li><li>如果其中一个操作数是字符串的话，另一个操作数也会转换成字符串，进行字符串连接</li><li>否则，两个操作数都将转换成数字或 NaN，进行加法操作</li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="number">10n</span> + <span class="number">10</span> <span class="comment">// TypeError: cannot mix BigInt and other types</span></span><br><span class="line"></span><br><span class="line"><span class="title class_">Symbol</span>.<span class="title function_">for</span>(<span class="string">&#x27;a&#x27;</span>) + <span class="number">10</span> <span class="comment">// TypeError: Cannot convert a Symbol value to a number</span></span><br></pre></td></tr></table></figure><h4 id="对象转为原始数据类型的值"><a href="#对象转为原始数据类型的值" class="headerlink" title="对象转为原始数据类型的值"></a>对象转为原始数据类型的值</h4><ul><li>Symbol.toPrimitive</li><li>Object.prototype.valueOf</li><li>Object.prototype.toString</li></ul><h4 id="的原始值"><a href="#的原始值" class="headerlink" title="[] 的原始值"></a>[] 的原始值</h4><ul><li>typeof [][Symbol.toPrimitive] &#x2F;&#x2F; undefined</li><li>[].valueOf() &#x2F;&#x2F; []</li><li>[].toString() &#x2F;&#x2F; ‘’</li></ul><h4 id="的原始值-1"><a href="#的原始值-1" class="headerlink" title="{} 的原始值"></a>{} 的原始值</h4><ul><li>typeof {}[Symbol.toPrimitive] &#x2F;&#x2F; undefined</li><li>{}.valueOf() &#x2F;&#x2F; {}</li><li>{}.toString() &#x2F;&#x2F; ‘[object Object]’</li></ul><h4 id="-1"><a href="#-1" class="headerlink" title="[] + []"></a>[] + []</h4><ul><li>[].toString() + [].toString()</li><li>‘’ + ‘’</li><li>‘’</li></ul><h4 id="-2"><a href="#-2" class="headerlink" title="[] + {}"></a>[] + {}</h4><ul><li>[].toString() + {}.toString()</li><li>‘’ + ‘[object Object]’</li><li>‘[object Object]’</li></ul><h4 id="-3"><a href="#-3" class="headerlink" title="{} + []"></a>{} + []</h4><ul><li>等同于 {}; + []</li><li><ul><li>[]</li></ul></li><li><ul><li>‘’</li></ul></li><li>0</li></ul><h4 id="-4"><a href="#-4" class="headerlink" title="{} + {}"></a>{} + {}</h4><ul><li>Safari: “[object Object][object Object]”</li><li>Chrome: “[object Object][object Object]”</li><li>Edge: “[object Object][object Object]”</li></ul><p>可能出现情况：</p><ul><li>等同于 {}; + {}</li><li><ul><li>‘[object Object]’</li></ul></li><li>NaN</li></ul><h3 id="通过普通属性，排序属性和隐藏类提升对象属性认知"><a href="#通过普通属性，排序属性和隐藏类提升对象属性认知" class="headerlink" title="通过普通属性，排序属性和隐藏类提升对象属性认知"></a>通过普通属性，排序属性和隐藏类提升对象属性认知</h3><p>键的两种属性：</p><ol><li>字符串作为键（常规属性）：根据创建时的顺序进行排序</li><li>数字、数字字符串作为键（排序属性）：按照索引值大小升序排序</li></ol><p>守护隐藏类：</p><ol><li>初始化时保持属性顺序一致</li><li>一次性初始化完毕</li><li>谨慎使用 delete</li></ol><table><thead><tr><th align="center">方法</th><th align="center">新增属性</th><th align="center">修改描述符</th><th align="center">删除属性</th><th align="center">更改属性值</th></tr></thead><tbody><tr><td align="center">Object.preventExtensions</td><td align="center">×</td><td align="center">√</td><td align="center">√</td><td align="center">√</td></tr><tr><td align="center">Object.seal</td><td align="center">×</td><td align="center">×（writable 有例外）</td><td align="center">×</td><td align="center">√</td></tr><tr><td align="center">Object.freeze</td><td align="center">×</td><td align="center">×（writable 有例外）</td><td align="center">×</td><td align="center">×</td></tr></tbody></table><h3 id="原型访问方式"><a href="#原型访问方式" class="headerlink" title="原型访问方式"></a>原型访问方式</h3><table><thead><tr><th align="center">方法</th><th align="left">作用</th><th align="left">重点和注意事项</th></tr></thead><tbody><tr><td align="center">prototype</td><td align="left">获取对象原型</td><td align="left">1、class ES6 转 ES5 基于 prototype<br>2、toString.call 的怪异现象</td></tr><tr><td align="center">__proto__</td><td align="left">构造函数的原型</td><td align="left">1、函数祖上第三代 __proto__ 是  null<br>2、普通对象祖上第二代 __proto__ 是 null</td></tr><tr><td align="center">instanceof</td><td align="left">构造函数（右侧）的 prototype 属性是否出现在某个实例对象（左侧）的原型链上</td><td align="left">1、Object instance of Function<br>2、Function instance Object</td></tr><tr><td align="center">getPrototype</td><td align="left">获取对象的原型</td><td align="left">null 和 undefined 没有原型</td></tr><tr><td align="center">setPrototype</td><td align="left">设置对象的原型</td><td align="left">null 可以作为第二个参数，原型的尽头是 null</td></tr><tr><td align="center">isPrototype</td><td align="left">对象是否存在于另一个对象的原型链上</td><td align="left">不会有 prototype 这一步运算</td></tr><tr><td align="center">Object.create</td><td align="left">使用现有的对象来提供新创建爱你的对象的 __proto__</td><td align="left">创建纯净对象</td></tr></tbody></table><h3 id="属性的类型及遍历"><a href="#属性的类型及遍历" class="headerlink" title="属性的类型及遍历"></a>属性的类型及遍历</h3><h4 id="属性的类型"><a href="#属性的类型" class="headerlink" title="属性的类型"></a>属性的类型</h4><ol><li>普通属性</li><li>不可枚举的属性</li><li>原型属性</li><li>Symbol 属性</li><li>静态属性</li></ol><h4 id="属性的遍历"><a href="#属性的遍历" class="headerlink" title="属性的遍历"></a>属性的遍历</h4><table><thead><tr><th align="left">方法名称</th><th align="center">普通属性</th><th align="center">不可枚举属性</th><th align="center">Symbol 属性</th><th align="center">原型属性</th></tr></thead><tbody><tr><td align="left">for in</td><td align="center">√</td><td align="center">×</td><td align="center">×</td><td align="center">√</td></tr><tr><td align="left">Object.keys</td><td align="center">√</td><td align="center">×</td><td align="center">×</td><td align="center">×</td></tr><tr><td align="left">Object.getOwnPropertyNames</td><td align="center">√</td><td align="center">√</td><td align="center">×</td><td align="center">×</td></tr><tr><td align="left">Object.getOwnPropertySymbols</td><td align="center">×</td><td align="center">√</td><td align="center">√</td><td align="center">×</td></tr><tr><td align="left">Reflect.getOwnKeys</td><td align="center">√</td><td align="center">√</td><td align="center">√</td><td align="center">×</td></tr></tbody></table><h4 id="获得原型上的所有属性"><a href="#获得原型上的所有属性" class="headerlink" title="获得原型上的所有属性"></a>获得原型上的所有属性</h4><p>递归 –&gt; 剔除内置属性</p><h4 id="获取不可枚举属性"><a href="#获取不可枚举属性" class="headerlink" title="获取不可枚举属性"></a>获取不可枚举属性</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">getNoEummerable</span>(<span class="params">obj</span>) &#123;</span><br><span class="line"><span class="keyword">const</span> keys = <span class="title class_">Reflect</span>.<span class="title function_">ownKeys</span>(obj);</span><br><span class="line"><span class="keyword">const</span> result = keys.<span class="title function_">filter</span>( <span class="function"><span class="params">key</span> =&gt;</span> &#123;</span><br><span class="line"><span class="keyword">return</span> !<span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">propertyIsEmmerable</span>.<span class="title function_">call</span>(obj, key);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="多种克隆方式"><a href="#多种克隆方式" class="headerlink" title="多种克隆方式"></a>多种克隆方式</h3><h4 id="浅克隆"><a href="#浅克隆" class="headerlink" title="浅克隆"></a>浅克隆</h4><h5 id="对象浅克隆"><a href="#对象浅克隆" class="headerlink" title="对象浅克隆"></a>对象浅克隆</h5><ol><li>ES6 的扩展运算符「…」</li><li>Object.assign</li><li>for in 和其他的一层遍历复制</li></ol><h5 id="数组浅克隆"><a href="#数组浅克隆" class="headerlink" title="数组浅克隆"></a>数组浅克隆</h5><ol><li>ES6 的扩展运算符「…」</li><li>slice</li><li>[].concat</li></ol><h4 id="深克隆"><a href="#深克隆" class="headerlink" title="深克隆"></a>深克隆</h4><ol><li><p>JSON.parse(JSON.stringify(xxxxxxxx))</p><ol><li>只能复制普通键的属性，Symbol类型的无能为力</li><li>循环引用对象，例如 window 不能复制（可参考使用 WeakMap 解决）</li><li>函数、Date、Regex、Blob等类型不能复制（可通过构造函数识别）</li><li>性能低</li><li>可能爆栈（循环代替递归）</li></ol></li><li><p>消息通讯-BroadcastChannel、window.postMessage、Shared Worker、Message Channel 等</p><ol><li>循环引用对象，例如 window 不能复制</li><li>函数不能复制</li><li>同步变异步</li></ol> <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> chId = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">clone</span>(<span class="params">date</span>) &#123;</span><br><span class="line">chId++;</span><br><span class="line"><span class="keyword">var</span> cname = <span class="string">`__clone__<span class="subst">$&#123;chId&#125;</span>`</span>;</span><br><span class="line"><span class="keyword">var</span> ch1 = <span class="keyword">new</span> <span class="title class_">BroadcastChannel</span>(cname);</span><br><span class="line"><span class="keyword">var</span> ch2 = <span class="keyword">new</span> <span class="title class_">BroadcastChannel</span>(cname);</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> &#123;</span><br><span class="line">ch2.<span class="title function_">addEventListener</span>(<span class="string">&quot;message&quot;</span>, <span class="function"><span class="params">ev</span> =&gt;</span> <span class="title function_">resolve</span>(ev.<span class="property">data</span>), &#123; <span class="attr">once</span>: <span class="literal">true</span> &#125;);</span><br><span class="line">chi1.<span class="title function_">postMessage</span>(data);</span><br><span class="line">&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>手写深度克隆</p></li></ol><table><thead><tr><th align="left">深度克隆</th><th align="left">循环引用</th><th align="left">递归爆栈</th><th align="left">特殊类型</th></tr></thead><tbody><tr><td align="left">JSON 方式</td><td align="left">❌</td><td align="left">❌</td><td align="left">❌</td></tr><tr><td align="left">消息通讯方式</td><td align="left">❌</td><td align="left">❌</td><td align="left">✅（大部分）</td></tr><tr><td align="left">手写方式</td><td align="left">✅</td><td align="left">✅</td><td align="left">✅</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CSS 动画</title>
      <link href="/2022/05/02/%E5%89%8D%E7%AB%AF/CSS%20%E5%8A%A8%E7%94%BB/"/>
      <url>/2022/05/02/%E5%89%8D%E7%AB%AF/CSS%20%E5%8A%A8%E7%94%BB/</url>
      
        <content type="html"><![CDATA[<p>CSS 动画 API 不多，看似简单，但真正掌握它的同学不多，究其原因在于大家对动画理解过于浅表，要高度掌控 CSS 动画，必须从浏览器底层原理入手。从浏览器渲染原理、硬件加速、CSS Time 等角度来介绍 CSS 动画，从而有能力制作复杂的动画。</p><h2 id="浏览器渲染原理"><a href="#浏览器渲染原理" class="headerlink" title="浏览器渲染原理"></a>浏览器渲染原理</h2><ol><li>导航<ol><li>DNS 查找</li><li>TCP Handshake</li><li>TLS 协商</li></ol></li><li>响应<ol><li>TCP 慢开始 &#x2F; 14kb 规则</li><li>拥塞控制</li></ol></li><li>解析<ol><li>构建DOM树</li><li>预加载扫描器</li><li>构建CSSOM树</li><li>JavaScript 编译</li><li>构建辅助功能树</li></ol></li><li>渲染<ol><li>Style</li><li>Layout</li><li>Paint</li><li>Compositing</li></ol></li><li>交互：一旦主线程绘制页面完成，你会认为我们已经“准备好了”，但事实并非如此。如果加载包含JavaScript（并且延迟到onload事件激发后执行），则主线程可能很忙，无法用于滚动、触摸和其他交互</li></ol><p><img src="https://personal-blog.oss-cn-hangzhou.aliyuncs.com/front-draw-step.png"></p><p>一次网页绘制流程如下：</p><ol><li>Function Call</li><li>Recalculate Style</li><li>Layout</li><li>Paint Setup</li><li>Paint</li><li>Composite Layers</li></ol><p>在涉及到动画时，如果每一次绘制，就需要走完 6 个流程，那么性能无疑会很低，如果少经过几个环节，那么性能就能提升不少，例如：只经过 5、6 环节。</p><h2 id="动画优化"><a href="#动画优化" class="headerlink" title="动画优化"></a>动画优化</h2><p>示例：一个气球，从底部移动到顶部，如果使用不断改变 <code>top</code> 值的方式，可以实现，但是性能如何呢？</p><p><a href="https://csstriggers.com/transform">CSS Triggers</a> 可以了解 CSS 属性改变引起的方法调用链，链路越少越好。</p><p>如下示例 <code>top</code> 属性的情况：</p><p><img src="https://personal-blog.oss-cn-hangzhou.aliyuncs.com/front-fun-calls-top.png"></p><p>从图可知，每次改变 <code>top</code>，<code>Layout、Paint、Composite</code> 都会执行一次，因此性能不高也知道原因点了，可以考虑其他属性实现对应的效果。</p><h3 id="硬件加速"><a href="#硬件加速" class="headerlink" title="硬件加速"></a>硬件加速</h3><p>也叫 <strong>GPU 加速</strong>，GPU 擅长对 texture 进行 <strong>偏移、放大、缩小、旋转等</strong> 操作，并且，GPU 渲染时 <strong>跳过 Layout、Paint</strong>，只触发 <strong>Composite</strong>，因此速度极快。</p><p>那么，如何使用 GPU 呢，这里需要引入 <strong>Layer 模型</strong>，流程如下：</p><ol><li>CSS 属性为元素生成 Layer</li><li>Layer 会作为 texture 上传 GPU</li></ol><p>Layer 触发条件:</p><ol><li>3D、perspective、transform 属性</li><li>使用 animation、transition 改变 opacity、transform 的元素</li><li>video、canvas、flash、CSS filters 等</li></ol><h3 id="requestAnimationFrame"><a href="#requestAnimationFrame" class="headerlink" title="requestAnimationFrame"></a>requestAnimationFrame</h3><p><code>window.requestAnimationFrame()</code> 告诉浏览器——你希望执行一个动画，并且要求浏览器在下次重绘之前调用指定的回调函数更新动画。该方法需要传入一个回调函数作为参数，该回调函数会在浏览器下一次重绘之前执行。</p><p>注意：为了提高性能和电池寿命，因此在大多数浏览器里，当<code>requestAnimationFrame()</code> 运行在后台标签页或者隐藏的「&lt;iframe&gt;」里时，<code>requestAnimationFrame()</code> 会被暂停调用以提升性能和电池寿命。</p><p><strong>语法</strong></p><blockquote><p>window.requestAnimationFrame(callback);</p><p><strong>参数</strong></p><p>callback: 下一次重绘之前更新动画帧所调用的函数(即上面所说的回调函数)。该回调函数会被传入 DOMHighResTimeStamp 参数，该参数与 performance.now() 的返回值相同，它表示 requestAnimationFrame() 开始去执行回调函数的时刻。</p><p><strong>返回值</strong></p><p>一个 long 整数，请求 ID ，是回调列表中唯一的标识。是个非零值，没别的意义。你可以传这个值给 <code>window.cancelAnimationFrame()</code> 以取消回调函数。</p></blockquote><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> element = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;some-element-you-want-to-animate&#x27;</span>);</span><br><span class="line"><span class="keyword">let</span> start;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">step</span>(<span class="params">timestamp</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (start === <span class="literal">undefined</span>)</span><br><span class="line">    start = timestamp;</span><br><span class="line">  <span class="keyword">const</span> elapsed = timestamp - start;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//这里使用`Math.min()`确保元素刚好停在200px的位置。</span></span><br><span class="line">  element.<span class="property">style</span>.<span class="property">transform</span> = <span class="string">&#x27;translateX(&#x27;</span> + <span class="title class_">Math</span>.<span class="title function_">min</span>(<span class="number">0.1</span> * elapsed, <span class="number">200</span>) + <span class="string">&#x27;px)&#x27;</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (elapsed &lt; <span class="number">2000</span>) &#123; <span class="comment">// 在两秒后停止动画</span></span><br><span class="line">    <span class="variable language_">window</span>.<span class="title function_">requestAnimationFrame</span>(step);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">window</span>.<span class="title function_">requestAnimationFrame</span>(step);</span><br></pre></td></tr></table></figure><p><strong>触发 Layout 情况 <a href="https://csstriggers.com/transform">CSS Triggers</a></strong></p><ul><li>改变 <code>width、height、margin</code> 等和 <strong>大小、位置</strong> 相关的属性</li><li>读取 <code>size、position</code> 相关属性</li></ul><p>解决方案：尽量使用 <code>transform</code> 代替 <code>top、left</code> 的动画。</p><p><strong>引起 Layout 的属性读取：</strong><code>clientHeight</code>、<code>clientLeft</code>、<code>clientTop</code>、<code>clientWidth</code>、<code>focus()</code>、<code>getBoundingClientRect()</code>、<code>getClientRects()</code>、<code>innerText</code>、<code>offsetHeight</code>、<code>offsetLeft</code>、<code>offsetParent</code>、<code>offsetTop</code>、<code>offsetWidth</code>、<code>outerText</code>、<code>scrollByLines()</code>、<code>scrollByPages()</code>、<code>scrollheight</code>、<code>scrollIntoView()</code>、<code>scrollIntoViewIfNeeded()</code>、<code>scrollLeft</code>、<code>scrollTop</code>、<code>scrollWidth</code> ……</p><p>解决方案：尽量 <strong>先读后写</strong>。多次读取降低为少次，甚至一次。</p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CSS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CSS 设计模式</title>
      <link href="/2022/04/19/%E5%89%8D%E7%AB%AF/CSS%20%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
      <url>/2022/04/19/%E5%89%8D%E7%AB%AF/CSS%20%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<p>除了 CSS 编写之外，<strong>CSS 设计模式</strong> 也是重中之重，如果前期不重视 CSS 规划，后期维护或者重构时，在几百个甚至更多文件中寻找并调整样式，将是一场灾难。为了 CSS 能更好的维护，接下来介绍几种常用的设计模式。</p><h2 id="OOCSS"><a href="#OOCSS" class="headerlink" title="OOCSS"></a>OOCSS</h2><p>「OO」即面向对象，采用面向对象思维来设计 CSS。</p><p>大致思路示例如下：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Father</span> &#123;</span><br><span class="line"><span class="title function_">action</span>()</span><br><span class="line"><span class="title function_">eat</span>()</span><br><span class="line"><span class="title function_">run</span>()</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Child</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Father</span> &#123;</span><br><span class="line"><span class="title function_">action</span>() <span class="comment">// 对父方法进行改动</span></span><br><span class="line"><span class="title function_">study</span>() <span class="comment">// 扩展方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>基于前面示例代码，可以考虑定义 <strong>公共 CSS</strong>，然后再进行改造或扩展。示例代码如下：</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line">&lt;<span class="selector-tag">div</span> class=&quot;item&quot;&gt;&lt;/<span class="selector-tag">div</span>&gt;</span><br><span class="line">&lt;<span class="selector-tag">div</span> class=&quot;item&quot;&gt;&lt;/<span class="selector-tag">div</span>&gt;</span><br><span class="line">&lt;<span class="selector-tag">div</span> class=&quot;item&quot;&gt;&lt;/<span class="selector-tag">div</span>&gt;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.item</span> &#123;</span><br><span class="line"><span class="attribute">color</span>: green;</span><br><span class="line"><span class="attribute">font-size</span>: <span class="number">14px</span>;</span><br><span class="line">// 其他属性</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>设想，如果想对第二个 div 调整为红色，如果直接更改 <strong>.item</strong> 里面的颜色显然是不合理的，重新写一份代价也大，如何处理呢？</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line">&lt;<span class="selector-tag">div</span> class=&quot;item&quot;&gt;&lt;/<span class="selector-tag">div</span>&gt;</span><br><span class="line">&lt;<span class="selector-tag">div</span> class=&quot;item item-red&quot;&gt;&lt;/<span class="selector-tag">div</span>&gt;</span><br><span class="line">&lt;<span class="selector-tag">div</span> class=&quot;item&quot;&gt;&lt;/<span class="selector-tag">div</span>&gt;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.item</span> &#123;</span><br><span class="line"><span class="attribute">color</span>: green;</span><br><span class="line"><span class="attribute">font-size</span>: <span class="number">14px</span>;</span><br><span class="line">// 其他属性</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.item-red</span> &#123;</span><br><span class="line"><span class="attribute">color</span>: red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如此，就可以符合要求，并不影响其他区域，并且改动量最少。</p><p>原则：</p><ol><li>容器与内容分离</li><li>结构（基础对象）与皮肤分离</li><li>面向设计开发</li></ol><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 容器与内容分离 --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- post 中的 meta-data --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;post&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">&quot;meta-data&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;#&quot;</span>&gt;</span>Information<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- comment 中的 meta-data --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;comment&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">&quot;meta-data&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;#&quot;</span>&gt;</span>Information<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 方式一，不推荐 --&gt;</span></span><br><span class="line">.post .meta-data &#123;</span><br><span class="line">    <span class="comment">&lt;!-- css code --&gt;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 方式二 --&gt;</span></span><br><span class="line">.post &#123;</span><br><span class="line">    <span class="comment">&lt;!-- css code --&gt;</span></span><br><span class="line">&#125;</span><br><span class="line">.meta-data &#123;</span><br><span class="line">    <span class="comment">&lt;!-- css code --&gt;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 结构（基础对象）与皮肤分离 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;item skin&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">.item &#123;</span><br><span class="line">color: green;</span><br><span class="line">font-size: 14px;</span><br><span class="line">// 其他属性</span><br><span class="line">&#125;</span><br><span class="line">.skin &#123;</span><br><span class="line">background-color: white;</span><br><span class="line">    // 其他样式</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="BEM"><a href="#BEM" class="headerlink" title="BEM"></a>BEM</h2><ul><li>块：Block</li><li>元素：Element__</li><li>修饰符：Modifier–</li></ul><p>作用：命名规范、让页面结构清晰。</p><p>也可称为：进阶版的 OOCSS。</p><h2 id="SMACSS"><a href="#SMACSS" class="headerlink" title="SMACSS"></a>SMACSS</h2><p>分类：Base、Layout、Modules、State、Theme</p><p>好处：易维护、易复用、易扩展</p><p>SMACSS（Scalable and Modular Architecture for CSS）是指可伸缩及模块化的 CSS 架构，由 Jonathan Snook 在 2011 年雅虎工作时提出。他在 OOCSS 和 BEM 的基础上添加了五种类别的组件的处理规则，具体如下所列：</p><ol><li>基础（Base）：是为HTML元素定义默认样式，可以包含属性、伪类等选择器；</li><li>布局（Layout）：会将页面分为几部分，可作为高级容器包含一个或多个模块，例如左右分栏、栅格系统等；</li><li>模块（Module）：又名对象或块，是可重用的模块化部分，例如导航栏、产品列表等；</li><li>状态（State）：描述的是任一模块或布局在特定状态下的外观，例如隐藏、激活等；</li><li>主题（Theme）：也就是换肤，描述了页面的外观，它可修改前面四个类别的样式，例如链接颜色、布局方式等；</li></ol><p>通过相应的命名前缀来完成对类别的表示：</p><ul><li>l- 用作布局的前缀，例如 .l-inline、.layout-grid 等；</li><li>m- 模块命名前缀，例如 .m-profile、.field 等；</li><li>is- 用作状态的前缀，例如 .is-collapsed、.is-active 等；</li><li>theme- 用作主题的前缀，例如 .theme-a-background、.theme-l-grid 等。</li></ul><h2 id="ITCSS"><a href="#ITCSS" class="headerlink" title="ITCSS"></a>ITCSS</h2><p>ITCSS 和 SMACSS 其实是很像的，只不过 SMACSS 是对 CSS 做了一个分类处理，而 ITCSS 是对 CSS 做了一个分层处理。分层是纵向的，从上往下，层层关联的。</p><ul><li>分层：七层</li><li>与 SMACSS 区别：层次分得更细</li></ul><p><img src="https://personal-blog.oss-cn-hangzhou.aliyuncs.com/itcss.png"></p><ol><li>Settings（设置）：包含字体、颜色定义等，通常定义可以自定义模板的变量。</li><li>Tools（工具）: mixin，function 主要结合预处理器使用</li><li>Generic（常规）：重置和&#x2F;或标准化样式、框大小定义等，例如 normalize.css、reset.css</li><li>Elements（元素）：定义网站 HTML 元素的样式（如 H1 标签默认样式等）</li><li>Objects（对象）：类名样式中，不允许出现外观属性，例如 Color，概念和 OOCSS 这个设计模式中的 struct 类似</li><li>Components（组件）：用于设置任何页面元素和所有页面元素样式的美学类（通常与对象类的结构结合使用）</li><li>Trumps（important）：最重要的样式，用于覆盖三角形中的任何其他内容。实用程序和辅助类，能够覆盖三角形中前面的任何内容，唯一 important! 的地方</li></ol><p>TRUMPS 有时也写为 UTILITIES，Elements 也可以作为 Base。越往上它的复用性越好。</p><h2 id="ACSS"><a href="#ACSS" class="headerlink" title="ACSS"></a>ACSS</h2><p>一个样式属性一个类。示例：<a href="https://www.tailwindcss.cn/">tailwindcss</a></p><p>好处：极强的复用性、维护成本低。</p><p>坏处：破坏了 CSS 命名的语义化。</p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CSS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>文字环绕布局</title>
      <link href="/2022/04/16/%E5%89%8D%E7%AB%AF/%E6%96%87%E5%AD%97%E7%8E%AF%E7%BB%95%E5%B8%83%E5%B1%80/"/>
      <url>/2022/04/16/%E5%89%8D%E7%AB%AF/%E6%96%87%E5%AD%97%E7%8E%AF%E7%BB%95%E5%B8%83%E5%B1%80/</url>
      
        <content type="html"><![CDATA[<p>除了常规的线性布局、网格布局之外，文字环绕布局也是一个常见场景，比如图文混排。因此，对图文混排进行归纳也是很有必要的。</p><p>常见的方案有三种，分别是：<strong>float 浮动</strong>、<strong>CSS Shapes 模块</strong> 以及 <strong>CSS Exclusion 模块</strong>。</p><h2 id="利用-float-浮动实现文字环绕"><a href="#利用-float-浮动实现文字环绕" class="headerlink" title="利用 float 浮动实现文字环绕"></a>利用 float 浮动实现文字环绕</h2><p>假设在一个布局中有上下 2 个元素，如果给上面的元素添加 float，会使其脱离文档流，从而让下面元素跑到上面元素的后面。</p><p>但是如果下面元素是一段文本的话，那么将无法跑到元素的后面，而是会产生文字环绕的效果。为什么会这样呢？主要是因为最初设计的初衷就是为了实现这种文字环绕的效果。</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css"><span class="selector-class">.main</span> &#123;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">width</span>: <span class="number">300px</span>;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">border</span>: <span class="number">1px</span> black solid;</span></span><br><span class="line"><span class="language-css">&#125;</span></span><br><span class="line"><span class="language-css"><span class="selector-class">.box</span> &#123;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">width</span>: <span class="number">100px</span>;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">height</span>: <span class="number">100px</span>;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">background</span>: pink;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">float</span>: left;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">margin</span>: <span class="number">10px</span>;</span></span><br><span class="line"><span class="language-css">&#125;</span></span><br><span class="line"><span class="language-css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;main&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;box&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    ^测试文字测试文字测试文字测试文字测试文字测试文字测试文字测试文字测试文字测试文字测试文字测试文字测试文字测试文字测试文字测试文字测试文字测试文字测试文字测试文字测试文字测试文字$</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>左浮动会产生右环绕，同理右浮动会产生左环绕。但是同时出现左右环绕，目前 float 属性还做不到。但是可以发现实现对文字的左右环绕方式。</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css"><span class="selector-class">.main</span> &#123;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">width</span>: <span class="number">300px</span>;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">border</span>: <span class="number">1px</span> black solid;</span></span><br><span class="line"><span class="language-css">&#125;</span></span><br><span class="line"><span class="language-css"><span class="selector-class">.box1</span>, <span class="selector-class">.box2</span> &#123;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">width</span>: <span class="number">100px</span>;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">height</span>: <span class="number">100px</span>;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">background</span>: pink;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">float</span>: right;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">margin</span>: <span class="number">10px</span>;</span></span><br><span class="line"><span class="language-css">&#125;</span></span><br><span class="line"><span class="language-css"><span class="selector-class">.box2</span> &#123;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">float</span>: left;</span></span><br><span class="line"><span class="language-css">&#125;</span></span><br><span class="line"><span class="language-css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;main&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;box1&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    ^测试文字测试文字测试文字测试文字测试文字测试文字测试文字测试文字测试文字测试文字测试文字测试文字测试文字测试文字测试文字测试文字测试文字测试文字测试文字测试文字测试文字测试文字$</span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;box2&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    ^测试文字测试文字测试文字测试文字测试文字测试文字测试文字测试文字测试文字测试文字测试文字测试文字测试文字测试文字测试文字测试文字测试文字测试文字测试文字测试文字测试文字测试文字$</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="利用-CSS-Shapes-模块实现文字环绕"><a href="#利用-CSS-Shapes-模块实现文字环绕" class="headerlink" title="利用 CSS Shapes 模块实现文字环绕"></a>利用 CSS Shapes 模块实现文字环绕</h2><p> CSS Shapes 是一个 CSS 模块，用于定义几何形状。CSS Shapes 模块可以实现不规则的文字环绕效果，需要和浮动配合使用。</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css"><span class="selector-class">.main</span> &#123;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">width</span>: <span class="number">300px</span>;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">border</span>: <span class="number">1px</span> black solid;</span></span><br><span class="line"><span class="language-css">&#125;</span></span><br><span class="line"><span class="language-css"><span class="selector-class">.box</span> &#123;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">width</span>: <span class="number">100px</span>;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">height</span>: <span class="number">100px</span>;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">background</span>: pink;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">float</span>: left;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">margin</span>: <span class="number">10px</span>;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">border-radius</span>: <span class="number">50%</span>;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">shape-outside</span>: margin-box;</span></span><br><span class="line"><span class="language-css">&#125;</span></span><br><span class="line"><span class="language-css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;main&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;box&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    ^测试文字测试文字测试文字测试文字测试文字测试文字测试文字测试文字测试文字测试文字测试文字测试文字测试文字测试文字测试文字测试文字测试文字测试文字测试文字测试文字测试文字测试文字测试文字测试文字测试文字测试文字测试文字测试文字$</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>文字会围绕着圆形的边界进行环绕，而普通的 float 浮动环绕是做不到的。<strong>shape-outside</strong> 的可选值比较多：</p><ul><li>none：默认值</li><li>shape-box：图形盒子。<ul><li>margin-box：沿着 margin 区域进行环绕</li><li>border-box：沿着元素 border 区域进行环绕</li><li>padding-box：沿着元素 padding 区域进行环绕</li><li>content-box：沿着元素 content 区域进行环绕</li></ul></li><li>basic-shape：基本图形函数。<ul><li>circle()：沿着圆形区域进行环绕</li><li>ellipse()：沿着椭圆形区域进行环绕</li><li>polygon()：沿着自定义的折现区域进行环绕</li></ul></li><li>image：图像类。</li></ul><p>示例：结合 clip-path 属性完成一个围绕三角形区域进行的文字环绕。</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line">.box &#123;</span><br><span class="line">    width: 100px;</span><br><span class="line">    height: 100px;</span><br><span class="line">    background: pink;</span><br><span class="line">    float: left;</span><br><span class="line">    margin: 10px;</span><br><span class="line">    clip-path: polygon(0 0, 0 100px, 100px 100px);</span><br><span class="line">    shape-outside: polygon(0 0, 0 100px, 100px 100px);</span><br><span class="line">    shape-margin: 15px;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>还可以让文字环绕特殊图片，需要配合 <strong>mask</strong> 完成，而且需要在服务器环境下运行代码，因为图片的访问有浏览器的安全限制。</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line">.box &#123;</span><br><span class="line">    width: 100px;</span><br><span class="line">    height: 164px;</span><br><span class="line">    float: left;</span><br><span class="line">    margin: 10px;</span><br><span class="line">    shape-outside: url(./birds.png);</span><br><span class="line">    shape-margin: 5px;</span><br><span class="line">    background-color: pink;</span><br><span class="line">    -webkit-mask: url(./birds.png) no-repeat;</span><br><span class="line">    mask: url(./birds.png) no-repeat;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="利用-CSS-Exclusion-模块实现文字环绕"><a href="#利用-CSS-Exclusion-模块实现文字环绕" class="headerlink" title="利用 CSS Exclusion 模块实现文字环绕"></a>利用 CSS Exclusion 模块实现文字环绕</h2><p> CSS Exclusion 是 Adobe 的另一项提议，旨在扩展 CSS 的现有可能性（以避免浮动的限制），并能够构建允许内联内容流入和&#x2F;或围绕圆形或其他任意复杂形状的布局。</p><p>利用 CSS Exclusion 模块可以实现类似于 Word 文档的方式，可以让文字四周环绕布局，不过 CSS Exclusion 模块目前浏览器的支持程度还不高，只能针对 IE10+ 的浏览器起作用。</p><p>CSS Exclusion 模块主要使用 <strong>wrap-flow</strong> 属性，可选值有：</p><ul><li>start</li><li>end</li><li>both</li><li>clear</li></ul><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css"><span class="selector-class">.main</span> &#123;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">width</span>: <span class="number">300px</span>;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">border</span>: <span class="number">1px</span> black solid;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">position</span>: relative;</span></span><br><span class="line"><span class="language-css">&#125;</span></span><br><span class="line"><span class="language-css"><span class="selector-class">.box</span> &#123;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">width</span>: <span class="number">100px</span>;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">height</span>: <span class="number">100px</span>;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">background-color</span>: pink;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">position</span>: absolute;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">left</span>: <span class="number">50%</span>;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">top</span>: <span class="number">50%</span>;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">margin</span>: -<span class="number">50px</span>;</span></span><br><span class="line"><span class="language-css">    -ms-wrap-<span class="attribute">flow</span>: both;</span></span><br><span class="line"><span class="language-css">    -webkit-wrap-<span class="attribute">flow</span>: both;</span></span><br><span class="line"><span class="language-css">&#125; </span></span><br><span class="line"><span class="language-css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;main&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;box&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    ^测试文字测试文字测试文字测试文字测试文字测试文字测试文字测试文字测试文字测试文字测试文字测试文字测试文字测试文字测试文字测试文字测试文字测试文字测试文字测试文字测试文字测试文字测试文字测试文字测试文字测试文字测试文字测试文字测试文字测试文字测试文字测试文字测试文字测试文字测试文字测试文字测试文字测试文字测试文字测试文字测试文字测试文字测试文字测试文字$</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CSS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CSS 方法论及样式规范</title>
      <link href="/2022/04/12/%E5%89%8D%E7%AB%AF/CSS%20%E6%96%B9%E6%B3%95%E8%AE%BA%E5%8F%8A%E6%A0%B7%E5%BC%8F%E8%A7%84%E8%8C%83/"/>
      <url>/2022/04/12/%E5%89%8D%E7%AB%AF/CSS%20%E6%96%B9%E6%B3%95%E8%AE%BA%E5%8F%8A%E6%A0%B7%E5%BC%8F%E8%A7%84%E8%8C%83/</url>
      
        <content type="html"><![CDATA[<p>除了前面介绍的 CSS 文件划分及功能分类，CSS 还应有 <strong>方法论</strong> 及 <strong>样式规范</strong>，从而更好的组织 CSS。</p><h2 id="CSS-方法论"><a href="#CSS-方法论" class="headerlink" title="CSS 方法论"></a>CSS 方法论</h2><p>方法论是一个哲学术语，会对一系列具体的方法进行分析研究、系统总结并最终提出较为一般性的原则。CSS方法论是一种面向CSS、由个人和组织设计、已被诸多项目检验且公认有效的最佳实践。这些方法论都会涉及结构化的命名约定，并且在组织CSS时可提供相应的指南，从而提升代码的性能、可读性以及可维护性。</p><p>常见的CSS方法论有：</p><ul><li>OOCSS</li><li>BEM</li><li>SMACSS</li><li>Atomic CSS</li></ul><p>BEM（Block Element Modifier）是指块级元素修饰符，BEM 分为三部分：</p><ul><li>块（Block）：是一个独立实体，最高级抽象，例如菜单、文本框等。</li><li>元素（Element）：是块的组成部分，被包含在块中，无法自成一体，例如菜单项、标题等。</li><li>修饰符（Modifier）：是块或元素的状态，可更改它们的外观或行为，例如高亮、选中等。</li></ul><p>BEM 中的 <code>块</code>、<code>元素</code> 和 <code>修饰符</code> 需要 <strong>全部小写</strong>，名称中的单词用连字符 <strong>「-」</strong>分割，<code>元素</code> 由 <strong>双下划线（__）</strong>分割，<code>修饰符</code> 由 <strong>双连字符（–）</strong>分割。注意，<code>块</code> 和 <code>元素</code> 既不能是 HTML 元素名或 ID，也不依赖其它块或元素。</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.setting-menu</span>&#123;&#125; // 表示一个独立实体</span><br><span class="line"><span class="selector-class">.setting-menu--open</span>&#123;&#125; // 对配置菜单展开状态的一种行为描述</span><br><span class="line"><span class="selector-class">.setting-menu__head</span>&#123;&#125; // 表示独立实体的组成部分</span><br><span class="line"><span class="selector-class">.setting-menu__head--fixed</span>&#123;&#125; // 对配置菜单头部固定状态的一种行为描述</span><br><span class="line"><span class="selector-class">.setting-menu__content</span>&#123;&#125; // 表示独立实体的组成部分</span><br></pre></td></tr></table></figure><p>SMACSS（Scalable and Modular Architecture for CSS）是指可伸缩及模块化的 CSS 架构，由 Jonathan Snook 在 2011 年雅虎工作时提出。他在 OOCSS 和 BEM 的基础上添加了五种类别的组件的处理规则，具体如下所列：</p><ol><li>基础（Base）：是为HTML元素定义默认样式，可以包含属性、伪类等选择器；</li><li>布局（Layout）：会将页面分为几部分，可作为高级容器包含一个或多个模块，例如左右分栏、栅格系统等；</li><li>模块（Module）：又名对象或块，是可重用的模块化部分，例如导航栏、产品列表等；</li><li>状态（State）：描述的是任一模块或布局在特定状态下的外观，例如隐藏、激活等；</li><li>主题（Theme）：也就是换肤，描述了页面的外观，它可修改前面四个类别的样式，例如链接颜色、布局方式等；</li></ol><p>通过相应的命名前缀来完成对类别的表示：</p><ul><li>l- 用作布局的前缀，例如 .l-inline、.layout-grid 等；</li><li>m- 模块命名前缀，例如 .m-profile、.field 等；</li><li>is- 用作状态的前缀，例如 .is-collapsed、.is-active 等；</li><li>theme- 用作主题的前缀，例如 .theme-a-background、.theme-l-grid 等。</li></ul><p>在实际工作中，不需要局限于某一个 CSS 方法论，很多时候可以结合使用，共享模块化 CSS 的规则。例如遵循 BEM 的命名约定，以及 SMACSS 的分类前缀，具体如下所列：</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.m-setting-menu</span>&#123;&#125;</span><br><span class="line"><span class="selector-class">.m-setting-menu--open</span>&#123;&#125;</span><br><span class="line"><span class="selector-class">.m-setting-menu__head</span>&#123;&#125;</span><br><span class="line"><span class="selector-class">.m-setting-menu__head--fixed</span>&#123;&#125;</span><br><span class="line"><span class="selector-class">.m-setting-menu__content</span>&#123;&#125;</span><br></pre></td></tr></table></figure><p>任何软件设计都存在不完美的地方，CSS 方法论也是一样。比如：命名过长不易维护；HTML 不够简洁等。但是它带来的巨大优势也是非常明显的，比如：样式不容易冲突，尤其是复杂的样式结构；清晰的 CSS 架构，对大型 CSS 项目管理维护非常重要等。</p><h2 id="样式规范"><a href="#样式规范" class="headerlink" title="样式规范"></a>样式规范</h2><ol><li>使用类选择器，放弃 ID 选择器：ID 在一个页面中的唯一性导致了如果以 ID 为选择器来写 CSS，就无法重用；</li><li>命名应简约而不失语义：反对过长命名和没有语义的命名，如：<code>.m-navigation</code>、<code>.m-abc</code>，推荐 <code>.m-nav</code>；</li><li>相同语义的不同类命名：直接加数字或字母区分即可（如：<code>.m-list</code>、<code>.m-list2</code>、<code>.m-list3</code> 等，都是列表模块，但是是完全不一样的模块）；</li><li>防止污染和被污染：为了防止后代选择器污染，尽量采用 &gt; 方式，例如：-m-nav&gt;li，而不是 -m-nav li；</li><li>最后一个值也以分号结尾：通常在大括号结束前的值可以省略分号，但是这样做会对修改、添加和维护工作带来不必要的失误和麻烦；</li><li>省略值为 0 时的单位：为节省不必要的字节同时也使阅读方便，我们将 0px、0em、0% 等值缩写为 0；</li><li>根据属性的重要性按顺序书写：先显示定位布局类属性，后盒模型等自身属性，最后是文本类及修饰类属性。例如：.m-box{position:relative;width:600px;margin:0 auto 10px;text-align:center;color:#000;}；</li><li>CSS 需要进行格式化和对齐处理：推荐 VSCode 插件；</li></ol><h2 id="样式断点"><a href="#样式断点" class="headerlink" title="样式断点"></a>样式断点</h2><p><strong>断点名称 断点描述）</strong></p><ol><li>mobile 移动设备断点，视窗宽度 ≤ 768 px</li><li>tablet 平板电脑设备断点，视窗宽度 ≥ 769 px</li><li>desktop 桌⾯电脑断点，视窗宽度 ≥ 1024 px</li><li>widescreen宽屏电脑断点，视窗宽度 ≥ 1216 px</li><li>fullhd ⾼清宽屏电脑断点，视窗宽度 ≥ 1408 px</li></ol>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CSS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CSS文件划分及功能分类</title>
      <link href="/2022/04/12/%E5%89%8D%E7%AB%AF/CSS%E6%96%87%E4%BB%B6%E5%88%92%E5%88%86%E5%8F%8A%E5%8A%9F%E8%83%BD%E5%88%86%E7%B1%BB/"/>
      <url>/2022/04/12/%E5%89%8D%E7%AB%AF/CSS%E6%96%87%E4%BB%B6%E5%88%92%E5%88%86%E5%8F%8A%E5%8A%9F%E8%83%BD%E5%88%86%E7%B1%BB/</url>
      
        <content type="html"><![CDATA[<p>在了解 CSS 之后，把 CSS 运用到实际项目中，将 CSS 写入 html 文件显然是不合理的。那么，如何对 CSS 进行划分，一般参考 <strong>文件划分</strong> 以及 <strong>功能分类</strong>。</p><h2 id="CSS-文件划分"><a href="#CSS-文件划分" class="headerlink" title="CSS 文件划分"></a>CSS 文件划分</h2><p>在中大型项目中，一般会对 CSS 进行文件划分，根据文件的性质与用途，大概会分成：</p><ul><li>公共型样式</li><li>特殊型样式</li><li>皮肤型样式</li></ul><p><strong>公共型样式</strong> 可命名为 global.css 或 common.css 等，主要包括通用样式编写，例如：重置默认样式 reset、网站通用布局、通用模块和元件、通用响应式系统等。</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 重置样式 */</span></span><br><span class="line">省略 css 代码...</span><br><span class="line"><span class="comment">/* 网站通用布局 */</span></span><br><span class="line">省略 css 代码...</span><br><span class="line"><span class="comment">/* 通用模块 */</span></span><br><span class="line">省略 css 代码...</span><br><span class="line"><span class="comment">/* 通用元件 */</span></span><br><span class="line">省略 css 代码...</span><br><span class="line"><span class="comment">/* 通用响应式系统 */</span></span><br><span class="line">省略 css 代码...</span><br></pre></td></tr></table></figure><p><strong>特殊型样式</strong> 主要是根据当前页面来决定的文件，只针对当前页面做出特殊处理的样式，例如：只在首页中用到的样式可放置到 index.css 中，在登录页中用到的样式可放置到 login.css 中。</p><p><strong>皮肤型样式</strong> 是针对网站需要皮肤功能时，把颜色、背景等抽离出来放到文件中的形式，例如 theme-pink.css、theme-skyblue.css 等。</p><p>CSS 文件的引入顺序如下：</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line">&lt;link href=&quot;assets/css/global<span class="selector-class">.css</span>&quot; rel=&quot;stylesheet&quot; type=&quot;text/css&quot;/&gt;</span><br><span class="line">&lt;link href=&quot;assets/css/index<span class="selector-class">.css</span>&quot; rel=&quot;stylesheet&quot; type=&quot;text/css&quot;/&gt;</span><br><span class="line">&lt;link href=&quot;assets/css/theme<span class="selector-class">.css</span>&quot; rel=&quot;stylesheet&quot; type=&quot;text/css&quot;/&gt;</span><br></pre></td></tr></table></figure><h2 id="CSS-功能分类"><a href="#CSS-功能分类" class="headerlink" title="CSS 功能分类"></a>CSS 功能分类</h2><p>除了公共型样式，在文件中具体包括哪些常见的功能呢？大概可分为如下几类：</p><ul><li>重置样式</li><li>网站通用布局</li><li>通用模块</li><li>通用元件</li><li>通用响应式系统</li></ul><p><strong>重置样式</strong> 主要是去除默认样式和统一不同设备下的表现形态。通常为 Reset CSS 代码和 Normalize CSS 代码的结合版本。</p><p><strong>网站通用布局</strong> 主要指的是对网站中出现的大块结构进行排版。如：PC 端中的菜单、内容的左右布局方案；移动端中的头部、列表、尾部的上中下布局方案等。</p><p><strong>通用模块</strong> 指的是网页中可以重复使用的较大的整体，比如导航、登录、注册、各种列表、评论、搜索等。</p><p><strong>通用原件</strong> 指的是不可再分的较为小巧的个体，通常被重复用于各种模块中，比如按钮、输入框、loading、图标等。</p><p><strong>通用响应式系统</strong> 指的是在不同设备下要实现响应式布局，当满足了某个断点设定后调用的相应变化样式，比如浮动添加、栅格生效、显示隐藏、版心宽度等。</p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CSS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CSS 深入学习</title>
      <link href="/2022/03/20/%E5%89%8D%E7%AB%AF/CSS%20%E6%B7%B1%E5%85%A5%E5%AD%A6%E4%B9%A0/"/>
      <url>/2022/03/20/%E5%89%8D%E7%AB%AF/CSS%20%E6%B7%B1%E5%85%A5%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<p>在了解 HTML 基础、CSS 基础、动画基础后，简单的 CSS 样式已经没有什么压力。但是还需趁热打铁，继续深入学习，只有深入，方能浅出。</p><p>本次学习，将深入 <strong>flex 弹性布局</strong>、<strong>grid 网格布局</strong>、<strong>移动端适配布局</strong>、<strong>响应式布局</strong>，熟练掌握现代布局四大核心技术。</p><h2 id="CSS-的研究方向"><a href="#CSS-的研究方向" class="headerlink" title="CSS 的研究方向"></a>CSS 的研究方向</h2><ul><li>特效<ul><li>动画</li><li>3D</li><li>渐变</li><li>…</li></ul></li><li>工程化<ul><li>sass&#x2F;scss</li><li>less</li><li>postcss</li></ul></li><li>布局<ul><li>flex</li><li>grid</li><li>响应式</li></ul></li></ul><h2 id="长度"><a href="#长度" class="headerlink" title="长度"></a>长度</h2><p> CSS 中有两种长度单位，<strong>绝对长度单位</strong> 和 <strong>相对长度单位</strong>。</p><h3 id="绝对长度单位"><a href="#绝对长度单位" class="headerlink" title="绝对长度单位"></a>绝对长度单位</h3><table><thead><tr><th align="center">单位</th><th align="center">名称</th></tr></thead><tbody><tr><td align="center">cm</td><td align="center">厘米</td></tr><tr><td align="center">mm</td><td align="center">毫米</td></tr><tr><td align="center">in</td><td align="center">英寸</td></tr><tr><td align="center">pt</td><td align="center">点</td></tr><tr><td align="center">px</td><td align="center">像素</td></tr></tbody></table><h3 id="相对长度单位"><a href="#相对长度单位" class="headerlink" title="相对长度单位"></a>相对长度单位</h3><p>相对长度档位相对于其他一些东西，比如：父元素的字体大小，或者视图窗口的大小。使用相对单位的好处是，经过一些仔细的规划，可以使文本或其他元素的大小与页面上的其他内容相对应。</p><table><thead><tr><th align="center">单位</th><th align="center">名称</th></tr></thead><tbody><tr><td align="center">em</td><td align="center">在 font-size 中使用的是相对应父元素的字体大小，在其他属性中使用的是相对于自身的字体大小</td></tr><tr><td align="center">ex</td><td align="center">字符「x」的高度</td></tr><tr><td align="center">ch</td><td align="center">数字「0」的宽度</td></tr><tr><td align="center">rem</td><td align="center">根元素的字体大小</td></tr><tr><td align="center">lh</td><td align="center">元素的 lint-height</td></tr><tr><td align="center">vw</td><td align="center">视窗宽度的 1%</td></tr><tr><td align="center">vh</td><td align="center">视窗高度的 1%</td></tr><tr><td align="center">vmin</td><td align="center">视窗小尺寸的 1%</td></tr><tr><td align="center">vmax</td><td align="center">视窗大尺寸的 1%</td></tr></tbody></table><h2 id="颜色"><a href="#颜色" class="headerlink" title="颜色"></a>颜色</h2><ol><li>颜色关键字：例如：red、blue</li><li>RGB：例如：rgb(0, 0, 0)<ul><li>R：红色</li><li>G：绿色</li><li>B：蓝色</li></ul></li><li>HEX：例如：0xFF0000<ul><li>rr：红色</li><li>gg：绿色</li><li>bb：蓝色</li></ul></li><li>HSL：例如：hsl(0, 100%, 50%)<ul><li>色相（hue）：色轮上从 0 到 360 的度数。0 是红色，120 是绿色，240 是蓝色；</li><li>饱和度（saturation）：是一个百分比值，0% 表示灰色阴影，100% 是全色；</li><li>亮度（lightness）：是一个百分比值，0% 是黑色，50% 是即不明也不暗，100% 是白色；</li></ul></li></ol><h2 id="CSS-盒模型的注意点"><a href="#CSS-盒模型的注意点" class="headerlink" title="CSS 盒模型的注意点"></a>CSS 盒模型的注意点</h2><ul><li>padding 不能为负值，而 margin 可以为负值</li><li>背景色会平铺到非 margin 的区域</li><li>margin-top 传递的现象及解决方案</li><li>margin 上下叠加的现象及解决方案</li></ul><h3 id="块级盒子的特性"><a href="#块级盒子的特性" class="headerlink" title="块级盒子的特性"></a>块级盒子的特性</h3><ul><li>独占一行</li><li>支持所有样式</li><li>不写宽度的时候，跟父容器的宽度相同</li><li>所占区域是一个矩形</li></ul><h3 id="内联盒子的特性"><a href="#内联盒子的特性" class="headerlink" title="内联盒子的特性"></a>内联盒子的特性</h3><ul><li>盒子不会产生换行</li><li>有些样式不支持，例如：width、height 等</li><li>不写宽度的时候，宽度由内容决定</li><li>所占的区域不一定是矩形</li><li>内联标签之间会有间隙</li></ul><h3 id="自适应盒模型的特性"><a href="#自适应盒模型的特性" class="headerlink" title="自适应盒模型的特性"></a>自适应盒模型的特性</h3><ul><li>当盒子不设置宽度时，盒模型相关组成部分的处理方式是如何的</li></ul><h3 id="标准盒模型与怪异盒模型"><a href="#标准盒模型与怪异盒模型" class="headerlink" title="标准盒模型与怪异盒模型"></a>标准盒模型与怪异盒模型</h3><ul><li>在标准模型中，如果你给盒设置 width 和 height，实际设置的是 content box。padding 和 border 再加上设置的宽高一起决定整个盒子的大小</li><li>在怪异模型中，所有宽度都是可见宽度，所以内容是该宽度减去边框和填充部分（box-sizing: border-box;）</li></ul><p><strong>box-sizing 属性</strong></p><ul><li>content-box: width、height -&gt; content</li><li>border-box: width、height -&gt; content + padding + border</li></ul><p><strong>应用</strong></p><ol><li>量取尺寸时不用再去计算一些值</li><li>解决一些需要设置百分比和盒模型值</li></ol><h2 id="浮动"><a href="#浮动" class="headerlink" title="浮动"></a>浮动</h2><h3 id="浮动样式详解"><a href="#浮动样式详解" class="headerlink" title="浮动样式详解"></a>浮动样式详解</h3><ul><li>当元素浮动时，会脱离文档流，根据 float 的值向左或向右移动，直到它的外边界碰到父元素的内边界或另一个浮动元素的外边界位置，是 CSS 布局中实现左右布局的一种方式</li><li>文档流：文档流是元素在 Web 页面上的一种呈现方式，按照出现的先后顺序进行排列</li></ul><p><strong>清除浮动的方案</strong></p><ul><li>clear 属性</li><li>BFC</li><li>空标签</li><li>.clearfix::after{}</li></ul><p><strong>浮动特性注意点</strong></p><ul><li>只会影响后面的元素</li><li>文本不会被浮动元素覆盖</li><li>具备内联盒子特性：宽度由内容决定</li><li>具备块级盒子特性：支持所有样式</li><li>浮动放不下，会自动换行</li></ul><h2 id="定位"><a href="#定位" class="headerlink" title="定位"></a>定位</h2><ul><li>static</li><li>relative<ul><li>相对定位的元素是在文档中的正常位置偏移给定的值</li><li>不影响其它元素布局</li><li>相对于自身进行偏移</li></ul></li><li>absolute<ul><li>绝对定位的元素脱离了文档流，绝对定位元素不占据空间</li><li>具备内联盒子特性：宽度由内容决定</li><li>具备块级盒子特性：支持所有样式</li><li>绝对定位元素相对于最近的非 static 祖先元素定位。当这样的祖先元素不存在时，则相对于可视区定位</li></ul></li><li>sticky<ul><li>粘性定位可以被认为是相对定位和固定定位的混合。元素在跨越特性阈值前为相对定位，之后为固定定位</li></ul></li><li>fixed<ul><li>固定定位与绝对定位相似，但是会固定在可视区中</li><li>具备内联盒子特性：宽度由内容决定</li><li>具备块级盒子特性：支持所有样式</li><li>固定定位元素不受祖先元素影响</li></ul></li></ul><h2 id="display"><a href="#display" class="headerlink" title="display"></a>display</h2><p>在 CSS 中 display 属性表示「显示框类型」，即不同的盒模型。简单来说，可以把块级盒子转换成内联盒子，也可以把内联盒子转成块级盒子。</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="attribute">display</span>: inline;</span><br><span class="line"></span><br><span class="line"><span class="attribute">display</span>: block;</span><br></pre></td></tr></table></figure><p>display 属性大概可分为以下几类进行学习：</p><ul><li>display-outside(外部值)</li><li>display-inside(内部值)</li><li>display-listitem(列表值)</li><li>display-internal(属性值)</li><li>display-box(显示值)</li><li>display-legacy(混合值)</li><li>global(全局值)</li></ul><h3 id="display-outside-外部值"><a href="#display-outside-外部值" class="headerlink" title="display-outside(外部值)"></a>display-outside(外部值)</h3><p>外部值就是定义自身元素的外部表现，而不影响其内的子元素。</p><ul><li><code>block</code>: 表示块级盒子像 <code>p</code> <code>div</code> 等标签默认就是块级盒子</li><li><code>inline</code>: 表示内联盒子像 <code>span</code> <code>i</code> 等默认就是内联盒子</li><li><code>run-in</code>: 实验性质的属性，浏览器支持不好</li></ul><h3 id="display-inside-内部值"><a href="#display-inside-内部值" class="headerlink" title="display-inside(内部值)"></a>display-inside(内部值)</h3><p>和外部值相反，内部值就是定义子元素布局的。像 flex、grid 这些设置都会影响到子元素的布局形式。</p><ul><li><code>flow</code></li><li><code>flow-root</code>: 一个 BFC 的块级盒子 </li><li><code>table</code>: 带有内部表格布局的块级盒子</li><li><code>flex</code>: 带有内部弹性布局的块级盒子</li><li><code>grid</code>: 带有内部网格布局的块级盒子</li><li><code>ruby</code></li></ul><h3 id="display-listitem-列表值"><a href="#display-listitem-列表值" class="headerlink" title="display-listitem(列表值)"></a>display-listitem(列表值)</h3><p><code>list-item</code> 属性值是生成一个容纳内容和单独的列表行内元素盒的块级盒子，目的是为了用 <code>div</code> 去代替</p><ul><li>标签之类的</li><li>元素默认就是 <code>list-item</code></li></ul><h3 id="display-internal-属性值"><a href="#display-internal-属性值" class="headerlink" title="display-internal(属性值)"></a>display-internal(属性值)</h3><p>一些和 table 布局、ruby 搭配一起控制页面布局的属性值。</p><ul><li>table-row-group</li><li>table-header-group</li><li>table-footer-group</li><li>table-row</li><li>table-cell</li><li>table-column-group</li><li>table-column</li><li>table-caption</li><li>ruby-base</li><li>ruby-text</li><li>ruby-base-container</li><li>ruby-text-container</li></ul><h3 id="display-box-显示值"><a href="#display-box-显示值" class="headerlink" title="display-box(显示值)"></a>display-box(显示值)</h3><ul><li><code>content</code>: 只影响其内容的样式生效，比如：字体大小、文字颜色等；但是像背景色、边框是不会生效的</li><li><code>none</code>: 从盒子树中移除，博阿凯其所有后代元素</li></ul><h3 id="display-legacy-混合值"><a href="#display-legacy-混合值" class="headerlink" title="display-legacy(混合值)"></a>display-legacy(混合值)</h3><ul><li><code>inline-block</code>: 对外表现成内联盒子，对内表现成块级盒子</li><li><code>inline-list-item</code></li><li><code>inline-table</code>: 对外表现成内联盒子，对内表现成表格盒子</li><li><code>inline-flex</code>: 对外表现成内联盒子，对内表现成弹性盒子</li><li><code>inline-grid</code>: 对外表现成内联盒子，对内表现成网格盒子</li></ul><h3 id="global-全局值"><a href="#global-全局值" class="headerlink" title="global(全局值)"></a>global(全局值)</h3><ul><li><code>inherit</code>: 继承父元素的 display 值</li><li><code>initial</code>: 不管父元素怎么设定，恢复到浏览器最初始时的 display 属性</li><li><code>unset</code>: 混合了 inherit 和 initial。如果父元素设置了，就用父元素的设定，如果父元素没设置，就用浏览器的缺省设定。</li></ul><h2 id="书写模式与逻辑属性"><a href="#书写模式与逻辑属性" class="headerlink" title="书写模式与逻辑属性"></a>书写模式与逻辑属性</h2><h3 id="书写模式"><a href="#书写模式" class="headerlink" title="书写模式"></a>书写模式</h3><p>绝大多数国家的阅读方式都是从左到右进行的，但是也有一小部分国家的阅读方式，可能是从右往左或从上到下。比如阿拉伯国家就是从右向左进行阅读的，所以在网页排版的时候，就要考虑到这个情况。</p><p>书写模式即 <code>writing-mode</code> 属性，可以帮助以上下阅读的国家去展示网页内容，它定义了文本水平或垂直排布以及在块级元素中文本的行进方向。</p><ul><li>horizontal-tb: 水平方向自上而下的书写方式</li><li>vertical-rl: 垂直方向自右而左的书写方式</li><li>vertical-lr: 垂直方向自左而右的书写方式</li><li>sideways-ri: 内容垂直方向从上到下的排列（兼容性不太好）</li><li>sideways-lr: 内容垂直方向从下到上排列（兼容性不太好）</li></ul><h3 id="逻辑属性"><a href="#逻辑属性" class="headerlink" title="逻辑属性"></a>逻辑属性</h3><p>如果一套代码想实现国际化，处理不同国家的排版方式时，就会导致无法实现。</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css"><span class="selector-tag">body</span> &#123;</span></span><br><span class="line"><span class="language-css"><span class="attribute">border</span>: <span class="number">1px</span> black solid;</span></span><br><span class="line"><span class="language-css"><span class="attribute">height</span>: <span class="number">100px</span>;</span></span><br><span class="line"><span class="language-css">&#125;</span></span><br><span class="line"><span class="language-css"><span class="selector-tag">div</span> &#123;</span></span><br><span class="line"><span class="language-css"><span class="attribute">border</span>: <span class="number">1px</span> red solid;</span></span><br><span class="line"><span class="language-css"><span class="attribute">float</span>: left;</span></span><br><span class="line"><span class="language-css"><span class="attribute">margin-left</span>: <span class="number">30px</span>;</span></span><br><span class="line"><span class="language-css">&#125;</span></span><br><span class="line"><span class="language-css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span>Walker Denial<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span>Walker Denial<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>接下来给 body 添加垂直方向自左而右的书写方式，可以返现布局出现了混乱，<code>height</code> 属性依然只针对高度，而 <code>margin-left</code> 属性也依然只针对左间距。</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">body</span> &#123;</span><br><span class="line"><span class="attribute">border</span>: <span class="number">1px</span> black solid;</span><br><span class="line"><span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line"><span class="attribute">writing-mode</span>: vertical-lr; <span class="comment">/* 新增样式 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如何更好的处理不同的书写模式呢？就要配合逻辑属性了。逻辑属性是从逻辑角度控制部件，而不是从物理、方向或纬度来控制。</p><p>简单来说，<strong>物理属性和值</strong> 指的是 <code>width</code>、<code>height</code>、<code>left</code>、<code>top</code>、<code>right</code>、<code>bottom</code> 等值；而 <strong>逻辑属性和值</strong> 指的是 <code>start</code>、<code>end</code>、<code>inline-start</code>、<code>inline-end</code>、<code>block-start</code>、<code>block-end</code> 等值。其中 <code>block</code> 表示垂直方式，<code>inline</code> 表示水平方式，在不容的书写模式下，<code>block</code> 和 <code>inline</code> 所代表的方向是会发生变化的。理解 <strong>逻辑属性</strong> 对于理解 <code>弹性布局</code> 和 <code>网格布局</code> 也有非常大的帮助。</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">body</span> &#123;</span><br><span class="line"><span class="attribute">border</span>: <span class="number">1px</span> black solid;</span><br><span class="line"><span class="attribute">block-size</span>: <span class="number">100px</span>; <span class="comment">/* 修改样式 height: 100px; */</span></span><br><span class="line"><span class="attribute">writing-mode</span>: vertical-lr; <span class="comment">/* 新增样式 */</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">div</span> &#123;</span><br><span class="line"><span class="attribute">border</span>: <span class="number">1px</span> red solid;</span><br><span class="line"><span class="attribute">float</span>: left;</span><br><span class="line"><span class="attribute">margin-inline-start</span>: <span class="number">30px</span>; <span class="comment">/* 修改样式 margin-left: 30px; */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="dir"><a href="#dir" class="headerlink" title="dir"></a>dir</h3><p><code>dir</code> 属性可以设置元素的显示方向，是从左往右（ltr），还是从右往左（rtl），当设置 <code>auto</code> 时会自动根据当前语言决定排列方向，<code>dir</code> 属性非常适合那些从右往左进行阅读的国家，例如：阿拉伯语、波斯语、希伯来语等。</p><h2 id="BFC-块级格式化上下文"><a href="#BFC-块级格式化上下文" class="headerlink" title="BFC 块级格式化上下文"></a>BFC 块级格式化上下文</h2><p> <code>BFC</code> 即 <code>Block Formatting Contexts</code>（块级格式上下文），它是 <strong>W3C CSS2.1</strong> 规范中的一个概念。它是页面中的一块渲染区域，并且有一套渲染规则，它决定了其子元素将如何定位，以及和其他元素的关系和相互作用。</p><p>具有 <code>BFC</code> 特性的元素可以看作是隔离了的独立容器，容器里面的元素不会再布局上影响到外面的元素，并且 <code>BFC</code> 具有普通容器所没有的一些特性。</p><p>通俗一点来讲，可以把 <code>BFC</code> 理解为一个封闭的大箱子，箱子内部的元素无论如何翻江倒海，都不会影响到外部。</p><h3 id="BFC-触发条件"><a href="#BFC-触发条件" class="headerlink" title="BFC 触发条件"></a>BFC 触发条件</h3><p>满足以下条件之一，即可触发 <code>BFC</code>：</p><ul><li>float 的值不是 none</li><li>position 的值不是 static 或者 relative</li><li>display 的值是 inline-block、table-cell、flex、table-caption 或者 inline-flex</li><li>overflow 的值不是 visiable</li></ul><p> 示例：</p> <figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.box</span> &#123;</span><br><span class="line"><span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line"><span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line"><span class="attribute">overflow</span>: hidden; <span class="comment">/* 触发了 BFC，形成独立盒子 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="BFC-的应用"><a href="#BFC-的应用" class="headerlink" title="BFC 的应用"></a>BFC 的应用</h3><p>在前面学习盒模型的 margin 时，出现了传递和叠加的问题，这里可以采用 <code>BFC</code> 规范来解决，原理就是让盒子形成一个独立的容器，无论里面的子元素如何折腾，都不影响到外面的元素。</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line">&lt;style&gt;</span><br><span class="line"><span class="selector-class">.box1</span> &#123;</span><br><span class="line"><span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line"><span class="attribute">height</span>: <span class="number">200px</span>;</span><br><span class="line"><span class="attribute">background</span>: pink;</span><br><span class="line"><span class="attribute">overflow</span>: hidden; <span class="comment">/* 触发了 BFC，形成独立盒子 */</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.box2</span> &#123;</span><br><span class="line"><span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line"><span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line"><span class="attribute">background</span>: skyblud;</span><br><span class="line"><span class="attribute">margin-top</span>: <span class="number">30px</span>;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/style&gt;</span><br><span class="line">&lt;<span class="selector-tag">div</span> class=&quot;box1&quot;&gt;</span><br><span class="line">&lt;<span class="selector-tag">div</span> class=&quot;box2&quot;&gt;&lt;/<span class="selector-tag">div</span>&gt;</span><br><span class="line">&lt;/<span class="selector-tag">div</span>&gt;</span><br></pre></td></tr></table></figure><p>除了解决传递和叠加问题，还可以解决高度塌陷问题。</p><p>在现代布局 <code>flex</code> 和 <code>grid</code> 中，是默认自带 <code>BFC</code> 规范的，所以可以解决非 <code>BFC</code> 盒子的一些问题，这就是为什么 <code>flex</code> 和 <code>grid</code> 能成为更好的布局方式原因之一。</p><h2 id="标签默认样式及清除"><a href="#标签默认样式及清除" class="headerlink" title="标签默认样式及清除"></a>标签默认样式及清除</h2><h3 id="标签默认样式"><a href="#标签默认样式" class="headerlink" title="标签默认样式"></a>标签默认样式</h3><p>一些 HTML 标签在浏览器中会有默认样式，例如：body 标签会有 margin: 8px；ul 标签会有 margin: 16px 0；及 padding-left: 40px；</p><p>当在切图软件中进行尺寸或位置测量的时候，把测量出来的数值设置到对应的标签上时，可能会受到当前标签默认样式的影响，从而页面显示效果分设计图效果不符。</p><h3 id="清除默认样式"><a href="#清除默认样式" class="headerlink" title="清除默认样式"></a>清除默认样式</h3><p>通常在网页开发中，要去掉这些影响尺寸和位置的默认样式及其他影响布局的默认值。可以参考 <a href="https://meyerweb.com/eric/tools/css/reset/">CSS Tools: Reset CSS</a> 方案。</p><p>由于 Reset CSS 相对「暴力」，不管你有没有用，统统重置成一样的效果，且影响范围很大，所以更加「平和」的一种方式 <a href="https://github.com/necolas/normalize.css/blob/master/normalize.css">Normalize CSS</a> 诞生了。</p><p><code>Normalize CSS</code> 可以看成是一种 <code>Reset CSS</code> 的替代方案。创造 <code>Normalize CSS</code> 有下面这几个目的：</p><ul><li>保护有用的浏览器默认样式而不是完全去掉它们</li><li>一般化的样式：为大部分 HTML 元素提供</li><li>修复浏览器自身的 bug 并保证各浏览器的一致性</li><li>优化 CSS 可用性：用一些小技巧</li><li>解释代码：用注释和详情的文档</li></ul><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="keyword">@charset</span> <span class="string">&quot;utf-8&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* --------------------重置样式-------------------------------- */</span></span><br><span class="line"></span><br><span class="line"><span class="selector-tag">body</span>,</span><br><span class="line"><span class="selector-tag">h1</span>,</span><br><span class="line"><span class="selector-tag">h2</span>,</span><br><span class="line"><span class="selector-tag">h3</span>,</span><br><span class="line"><span class="selector-tag">h4</span>,</span><br><span class="line"><span class="selector-tag">h5</span>,</span><br><span class="line"><span class="selector-tag">h6</span>,</span><br><span class="line">hr,</span><br><span class="line"><span class="selector-tag">p</span>,</span><br><span class="line"><span class="selector-tag">blockquote</span>,</span><br><span class="line"><span class="selector-tag">dl</span>,</span><br><span class="line"><span class="selector-tag">dt</span>,</span><br><span class="line"><span class="selector-tag">dd</span>,</span><br><span class="line"><span class="selector-tag">ul</span>,</span><br><span class="line"><span class="selector-tag">ol</span>,</span><br><span class="line"><span class="selector-tag">li</span>,</span><br><span class="line"><span class="selector-tag">button</span>,</span><br><span class="line"><span class="selector-tag">input</span>,</span><br><span class="line"><span class="selector-tag">textarea</span>,</span><br><span class="line"><span class="selector-tag">th</span>,</span><br><span class="line"><span class="selector-tag">td</span> &#123;</span><br><span class="line">    <span class="attribute">margin</span> : <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">padding</span>: <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*设置默认字体*/</span></span><br><span class="line"><span class="selector-tag">body</span> &#123;</span><br><span class="line">    <span class="attribute">font-size</span>  : <span class="number">14px</span>;</span><br><span class="line">    <span class="attribute">font-style</span> : normal;</span><br><span class="line">    <span class="attribute">font-family</span>: -apple-system, BlinkMacSystemFont, segoe ui, Roboto, helvetica neue, Arial, noto sans, sans-serif, apple color emoji, segoe ui emoji, segoe ui symbol, noto color emoji;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*字体太小用户体检不好，让small恢复12px*/</span></span><br><span class="line">small &#123;</span><br><span class="line">    <span class="attribute">font-size</span>: <span class="number">12px</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">h1</span> &#123;</span><br><span class="line">    <span class="attribute">font-size</span>: <span class="number">18px</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">h2</span> &#123;</span><br><span class="line">    <span class="attribute">font-size</span>: <span class="number">16px</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">h3</span> &#123;</span><br><span class="line">    <span class="attribute">font-size</span>: <span class="number">14px</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">h4</span>,</span><br><span class="line"><span class="selector-tag">h5</span>,</span><br><span class="line"><span class="selector-tag">h6</span> &#123;</span><br><span class="line">    <span class="attribute">font-size</span>: <span class="number">100%</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">ul</span>,</span><br><span class="line"><span class="selector-tag">ol</span> &#123;</span><br><span class="line">    <span class="attribute">list-style</span>: none</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">a</span> &#123;</span><br><span class="line">    <span class="attribute">text-decoration</span> : none;</span><br><span class="line">    <span class="attribute">background-color</span>: transparent</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">a</span><span class="selector-pseudo">:hover</span>,</span><br><span class="line"><span class="selector-tag">a</span><span class="selector-pseudo">:active</span> &#123;</span><br><span class="line">    <span class="attribute">outline-width</span>  : <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">text-decoration</span>: none</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*重置表格*/</span></span><br><span class="line"><span class="selector-tag">table</span> &#123;</span><br><span class="line">    <span class="attribute">border-collapse</span>: collapse;</span><br><span class="line">    <span class="attribute">border-spacing</span> : <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*重置hr*/</span></span><br><span class="line">hr &#123;</span><br><span class="line">    <span class="attribute">border</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">1px</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*图形图片*/</span></span><br><span class="line"><span class="selector-tag">img</span> &#123;</span><br><span class="line">    <span class="attribute">border-style</span>: none</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">img</span><span class="selector-pseudo">:not</span>(<span class="selector-attr">[src]</span>) &#123;</span><br><span class="line">    <span class="attribute">display</span>: none</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">svg<span class="selector-pseudo">:not</span>(<span class="selector-pseudo">:root</span>) &#123;</span><br><span class="line">    <span class="attribute">overflow</span>: hidden</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*下面的操作是针对于html5页面布局准备的，不支持ie6~8以及其他低版本的浏览器*/</span></span><br><span class="line"><span class="selector-tag">html</span> &#123;</span><br><span class="line">    <span class="comment">/*禁用系统默认菜单*/</span></span><br><span class="line">    -webkit-touch-callout   : none;</span><br><span class="line">    <span class="comment">/*关闭iphone &amp; Android的浏览器纵向和横向模式中自动调整字体大小的功能*/</span></span><br><span class="line">    -webkit-text-size-adjust: <span class="number">100%</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">input</span>,</span><br><span class="line"><span class="selector-tag">textarea</span>,</span><br><span class="line"><span class="selector-tag">button</span>,</span><br><span class="line"><span class="selector-tag">a</span> &#123;</span><br><span class="line">    <span class="comment">/*表单或者a标签在手机点击时会出现边框或彩色的背景区域，意思是去除点击背景框*/</span></span><br><span class="line">    -webkit-tap-highlight-<span class="attribute">color</span>: <span class="built_in">rgba</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*重置html5元素的默认样式*/</span></span><br><span class="line"><span class="selector-tag">article</span>,</span><br><span class="line"><span class="selector-tag">aside</span>,</span><br><span class="line"><span class="selector-tag">details</span>,</span><br><span class="line"><span class="selector-tag">figcaption</span>,</span><br><span class="line"><span class="selector-tag">figure</span>,</span><br><span class="line"><span class="selector-tag">footer</span>,</span><br><span class="line"><span class="selector-tag">header</span>,</span><br><span class="line"><span class="selector-tag">main</span>,</span><br><span class="line"><span class="selector-tag">menu</span>,</span><br><span class="line"><span class="selector-tag">nav</span>,</span><br><span class="line"><span class="selector-tag">section</span>,</span><br><span class="line"><span class="selector-tag">summary</span> &#123;</span><br><span class="line">    <span class="attribute">display</span>: block</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">audio</span>,</span><br><span class="line"><span class="selector-tag">canvas</span>,</span><br><span class="line">progress,</span><br><span class="line"><span class="selector-tag">video</span> &#123;</span><br><span class="line">    <span class="attribute">display</span>: inline-block</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">audio</span><span class="selector-pseudo">:not</span>(<span class="selector-attr">[controls]</span>),</span><br><span class="line"><span class="selector-tag">video</span><span class="selector-pseudo">:not</span>(<span class="selector-attr">[controls]</span>) &#123;</span><br><span class="line">    <span class="attribute">display</span>: none;</span><br><span class="line">    <span class="attribute">height</span> : <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">progress &#123;</span><br><span class="line">    <span class="attribute">vertical-align</span>: baseline</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">mark</span> &#123;</span><br><span class="line">    <span class="attribute">background-color</span>: <span class="number">#ff0</span>;</span><br><span class="line">    <span class="attribute">color</span>           : <span class="number">#000</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">sub,</span><br><span class="line"><span class="selector-tag">sup</span> &#123;</span><br><span class="line">    <span class="attribute">position</span>      : relative;</span><br><span class="line">    <span class="attribute">font-size</span>     : <span class="number">75%</span>;</span><br><span class="line">    <span class="attribute">line-height</span>   : <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">vertical-align</span>: baseline</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">sub &#123;</span><br><span class="line">    <span class="attribute">bottom</span>: -<span class="number">0.25em</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">sup</span> &#123;</span><br><span class="line">    <span class="attribute">top</span>: -<span class="number">0.5em</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">button</span>,</span><br><span class="line"><span class="selector-tag">input</span>,</span><br><span class="line">select,</span><br><span class="line"><span class="selector-tag">textarea</span> &#123;</span><br><span class="line">    <span class="attribute">font-size</span>: <span class="number">100%</span>;</span><br><span class="line">    <span class="attribute">outline</span>  : <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">button</span>,</span><br><span class="line"><span class="selector-tag">input</span> &#123;</span><br><span class="line">    <span class="attribute">overflow</span>: visible</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">button</span>,</span><br><span class="line">select &#123;</span><br><span class="line">    <span class="attribute">text-transform</span>: none</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">textarea</span> &#123;</span><br><span class="line">    <span class="attribute">overflow</span>: auto</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">button</span>,</span><br><span class="line"><span class="selector-tag">html</span> <span class="selector-attr">[type=<span class="string">&quot;button&quot;</span>]</span>,</span><br><span class="line"><span class="selector-attr">[type=<span class="string">&quot;reset&quot;</span>]</span>,</span><br><span class="line"><span class="selector-attr">[type=<span class="string">&quot;submit&quot;</span>]</span> &#123;</span><br><span class="line">    -webkit-appearance: button</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">button</span>::-moz-focus-inner,</span><br><span class="line">[type=<span class="string">&quot;button&quot;</span>]::-moz-focus-inner,</span><br><span class="line">[type=<span class="string">&quot;reset&quot;</span>]::-moz-focus-inner,</span><br><span class="line">[type=<span class="string">&quot;submit&quot;</span>]::-moz-focus-inner &#123;</span><br><span class="line">    <span class="attribute">border-style</span>: none;</span><br><span class="line">    <span class="attribute">padding</span>     : <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">button</span>:-moz-focusring,</span><br><span class="line">[type=<span class="string">&quot;button&quot;</span>]:-moz-focusring,</span><br><span class="line">[type=<span class="string">&quot;reset&quot;</span>]:-moz-focusring,</span><br><span class="line">[type=<span class="string">&quot;submit&quot;</span>]:-moz-focusring &#123;</span><br><span class="line">    <span class="attribute">outline</span>: <span class="number">1px</span> dotted ButtonText</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-attr">[type=<span class="string">&quot;checkbox&quot;</span>]</span>,</span><br><span class="line"><span class="selector-attr">[type=<span class="string">&quot;radio&quot;</span>]</span> &#123;</span><br><span class="line">    <span class="attribute">box-sizing</span>: border-box;</span><br><span class="line">    <span class="attribute">padding</span>   : <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-attr">[type=<span class="string">&quot;number&quot;</span>]</span>::-webkit-inner-spin-button,</span><br><span class="line">[type=<span class="string">&quot;number&quot;</span>]::-webkit-outer-spin-button &#123;</span><br><span class="line">    <span class="attribute">height</span>: auto</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-attr">[type=<span class="string">&quot;search&quot;</span>]</span> &#123;</span><br><span class="line">    -webkit-appearance: textfield;</span><br><span class="line">    <span class="attribute">outline-offset</span>    : -<span class="number">2px</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-attr">[type=<span class="string">&quot;search&quot;</span>]</span>::-webkit-search-cancel-button,</span><br><span class="line">[type=<span class="string">&quot;search&quot;</span>]::-webkit-search-decoration &#123;</span><br><span class="line">    -webkit-appearance: none</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">::-webkit-input-placeholder &#123;</span><br><span class="line">    <span class="attribute">color</span>  : inherit;</span><br><span class="line">    <span class="attribute">opacity</span>: .<span class="number">54</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">::-webkit-file-upload-button &#123;</span><br><span class="line">    -webkit-appearance: button;</span><br><span class="line">    <span class="attribute">font</span>              : inherit</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="flex"><a href="#flex" class="headerlink" title="flex"></a>flex</h2><p>弹性盒子是一种用于按行或按列布局元素的一维布局方法。元素可以膨胀以填充额外的空间，收缩以适应更小的空间。</p><p>flex 容器：</p><ul><li>flex-direction：改变轴方向<ul><li>row(默认)</li><li>row-reverse</li><li>column</li><li>column-reverse</li></ul></li><li>flex-wrap<ul><li>nowrap</li><li>wrap</li><li>wrap-reverse</li></ul></li><li>flex-flow: [flex-direction] [flex-wrap]</li><li>justify-content<ul><li>flex-start(默认)</li><li>flex-end</li><li>center</li><li>space-around</li><li>space-between</li><li>space-evenly</li></ul></li><li>align-items<ul><li>stretch(默认)</li><li>flex-start</li><li>flex-end</li><li>center</li><li>baseline</li></ul></li><li>align-content：当不折行的情况下，此属性不生效<ul><li>strech(默认)</li><li>flex-start</li><li>flex-end</li><li>center</li><li>space-around</li><li>space-between</li><li>space-evenly</li></ul></li></ul><p>flex 子项：</p><ul><li>order: 默认值是 0，改变某一个 flex 子项的排序位置</li><li>flex-grow: 扩展比例。默认值是 0，不能为负数，表示不占用剩余的空白间隙扩展自己的宽度( 0~1，1 表示占满剩余所有空间)</li><li>flex-shrink: 收缩比例。默认值是 1，表示 flex 容器空间不足时，元素的收缩比例。（0~1：自动收缩，跟容器大小相同，0：不收缩）</li><li>flex-basis：默认值是 auto，指定了 flex 元素在主轴方向上的初始大小（0%~100%、auto、xxxpx）</li><li>flex：是 flex-grow, flex-shrink, flex-basis 的缩写</li><li>align-self: 默认值是 auto，控制单独某一个 flex 子项的垂直对齐方式</li></ul><h2 id="grid"><a href="#grid" class="headerlink" title="grid"></a>grid</h2><p>CSS 网格是一个用于 web 的二维布局系统。利用网络，可以把内容按照行与列的格式进行排版。另外，网格还能非常轻松地实现一些复杂的布局。</p><p><strong>grid 容器</strong></p><ul><li>justify-items: 默认值 stretch，指定了子项在网格中的对齐方式</li><li>align-items: 默认值 stretch，指定了子项在网格中的对齐方式</li><li>place-items: 默认值 stretch，指定了子项在网格中的对齐方式</li><li>justify-content: 默认值 stretch，指定了所有网格在 grid 容器中的对齐方式</li><li>align-content: 默认值 stretch，指定了所有网格在 grid 容器中的对齐方式</li><li>place-content: 默认值 stretch，指定了所有网格在 grid 容器中的对齐方式</li><li>grid-auto-flow: 指定在显示网格之外的隐式网格，如何排列，默认 row 就是行产生隐式网格，dense（紧密的）</li><li>grid-auto-rows: 可以调节产生隐式网格的高度</li><li>grid-auto-columns: 可以调节产生隐式网格的宽度</li><li>grid-template-rows: 基于网格行的纬度，定义网格线的名称和网格轨道的尺寸大小</li><li>grid-template-columns: 基于网格列的纬度，定义网格线的名称和网格轨道的尺寸大小</li><li>grid-template-areas: 使用命名方式定义网格区域，需配合 grid-area 属性进行使用</li><li>grid-template: 「grid-template-rows」「grid-template-columns」「grid-template-areas」的缩写</li><li>grid-row-gap: 用来设置元素行之间的间隙大小，推荐使用 row-gap</li><li>grid-column-gap: 用来设置元素列之间的间隙大小，推荐使用 column-gap</li><li>grid-gap: 用来设置元素行列之间的间隙大小，推荐使用 gap</li></ul><p><strong>grid 子项</strong></p><ul><li>justify-self: 指定了子项在网格中行的对齐方式</li><li>align-self: 指定了子项在网格中列的对齐方式</li><li>place-self: 指定了子项在网格中的对齐方式</li><li>grid-row: 基于线对应位置的缩写方式，通过 &#x2F; 作为分割</li><li>grid-column: 基于线对应位置的缩写方式，通过 &#x2F; 作为分割</li><li>grid-area: 「grid-row-start」「grid-column-start」「grid-row-end」「grid-column-end」属性的缩写，以及额外支持 「grid-template-areas」设置的网格名称</li><li>grid-column-start: grid 子项所占区域的垂直方向开始</li><li>grid-column-end: grid 子项所占区域的垂直方向结束</li><li>grid-row-start: grid 子项所占区域的水平方向开始</li><li>grid-row-end: grid 子项所占区域的水平方向结束</li></ul><h2 id="移动端适配"><a href="#移动端适配" class="headerlink" title="移动端适配"></a>移动端适配</h2><p><strong>逻辑像素</strong>：CSS 中的像素，绝对单位，保证不同设备下元素的尺寸时相同的。</p><p><strong>物理像素</strong>：设备屏幕实际拥有的像素点，相对单位，不同设备下物理像素大小不同。</p><p>动态计算 font-size：</p><ul><li>JS 动态计算，flexible.js 库</li><li>利用 vw 相对单位，动态换算 font-size</li></ul><h2 id="媒体查询"><a href="#媒体查询" class="headerlink" title="媒体查询"></a>媒体查询</h2><ul><li>媒体类型：描述设备的一般类别<ul><li>all：适用于所有设备</li><li>print：适用于在打印预览模式</li><li>screen：主要用于屏幕</li><li>speech：主要用于语言合成器</li></ul></li><li>媒体特性：描述了 user agent、输出设备，或是浏览环境的具体特征<ul><li>width：viewport 的宽度</li><li>height：viewport 的高度</li><li>aspect-ratio：viewport 的宽高比</li><li>orientation：viewport 的旋转方向</li></ul></li><li>逻辑操作符：not、and、only 可用于联合构造复杂的媒体查询<ul><li>and：用于将多个媒体查询规则组合成单条媒体查询</li><li>not：用于否定媒体查询，如果不满足这个条件则返回 true，否则返回 false</li><li>only：用于旧版浏览器识别媒体类型使用</li><li>逗号：用于将多个媒体查询合并为一个规则</li></ul></li><li>link 标签方式：通过 media 属性设置媒体查询类型和媒体特性</li></ul><h3 id="媒体查询的编写位置及顺序"><a href="#媒体查询的编写位置及顺序" class="headerlink" title="媒体查询的编写位置及顺序"></a>媒体查询的编写位置及顺序</h3><ul><li>添加到样式表的底部，对 CSS 进行优先级的覆盖</li><li>移动端 -&gt; PC 端的适配原则：min-width 从小到大</li><li>PC 端 -&gt; 移动端的适配原则：max-width 从大到小</li></ul><h3 id="响应断点（阈值）的设定"><a href="#响应断点（阈值）的设定" class="headerlink" title="响应断点（阈值）的设定"></a>响应断点（阈值）的设定</h3><p><img src="https://personal-blog.oss-cn-hangzhou.aliyuncs.com/css-screen-threshold.png"></p><table><thead><tr><th align="left">设备描述</th><th align="left">端点值</th><th align="left">标识符</th></tr></thead><tbody><tr><td align="left">Extra small</td><td align="left">&lt; 576px</td><td align="left"></td></tr><tr><td align="left">Small</td><td align="left">≥ 576px</td><td align="left">-sm</td></tr><tr><td align="left">Medium</td><td align="left">≥ 768px</td><td align="left">-md</td></tr><tr><td align="left">Large</td><td align="left">≥ 992px</td><td align="left">-lg</td></tr><tr><td align="left">X-Large</td><td align="left">≥ 1200px</td><td align="left">-xl</td></tr><tr><td align="left">XX-Large</td><td align="left">≥ 1400px</td><td align="left">-xxl</td></tr></tbody></table><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><h3 id="多栏布局-Multi-Columns"><a href="#多栏布局-Multi-Columns" class="headerlink" title="多栏布局 Multi-Columns"></a>多栏布局 Multi-Columns</h3><ul><li>column-count：多栏的个数</li><li>column-width：多栏的宽度</li><li>column-gap：多栏的间距</li><li>column-rule：多栏的边线</li><li>column-span：多栏的合并</li></ul><p>在 <strong>column-count</strong> 和 <strong>column-width</strong> 同时设置的情况下，以 <strong>栏数最少的为准</strong>。</p><p>弊端：排列方式为纵向，如果需要加载更多，会导致子项位置变化s。</p><h3 id="视觉差布局"><a href="#视觉差布局" class="headerlink" title="视觉差布局"></a>视觉差布局</h3><p>也叫视差滚动布局，是指多层背景以不同的速度移动，形成立体的运动效果，带来非常出色的视觉体验。</p><p><strong>原理：</strong></p><ul><li>修改：background-attachment、position、left、top、transform、opacity 等样式</li><li>需要配合 JS 插件来监听滚动条位置：<a href="https://github.com/Prinzhorn/skrollr">https://github.com/Prinzhorn/skrollr</a></li></ul><p>CSS 方式实现：</p><ol><li>perspective</li><li>translateZ</li></ol><p>让需要慢速滚动的区域，远离视线，就会感觉滚动慢一些，例如：远处的人走路移动 10 米，肉眼感觉移动距离很短，可能只有 1 米，这就是由于距离产生的一个视觉差。</p><h3 id="CSS-实现轮播图"><a href="#CSS-实现轮播图" class="headerlink" title="CSS 实现轮播图"></a>CSS 实现轮播图</h3><ol><li>父容器使用 <code>scroll-snap-type: none | [ x | y | block | inline | both ] [ mandatory | proximity ]?</code></li><li>子组件使用 <code>scroll-snap-align: [ none | start | end | center ]&#123;1,2&#125;</code></li></ol><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Keyword values */</span></span><br><span class="line"><span class="attribute">scroll-snap-type</span>: none; // 当这个滚动容器的可视的 viewport 是滚动的，它必须忽略临时点。</span><br><span class="line"><span class="attribute">scroll-snap-type</span>: x; // 滚动容器只捕捉其水平轴上的捕捉位置</span><br><span class="line"><span class="attribute">scroll-snap-type</span>: y; // 滚动容器只捕捉其垂直轴上的捕捉位置</span><br><span class="line"><span class="attribute">scroll-snap-type</span>: block; // 滚动容器仅捕捉到其块轴上的捕捉位置</span><br><span class="line"><span class="attribute">scroll-snap-type</span>: inline; // 滚动容器仅捕捉到其内联轴上的捕捉位置</span><br><span class="line"><span class="attribute">scroll-snap-type</span>: both; // 滚动容器会独立捕捉到其两个轴上的位置（可能会捕捉到每个轴上的不同元素）</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Optional mandatory | proximity*/</span></span><br><span class="line"><span class="attribute">scroll-snap-type</span>: x mandatory; // 如果它当前没有被滚动，这个滚动容器的可视视图将静止在临时点上。意思是当滚动动作结束，如果可能，它会临时在那个点上。如果内容被添加、移动、删除或者重置大小，滚动偏移将被调整为保持静止在临时点上</span><br><span class="line"><span class="attribute">scroll-snap-type</span>: y proximity; 如果它当前没有被滚动，这个滚动容器的可视视图将基于基于用户代理滚动的参数去到临时点上。如果内容被添加、移动、删除或者重置大小，滚动偏移将被调整为保持静止在临时点上</span><br><span class="line"><span class="attribute">scroll-snap-type</span>: both mandatory;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* etc */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Global values */</span></span><br><span class="line"><span class="attribute">scroll-snap-type</span>: inherit;</span><br><span class="line"><span class="attribute">scroll-snap-type</span>: initial;</span><br><span class="line"><span class="attribute">scroll-snap-type</span>: unset;</span><br></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Keyword values */</span></span><br><span class="line"><span class="attribute">scroll-snap-align</span>: none;</span><br><span class="line"><span class="attribute">scroll-snap-align</span>: start end; <span class="comment">/* when two values set first is block, second inline */</span></span><br><span class="line"><span class="attribute">scroll-snap-align</span>: center;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Global values */</span></span><br><span class="line"><span class="attribute">scroll-snap-align</span>: inherit;</span><br><span class="line"><span class="attribute">scroll-snap-align</span>: initial;</span><br><span class="line"><span class="attribute">scroll-snap-align</span>: revert;</span><br><span class="line"><span class="attribute">scroll-snap-align</span>: revert-layer;</span><br><span class="line"><span class="attribute">scroll-snap-align</span>: unset;</span><br></pre></td></tr></table></figure><p>此设置方式，如果滑动距离过大，可能会出现跳过某个子项的情况，如果想一个一个按顺序展示，只需设置 <code>scroll-snap-stop: always;</code></p><blockquote><p>scroll-snap-stop: normal | always;</p></blockquote><h3 id="字蛛-font-spider"><a href="#字蛛-font-spider" class="headerlink" title="字蛛 font-spider"></a><a href="https://github.com/aui/font-spider">字蛛 font-spider</a></h3><p>字蛛是一个智能 WebFont 压缩工具，它能自动分析出页面使用的 WebFont 并进行按需压缩。</p><p><strong>特性</strong></p><ol><li>压缩字体：智能删除没有被使用的字形数据，大幅度减少字体体积</li><li>生成字体：支持 woff2、woff、eot、svg 字体格式生成</li><li>字蛛 v1.0.0 版本支持图标字体</li></ol>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CSS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CSS 基础学习</title>
      <link href="/2022/03/07/%E5%89%8D%E7%AB%AF/CSS%20%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0/"/>
      <url>/2022/03/07/%E5%89%8D%E7%AB%AF/CSS%20%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<p>作为前端三大件之一的 CSS，虽然经常使用，但是却从未系统学习过，应对简单需求还好，如果复杂一些，就会出现各种各样的问题，例如：</p><ol><li>HTML 元素的嵌套关系是怎么确定的？哪些嵌套不可以发生？</li><li>CSS 选择器的权重是如何计算的？写代码时要注意什么？</li><li>浮动布局是怎么回事？有什么优缺点？</li></ol><p>如果不清楚这些基础问题，就会导致项目经常碰壁，因此还是很有必要系统学习一遍 CSS 的。</p><h1 id="HTML-基础"><a href="#HTML-基础" class="headerlink" title="HTML 基础"></a>HTML 基础</h1><p>前端开发三大件：</p><ol><li>HTML：结构</li><li>CSS：样式</li><li>JavaScript：行为</li></ol><h2 id="HTML-常见元素和理解"><a href="#HTML-常见元素和理解" class="headerlink" title="HTML 常见元素和理解"></a>HTML 常见元素和理解</h2><h3 id="header-区域常用标签，不会展现在用户可视化界面："><a href="#header-区域常用标签，不会展现在用户可视化界面：" class="headerlink" title="header 区域常用标签，不会展现在用户可视化界面："></a>header 区域常用标签，不会展现在用户可视化界面：</h3><ul><li>meta</li><li>title</li><li>style</li><li>link</li><li>script</li><li>base</li></ul><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;utf-8&quot;</span>&gt;</span> //设置字符集编码</span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width,initial-scale=1.0,maximum-scale=1.0,user-scalable=no&quot;</span>&gt;</span> // 视口</span><br><span class="line"></span><br><span class="line">/ *</span><br><span class="line">   * <span class="tag">&lt;<span class="name">base</span>&gt;</span> 标签为页面上的所有链接规定默认地址或默认目标。</span><br><span class="line">   * 通常情况下，浏览器会从当前文档的 URL 中提取相应的元素来填写相对 URL 中的空白。</span><br><span class="line">   * 使用 <span class="tag">&lt;<span class="name">base</span>&gt;</span> 标签可以改变这一点。浏览器随后将不再使用当前文档的 URL，而使用指定的基本 URL 来解析所有的相对 URL。这其中包括 <span class="tag">&lt;<span class="name">a</span>&gt;</span>、<span class="tag">&lt;<span class="name">img</span>&gt;</span>、<span class="tag">&lt;<span class="name">link</span>&gt;</span>、<span class="tag">&lt;<span class="name">form</span>&gt;</span> 标签中的 URL。</span><br><span class="line">   */</span><br><span class="line"><span class="tag">&lt;<span class="name">base</span> <span class="attr">href</span>=<span class="string">&quot;/&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="body-区域常用标签，用于展示可视化界面："><a href="#body-区域常用标签，用于展示可视化界面：" class="headerlink" title="body 区域常用标签，用于展示可视化界面："></a>body 区域常用标签，用于展示可视化界面：</h3><ul><li>div&#x2F;section&#x2F;article&#x2F;aside&#x2F;header&#x2F;footer</li><li>p</li><li>span&#x2F;em&#x2F;strong</li><li>table&#x2F;thead&#x2F;tbody&#x2F;tr&#x2F;td</li><li>ul&#x2F;ol&#x2F;li&#x2F;dl&#x2F;dt&#x2F;dd</li><li>a</li><li>form&#x2F;input&#x2F;select&#x2F;textarea&#x2F;button</li></ul><h3 id="HTML-重要属性"><a href="#HTML-重要属性" class="headerlink" title="HTML 重要属性"></a>HTML 重要属性</h3><ul><li>a[href, target]</li><li>img[src, alt]</li><li>table td[colspan, rowspan]</li><li>form[target, method, enctype]</li><li>input[type, value]</li><li>button[type]</li><li>select &gt; option[value]</li><li>label[for]</li></ul><h3 id="如何理解-HTML"><a href="#如何理解-HTML" class="headerlink" title="如何理解 HTML"></a>如何理解 HTML</h3><ul><li>HTML 「文档」</li><li>描述文档的「结构」</li><li>有区块和大纲</li></ul><p>常用分析工具：</p><ol><li><a href="https://h5o.github.io/">H5O</a></li><li><a href="https://validator.w3.org/">validator</a></li></ol><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">section</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>Walker Denial<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">section</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>Habbit<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>travel<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">section</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">section</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>Desc<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>Wild coder<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">section</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">aside</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>Enjoy life<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">aside</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">section</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">footer</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>(c) 2022 WalkerDenial Studio<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">footer</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="HTML-版本"><a href="#HTML-版本" class="headerlink" title="HTML 版本"></a>HTML 版本</h2><ul><li>HTML4&#x2F;4.01(SGML)</li><li>XHTML(XML)</li><li>HTML5</li></ul><table><thead><tr><th align="center"></th><th align="center">HTML4</th><th align="center">XHTML</th><th align="center">HTML5</th></tr></thead><tbody><tr><td align="center">标签是否允许不结束</td><td align="center">✅</td><td align="center">❎</td><td align="center">✅</td></tr><tr><td align="center">属性是否可以不带引号</td><td align="center">✅</td><td align="center">❎</td><td align="center">✅</td></tr><tr><td align="center">标签属性是否可大写</td><td align="center">✅</td><td align="center">❎</td><td align="center">✅</td></tr><tr><td align="center">Boolean 属性是否可省略值</td><td align="center">✅</td><td align="center">❎</td><td align="center">✅</td></tr></tbody></table><h3 id="HTML5-新增内容"><a href="#HTML5-新增内容" class="headerlink" title="HTML5 新增内容"></a>HTML5 新增内容</h3><ul><li>新区块标签<ul><li>section</li><li>article</li><li>nav</li><li>aside</li></ul></li><li>表单增强<ul><li>日期、时间、搜索</li><li>表单验证</li><li>Placeholder 自动聚焦</li></ul></li></ul><h3 id="HTML5-新增语义"><a href="#HTML5-新增语义" class="headerlink" title="HTML5 新增语义"></a>HTML5 新增语义</h3><ul><li>header&#x2F;footer 头尾</li><li>section&#x2F;article 区域</li><li>nav 导航</li><li>aside 不重要内容</li><li>em&#x2F;strong 强调</li><li>i icon</li></ul><h2 id="HTML-元素分类"><a href="#HTML-元素分类" class="headerlink" title="HTML 元素分类"></a>HTML 元素分类</h2><ul><li>按默认样式分<ul><li>块级 block</li><li>行内 inline</li><li>inline-block</li></ul></li><li>按内容分 <a href="https://html.spec.whatwg.org/multipage/dom.html#phrasing-content">phrasing content</a></li></ul><h2 id="HTML-元素嵌套关系"><a href="#HTML-元素嵌套关系" class="headerlink" title="HTML 元素嵌套关系"></a>HTML 元素嵌套关系</h2><ul><li>块级元素可以包含行内元素</li><li>块级元素不一定能包含块级元素</li><li>行内元素一般不能包含块级元素</li></ul><h2 id="HTML-元素默认样式和定制化"><a href="#HTML-元素默认样式和定制化" class="headerlink" title="HTML 元素默认样式和定制化"></a>HTML 元素默认样式和定制化</h2><ul><li>默认样式的意义</li><li>默认样式带来的问题</li><li>CSS Reset<ul><li>CSS Tools: Reset CSS</li><li>YUI</li><li>*{padding: 0; margin: 0;}</li><li>Normalize.css</li></ul></li></ul><h2 id="HTML-面试真题解答"><a href="#HTML-面试真题解答" class="headerlink" title="HTML 面试真题解答"></a>HTML 面试真题解答</h2><p>1.doctype 的意义是什么</p><blockquote><p>让浏览器以标准模式渲染</p><p>让浏览器知道元素的合法性</p></blockquote><p>2.HTML、XHTML、HTML5 的关系</p><blockquote><p>HTML 属于 SGML</p><p>XHTML 属于 XML，是 HTML 进行 XML 严格化的结果</p><p>HTML5 不属于 SGML 或 XML，比 XHTML 宽松</p></blockquote><p>3.HTML5 有什么变化</p><blockquote><p>新的语义化元素</p><p>表单增强</p><p>新的 API（离线、音视频、图形、实时通信、本地存储、设备能力）</p><p>分类和嵌套变更</p></blockquote><p> 4.em 和 i 有什么区别</p><blockquote><p>em 是语义化的标签，表示强调</p><p>i 是纯样式的标签，表示斜体</p><p>HTML5 中 i 不推荐使用，一般用作图标</p></blockquote><p>5.语义化的意义是什么</p><blockquote><p>开发者容易理解</p><p>机器容易理解结构（搜索、读屏、软件）</p><p>有助于 SEO</p><p>semantic microdata</p></blockquote><p>6.哪些元素可以自闭合</p><blockquote><p>表单元素 input</p><p>图片 img</p><p>br hr</p><p>meta link</p></blockquote><p>7.HTML 和 DOM 的关系</p><blockquote><p>HTML 是「死」的<br>DOM 由 HTML 解析而来，是「活」的<br>JS 可以维护 DOM</p></blockquote><p>8.property 和 attribute 的区别</p><blockquote><p>attribute 是「死」的</p><p>property 是「活」的</p></blockquote><p>9.form 的作用有哪些</p><blockquote><p>直接提交表单</p><p>使用 submit&#x2F;reset 按钮</p><p>便于浏览器保存表单</p><p>第三方库可以整体提取值</p><p>第三方库可以进行表单验证</p></blockquote><h1 id="CSS-基础"><a href="#CSS-基础" class="headerlink" title="CSS 基础"></a>CSS 基础</h1><p> CSS 全称为 <code>Cascading Style Sheet</code>，也叫层叠样式表。</p><h2 id="基本规则"><a href="#基本规则" class="headerlink" title="基本规则"></a>基本规则</h2><blockquote><p>选择器 {<br/><br>    属性: 值;<br/><br>    属性: 值;<br/><br>}</p></blockquote><h3 id="选择器作用"><a href="#选择器作用" class="headerlink" title="选择器作用"></a>选择器作用</h3><ul><li>用于匹配 HTML 元素</li><li>有不同的匹配规则</li><li>多个选择器可叠加</li></ul><h3 id="选择器分类"><a href="#选择器分类" class="headerlink" title="选择器分类"></a>选择器分类</h3><ul><li>元素选择器 a{}</li><li>伪元素选择器 ::before{}</li><li>类选择器 .link{}</li><li>属性选择器 [type&#x3D;radio]{}</li><li>伪类选择器 :hover{}</li><li>ID 选择器 #id{}</li><li>组合选择器 [type&#x3D;checkbox] + label{}</li><li>否定选择器 :not(.link){}</li><li>通用选择器 *{}</li></ul><h3 id="选择器权重"><a href="#选择器权重" class="headerlink" title="选择器权重"></a>选择器权重</h3><p>选择器权重计算规则：</p><ul><li>ID 选择器 #id{} +100</li><li>类、属性、伪类 +10</li><li>元素、伪元素 +1</li><li>其它选择器 +0</li></ul><p>注意点：权重是不进位的。列如：11 个类选择器与 1 个 ID 选择器，权重高的还是 ID 选择器。</p><p>选择器优先级：</p><ul><li>!important 优先级最高</li><li>元素属性优先级高</li><li>相同权重，后写的生效</li></ul><h2 id="非布局样式"><a href="#非布局样式" class="headerlink" title="非布局样式"></a>非布局样式</h2><ul><li>字体、字重、颜色、大小、行高</li><li>背景、边框</li><li>滚动、换行</li><li>粗体、斜体、下划线</li><li>其它</li></ul><h3 id="字体相关知识"><a href="#字体相关知识" class="headerlink" title="字体相关知识"></a>字体相关知识</h3><p><strong>字体族：</strong></p><ul><li>serif：衬线字体</li><li>sans-serif：非衬线字体</li><li>monospace：等宽字体</li><li>cursive：手写字体</li><li>fantasy：花体</li></ul><p><strong>多字体 fallback</strong></p><p><strong>网络字体、自定义字体</strong></p><p><strong>iconfont</strong></p><h3 id="行高相关知识"><a href="#行高相关知识" class="headerlink" title="行高相关知识"></a>行高相关知识</h3><ul><li>行高的构成</li><li>行高相关的现象和方案</li><li>行高的调整</li></ul><h3 id="背景相关知识"><a href="#背景相关知识" class="headerlink" title="背景相关知识"></a>背景相关知识</h3><ul><li>背景颜色</li><li>渐变色背景</li><li>多背景叠加</li><li>背景图片和属性（雪碧图）</li><li>base64 和性能优化</li><li>多分辨率适配</li></ul><h3 id="边框相关知识"><a href="#边框相关知识" class="headerlink" title="边框相关知识"></a>边框相关知识</h3><ul><li>边框的属性：线型、大小、颜色</li><li>边框背景图</li><li>边框衔接（三角形）</li></ul><h3 id="滚动"><a href="#滚动" class="headerlink" title="滚动"></a>滚动</h3><ul><li>滚动行为和滚动条</li></ul><h3 id="文字折行"><a href="#文字折行" class="headerlink" title="文字折行"></a>文字折行</h3><ul><li>overflow-wrap(word-wrap) 通用换行控制<ul><li>是否保留单词</li></ul></li><li>work-break 针对多字节文字<ul><li>中文句子也是单词</li></ul></li><li>white-space 空白处是否断行</li></ul><h3 id="装饰性属性及其它"><a href="#装饰性属性及其它" class="headerlink" title="装饰性属性及其它"></a>装饰性属性及其它</h3><ul><li>字重（粗体）font-weight</li><li>斜体 font-style: itatic</li><li>下划线 text-decoration</li><li>指针 cursor</li></ul><h3 id="CSS-Hack"><a href="#CSS-Hack" class="headerlink" title="CSS Hack"></a>CSS Hack</h3><ul><li>Hack 即不合法但生效的写法</li><li>主要用于区分不同浏览器</li><li>缺点：<ul><li>难理解</li><li>难维护</li><li>易失效</li></ul></li><li>替代方案<ul><li>特性检测</li><li>针对性加 class</li></ul></li></ul><p>注意：标准属性写前面，Hack 属性写后面。</p><h3 id="CSS-面试题"><a href="#CSS-面试题" class="headerlink" title="CSS 面试题"></a>CSS 面试题</h3><p>1.CSS 样式（选择器）的优先级</p><blockquote><p>计算权重确定</p><p>!importmant</p><p>内联样式</p><p>后写的优先级高</p></blockquote><p>2.雪碧图的作用</p><blockquote><p>减少 HTTP 的请求数，提高加载性能</p><p>有一些情况下可以减少图片大小</p></blockquote><p>3.自定义字体的使用场景</p><blockquote><p>选择&#x2F;品牌&#x2F;banner 等固定文案</p><p>字体图标</p></blockquote><p>4.base64 的作用</p><blockquote><p>用于减少 HTTP 请求</p><p>适用于小图片</p><p>base64 的体积约为原图的 4&#x2F;3</p></blockquote><p>5.伪类和伪元素的区别</p><blockquote><p>伪类表状态</p><p>伪元素是真的有元素</p><p>前者单冒号，后者双冒号</p></blockquote><p>6.如何美化 checkbox</p><blockquote><p>label[for] 和 id</p><p>隐藏原生 input</p><p>:checked + label</p></blockquote><h2 id="CSS-布局"><a href="#CSS-布局" class="headerlink" title="CSS 布局"></a>CSS 布局</h2><ul><li>CSS 知识体系的重中之重</li><li>早期以 table 为主（简单）</li><li>后来以技巧性布局为主（难）</li><li>现在有 flexbox&#x2F;grid（偏简单）</li><li>响应式布局是必备知识</li></ul><h3 id="常用布局方法"><a href="#常用布局方法" class="headerlink" title="常用布局方法"></a>常用布局方法</h3><ul><li>table 表格布局</li><li>float 浮动 + margin</li><li>inline-block 布局</li><li>flexbox 布局</li></ul><p><img src="https://personal-blog.oss-cn-hangzhou.aliyuncs.com/front-box.png"></p><h3 id="常用布局属性"><a href="#常用布局属性" class="headerlink" title="常用布局属性"></a>常用布局属性</h3><ul><li>display：确定元素的显示类型（block&#x2F;inline&#x2F;inline-block）</li><li>position:：确定元素的位置（static&#x2F;relative&#x2F;absolute&#x2F;fixed）</li></ul><h3 id="flexbox"><a href="#flexbox" class="headerlink" title="flexbox"></a>flexbox</h3><ul><li>弹性盒子</li><li>盒子本来就是并列的</li><li>指定宽度即可</li></ul><h3 id="float"><a href="#float" class="headerlink" title="float"></a>float</h3><ul><li>元素「浮动」</li><li>脱离文档流</li><li>但不脱离文本流</li></ul><p>对自身的影响：</p><ul><li>形成「块」（BFC）</li><li>位置尽量靠上</li><li>位置尽量靠左（右）</li></ul><p>对兄弟的影响：</p><ul><li>上面贴非 float 元素</li><li>旁边贴 float 元素</li><li>不影响其它块级元素位置</li><li>影响其它块级元素内部文本</li></ul><p>对父级元素的影响：</p><ul><li>从布局上「消失」</li><li>高度塌陷<ul><li>父元素也变成 BFC 元素：overflow: auto&#x2F;hidden;</li><li>父元素添加伪元素：{content: ‘’; clear: both; display: block; height: 0;visibility: hidde;};</li></ul></li></ul><h3 id="inline-block"><a href="#inline-block" class="headerlink" title="inline-block"></a>inline-block</h3><ul><li>像文本一样排 block 元素</li><li>没有清除浮动等问题</li><li>需要处理间隙<ul><li>父元素：font-size: 0;</li><li>元素不换行</li></ul></li></ul><h3 id="响应式设计和布局"><a href="#响应式设计和布局" class="headerlink" title="响应式设计和布局"></a>响应式设计和布局</h3><ul><li>在不同设备上正常使用</li><li>一般主要处理屏幕大小问题</li><li>主要方法：<ul><li>隐藏 + 折行 + 自适应空间</li><li>rem&#x2F;viewport&#x2F;media query</li></ul></li></ul><h2 id="CSS-面试题-1"><a href="#CSS-面试题-1" class="headerlink" title="CSS 面试题"></a>CSS 面试题</h2><p>1.实现两栏（三栏）布局的方法</p><blockquote><p>表格布局</p><p>float + margin 布局</p><p>inline-block 布局</p><p>flexbox 布局</p></blockquote><p>2.position：absolute&#x2F;fixed 有什么区别</p><blockquote><p>前者相对最近的 absolute&#x2F;relative</p><p>后者相对屏幕（viewport）</p></blockquote><p>3.display:inline-block 的间隙</p><blockquote><p>原因：字符间距</p><p>解决：消灭字符或者消灭间距</p></blockquote><p>4.如何清除浮动</p><blockquote><p>让盒子负责自己的布局</p><p>overflow:hidden(auto)</p><p>::after{clear:both}</p></blockquote><p>5.如何适配移动端页面</p><blockquote><p>viewport</p><p>rem&#x2F;viewport&#x2F;media query</p><p>设计上：隐藏、折行、自适应</p></blockquote><h2 id="CSS-效果"><a href="#CSS-效果" class="headerlink" title="CSS 效果"></a>CSS 效果</h2><h3 id="效果属性"><a href="#效果属性" class="headerlink" title="效果属性"></a>效果属性</h3><ul><li>box-shadow<ul><li>营造层次感（立体感）</li><li>充当没有宽度的边框</li><li>特殊效果</li></ul></li><li>text-shadow<ul><li>立体感</li><li>印刷品质感</li></ul></li><li>border-radius<ul><li>圆角矩形</li><li>圆形</li><li>半圆&#x2F;扇形</li><li>一些奇怪的角角</li></ul></li><li>background<ul><li>纹理、图案</li><li>渐变</li><li>雪碧图动画</li><li>背景图尺寸适应</li></ul></li><li>clip-path<ul><li>对容器进行裁剪</li><li>常见几何图形</li><li>自定义路径</li></ul></li></ul><h3 id="3D-transform"><a href="#3D-transform" class="headerlink" title="3D transform"></a>3D transform</h3><ul><li>变换 transform<ul><li>translate</li><li>scale</li><li>skew</li><li>rotate</li></ul></li><li>3D 变换<ul><li>在 3D 空间中进行变换</li></ul></li></ul><h3 id="面试题"><a href="#面试题" class="headerlink" title="面试题"></a>面试题</h3><p> 1.如何用一个 div 绘制 xxx</p><blockquote><p>box-shadow 无限投影</p><p>::before</p><p>::after</p></blockquote><p>2.如何产生不占空间的边框</p><blockquote><p>box-shadow</p><p>outline</p></blockquote><p>3.如何实现圆形元素</p><blockquote><p>border-radius</p></blockquote><p>4.如何实现 iOS 图标的圆角</p><blockquote><p>clip-path</p></blockquote><p>5.如何实现半圆、扇形等图形</p><blockquote><p>border-radius 组合</p></blockquote><p>6.如何实现背景图居中显示&#x2F;不重复&#x2F;改变大小</p><blockquote><p>background-position</p><p>background-repeat</p><p>background-size(cover&#x2F;contain)</p></blockquote><p>7.如何平移&#x2F;放大一个元素</p><blockquote><p>transform: translateX(100px)</p><p>transform: scale(2)</p></blockquote><p>8.如何实现 3D 效果</p><blockquote><p>perspective: 500px;</p><p>transform-style: preserve-3d</p><p>transform: translate rotate …</p></blockquote><h2 id="CSS-动画"><a href="#CSS-动画" class="headerlink" title="CSS 动画"></a>CSS 动画</h2><p>动画的原理：</p><ol><li>视觉暂留作用</li><li>画面逐渐变化</li></ol><p>CSS 中的动画类型：</p><ol><li>transition 补间动画<ol><li>位置-平移（left&#x2F;right&#x2F;margin&#x2F;transform）</li><li>方位-旋转（transform）</li><li>大小-缩放（transform）</li><li>透明度（opacity）</li><li>其他-线性变换（transform）</li></ol></li><li>keyframe 关键帧动画<ol><li>相当于多个补件动画</li><li>与元素状态的变化无关</li><li>定义更加灵活</li></ol></li><li>逐帧动画<ol><li>适用于无法补间计算的动画</li><li>资源较大</li><li>使用 steps()</li></ol></li></ol><h3 id="面试题-1"><a href="#面试题-1" class="headerlink" title="面试题"></a>面试题</h3><p> 1.CSS 动画的实现方式有几种</p><blockquote><p>transition</p><p>keyframes(animation)</p></blockquote><p>2.过渡动画和关键帧动画的区别</p><blockquote><p>过渡动画需要有状态变化</p><p>关键帧动画不需要状态变化</p><p>关键帧动画能控制更精细</p></blockquote><p> 3.如何实现逐帧动画</p><blockquote><p>使用关键帧动画</p><p>去掉补间（steps）</p></blockquote><p>4.CSS 动画的性能</p><blockquote><p>性能不坏</p><p>部分情况下优于 JS</p><p>但 JS 可以做到更好</p><p>部分高危属性（box-shadow 等）</p></blockquote><h2 id="预处理器"><a href="#预处理器" class="headerlink" title="预处理器"></a>预处理器</h2><ul><li>基于 CSS 的另一种语言</li><li>通过工具编译成 CSS</li><li>添加了很多 CSS 不具备的特性</li><li>能提升 CSS 的文件组织</li></ul><p><strong>作用</strong></p><ol><li>嵌套：反映层级和约束</li><li>变量和计算：减少重复代码</li><li>Extend 和 Mixin：代码片段</li><li>循环：适用于复杂有规律的样式</li><li>import：CSS 文件模块化</li></ol><h3 id="less"><a href="#less" class="headerlink" title="less"></a>less</h3><p><strong>变量</strong>：</p><blockquote><p>声明：以 <strong>@</strong> 开头，例如：@titleFontSize</p><p>使用：@titleFontSize</p></blockquote><p><strong>minxin</strong></p><blockquote><p>声明：.className(params) { &#x2F;* content *&#x2F;}</p><p>使用：.className(…)</p></blockquote><p>无参情况下：「()」可加可不加，区别是，加了「()」的 className，编译后不存在，不加的情况下，会生成 .className 类。</p><p><strong>extend</strong></p><blockquote><p>使用：xxx:extend(className) { &#x2F;* content *&#x2F; }</p></blockquote><p><strong>loop</strong></p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.className</span>(<span class="keyword">@n</span>) when (@n &gt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="selector-class">.className</span>(<span class="keyword">@n</span> - <span class="number">1</span>);</span><br><span class="line"><span class="selector-class">.generateName-</span><span class="keyword">@n</span> &#123;</span><br><span class="line">// <span class="attribute">content</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">. className(<span class="number">12</span>);</span><br></pre></td></tr></table></figure><p><strong>import</strong></p><blockquote><p>使用：@import “file-path”;</p></blockquote><h3 id="sass-scss"><a href="#sass-scss" class="headerlink" title="sass&#x2F;scss"></a>sass&#x2F;scss</h3><p>变量：</p><blockquote><p>声明：以 <strong>$</strong> 开头，例如：$titleFontSize</p><p>使用：$titleFontSize</p></blockquote><p><strong>minxin</strong></p><blockquote><p>声明：以 <strong>@minxin</strong> 开头，且，不能有「.」，内容写法与 less 一致。例如：@mixin className(params) { &#x2F;* content *&#x2F;}</p><p>使用：@include className(…)</p></blockquote><p><strong>extend</strong></p><blockquote><p>使用：@extend .className</p></blockquote><p><strong>loop</strong></p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line">// 方式一</span><br><span class="line"><span class="keyword">@mixin</span> className($n) &#123;</span><br><span class="line"><span class="keyword">@if</span> $n &gt; <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">@include</span> className($n - <span class="number">1</span>);</span><br><span class="line"><span class="selector-class">.generateName-</span>#&#123;$n&#125; &#123;</span><br><span class="line">// <span class="attribute">content</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@include</span> className(<span class="number">12</span>);</span><br><span class="line"></span><br><span class="line">// 方式二</span><br><span class="line"><span class="keyword">@for</span> $i from <span class="number">1</span> through <span class="number">12</span> &#123;</span><br><span class="line"><span class="selector-class">.generateName-</span>#&#123;$<span class="selector-tag">i</span>&#125; &#123;</span><br><span class="line">// <span class="attribute">content</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>import</strong></p><blockquote><p>使用：@import “file-path”;</p></blockquote><h3 id="CSS-预处理器框架"><a href="#CSS-预处理器框架" class="headerlink" title="CSS 预处理器框架"></a>CSS 预处理器框架</h3><ul><li>SASS - Compass</li><li>Less - Lesshat &#x2F; EST</li><li>提供现成的 mixin</li><li>类似 JS 类库，封装常用功能</li></ul><h3 id="CSS-面试真题"><a href="#CSS-面试真题" class="headerlink" title="CSS 面试真题"></a>CSS 面试真题</h3><p> 1.常见的 CSS 预处理器</p><blockquote><p>Less(Node.js)</p><p>Saaa(Ruby 有 Node 版本)</p></blockquote><p>2.预处理器的作用</p><blockquote><p>帮助更好地组织 CSS 代码</p><p>提高代码复用率</p><p>提高可维护性</p></blockquote><p>3.预处理器的能力</p><blockquote><p>嵌套：反映层级和约束</p><p>变量和计算：减少重复代码</p><p>Extend 和 Mixin：代码片段</p><p>循环：适用于复杂有规律的样式</p><p>import：CSS 文件模块化</p></blockquote><p>4.预处理器的优缺点</p><blockquote><p>优点：提高代码复用率和可维护性</p><p>缺点：需要引入编译过程，有学习成本</p></blockquote><h2 id="CSS-工程化"><a href="#CSS-工程化" class="headerlink" title="CSS 工程化"></a>CSS 工程化</h2><p>关注点：</p><ol><li>组织：代码的组织</li><li>优化：代码怎样写更好</li><li>构建：代码写完之后的处理步骤</li><li>维护：后期修复或迭代</li></ol><h3 id="PostCSS"><a href="#PostCSS" class="headerlink" title="PostCSS"></a>PostCSS</h3><p><img src="https://personal-blog.oss-cn-hangzhou.aliyuncs.com/post_css.png"></p><ul><li>PostCSS 本身只有解析能力</li><li>各种神奇的特性全靠插件</li><li>目前至少有 200 多个插件<ul><li>import：模块合并</li><li>autoprefixier：自动加前缀</li><li>cssnano：压缩代码</li><li>cssnext：使用 CSS 新特性</li><li>precss：变量、mixin、循环等</li></ul></li></ul><p><strong>cssnext</strong></p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-pseudo">:root</span> &#123; // 只能在 root 里面定义变量</span><br><span class="line"><span class="attr">--mainColor</span>: red;</span><br><span class="line"><span class="attr">--danger-theme</span>: &#123;</span><br><span class="line"><span class="attribute">color</span>: white;</span><br><span class="line"><span class="attribute">background-color</span>: red;</span><br><span class="line">&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">a</span> &#123;</span><br><span class="line"><span class="attribute">color</span>: <span class="built_in">var</span>(--mainColor);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.danger</span> &#123;</span><br><span class="line"><span class="keyword">@apply</span> --danger-theme;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>precss</strong></p><ul><li>变量</li><li>条件（if）</li><li>循环</li><li>Mixin、Extend</li><li>import</li><li>属性值引用</li></ul><h4 id="PostCSS-支持的构件工具"><a href="#PostCSS-支持的构件工具" class="headerlink" title="PostCSS 支持的构件工具"></a>PostCSS 支持的构件工具</h4><ul><li>CLI 命令行工具</li><li>webpack postcss-loader</li><li>Gulp gulp-postcss</li><li>Grunt grunt-postcss</li><li>Rollup rollup-postcss</li></ul><h4 id="webpack"><a href="#webpack" class="headerlink" title="webpack"></a>webpack</h4><ul><li>JS 是整个应用的核心入口</li><li>一切资源均由 JS 管理依赖</li><li>一切资源均由 webpack 打包</li></ul><h3 id="webpack-和-CSS"><a href="#webpack-和-CSS" class="headerlink" title="webpack 和 CSS"></a>webpack 和 CSS</h3><ul><li>css-loader 将 CSS 变成 JS</li><li>style-loader 将 JS 样式插入 head</li><li>ExtractTextPlugin 将 CSS 从 JS 中提取出来</li><li>css module 解决 CSS 命名冲突的问题</li><li>less-loader sass-loader 各类预处理器</li><li>postcss-loader PostCSS 处理</li></ul><h3 id="面试真题"><a href="#面试真题" class="headerlink" title="面试真题"></a>面试真题</h3><p> 1.如何解决 CSS 模块化问题</p><blockquote><p>Less Sass 等 CSS 预处理器</p><p>PostCSS 插件（postcss-import&#x2F;precss 等）</p><p>webpack 处理 CSS（css-loader + style - loader）</p></blockquote><p>2.PostCSS 可以做什么？</p><blockquote><p>取决于插件可以做什么</p><p>autoprefixer cssnext precss 等兼容性处理</p><p>import 模块合并</p><p>css 语法检查，兼容性检查</p><p>压缩问价</p></blockquote><p> 3.CSS modules 是做什么的，如何使用</p><blockquote><p>解决类名冲突的问题</p><p>使用 PostCSS 或者 webpack 等构建工具进行编译</p><p>在 HTML 模板中使用编译过程产生的类名</p></blockquote><p>4.为什么使用 JS 来引用、加载 CSS</p><blockquote><p>JS 作为入口，管理资源有天然优势</p><p>将组件的结构、样式、行为封装到一起，增强内聚</p><p>可以做更多处理（webpack）</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CSS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>动画</title>
      <link href="/2021/12/18/Flutter/%E5%8A%A8%E7%94%BB/"/>
      <url>/2021/12/18/Flutter/%E5%8A%A8%E7%94%BB/</url>
      
        <content type="html"><![CDATA[<h2 id="动画"><a href="#动画" class="headerlink" title="动画"></a>动画</h2><p>Flutter 中的动画系统基于 <code>Animation</code> 对象，与之前的手势不同，它不是一个 <strong>Widget</strong>，这是因为 <code>Animation</code> 对象本身和 UI 渲染没有任何关系。</p><p><code>Animation</code> 是一个抽象类，相当于一个定时器，它用于保存动画的插值和状态，并执行数值的变化。Widget 可以在 <strong>build</strong> 函数中读取 <code>Animation</code> 对象的当前值，并且可以监听动画的状态改变。</p><h3 id="AnimationController"><a href="#AnimationController" class="headerlink" title="AnimationController"></a>AnimationController</h3><p>AnimationController 用于控制动画，它包含 <strong>forward()、stop()、reverse()</strong> 等方法。AnimationController 会在动画的每一帧，就会生成一个新的值。默认情况下，AnimationController 在给定的时间段内线性的生成从 0.0 到 1.0 的数字。</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">AnimationController controller = AnimationController( </span><br><span class="line"> duration: <span class="keyword">const</span> <span class="built_in">Duration</span>(milliseconds: <span class="number">2000</span>), <span class="comment">// 动画时间</span></span><br><span class="line"> lowerBound: <span class="number">10.0</span>,<span class="comment">// 生成数字的区间 </span></span><br><span class="line"> upperBound: <span class="number">20.0</span>,<span class="comment">// 10.0 ~ 20.0</span></span><br><span class="line"> vsync: <span class="keyword">this</span>  <span class="comment">// TickerProvider 动画驱动器提供者</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure><h3 id="Ticker"><a href="#Ticker" class="headerlink" title="Ticker"></a>Ticker</h3><p>Ticker 的作用是添加屏幕刷新回调，每次屏幕刷新都会调用 <code>TikerCallback</code>。使用 <code>Ticker</code> 来驱动动画，防止屏幕外动画（动画的 UI 不在当前屏幕时，比如：锁屏）消耗不必要的资源。因为 Flutter 在屏幕中刷新时会通知 <code>Ticker</code>，锁屏后屏幕会停止刷新，所以 Ticker 就不会再触发。最简单的做法为：将 <code>SingleTickerProviderStateMixin</code> 添加到 State 的定义中。</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&#x27;package:flutter/material.dart&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> main() =&gt; runApp(AnimationApp());</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AnimationApp</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> MaterialApp(</span><br><span class="line">      title: <span class="string">&quot;animation&quot;</span>,</span><br><span class="line">      home: Scaffold(</span><br><span class="line">        appBar: AppBar(</span><br><span class="line">          title: Text(<span class="string">&#x27;animation&#x27;</span>),</span><br><span class="line">        ),</span><br><span class="line">        body: AnimWidget(),</span><br><span class="line">      ),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 动画是有状态的</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AnimWidget</span> <span class="keyword">extends</span> <span class="title">StatefulWidget</span> </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  State&lt;StatefulWidget&gt; createState() &#123;</span><br><span class="line">    <span class="keyword">return</span> _AnimWidgetState();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">_AnimWidgetState</span> <span class="keyword">extends</span> <span class="title">State</span>&lt;<span class="title">AnimWidget</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="title">with</span> <span class="title">SingleTickerProviderStateMixin</span> </span>&#123;</span><br><span class="line">  AnimationController controller;</span><br><span class="line">  <span class="built_in">bool</span> forward = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="keyword">void</span> initState() &#123;</span><br><span class="line">    <span class="keyword">super</span>.initState();</span><br><span class="line">    controller = AnimationController(</span><br><span class="line">      <span class="comment">// 动画的时长</span></span><br><span class="line">      duration: <span class="built_in">Duration</span>(milliseconds: <span class="number">2000</span>),</span><br><span class="line">      lowerBound: <span class="number">10.0</span>,</span><br><span class="line">      upperBound: <span class="number">100.0</span>,</span><br><span class="line">      <span class="comment">// 提供 vsync 最简单的方式，就是直接混入 SingleTickerProviderStateMixin</span></span><br><span class="line">      <span class="comment">// 如果有多个 AnimationController，则使用 TickerProviderStateMixin。</span></span><br><span class="line">      vsync: <span class="keyword">this</span>,</span><br><span class="line">    );</span><br><span class="line">   <span class="comment">// 状态修改监听</span></span><br><span class="line">    controller</span><br><span class="line">      ..addStatusListener((AnimationStatus status) &#123;</span><br><span class="line">        debugPrint(<span class="string">&quot;状态：<span class="subst">$status</span>&quot;</span>);</span><br><span class="line">      &#125;)</span><br><span class="line">      ..addListener(() &#123;</span><br><span class="line">        setState(() =&gt; &#123;&#125;);</span><br><span class="line">      &#125;);</span><br><span class="line">    debugPrint(<span class="string">&quot;controller.value:<span class="subst">$&#123;controller.value&#125;</span>&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> Column(</span><br><span class="line">      children: &lt;Widget&gt;[</span><br><span class="line">        Container(</span><br><span class="line">          width: controller.value,</span><br><span class="line">          height: controller.value,</span><br><span class="line">          color: Colors.blue,</span><br><span class="line">        ),</span><br><span class="line">        RaisedButton(</span><br><span class="line">          child: Text(<span class="string">&quot;播放&quot;</span>),</span><br><span class="line">          onPressed: () &#123;</span><br><span class="line">            <span class="keyword">if</span> (forward) &#123;</span><br><span class="line">              controller.forward();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">              controller.reverse();</span><br><span class="line">            &#125;</span><br><span class="line">            forward = !forward;</span><br><span class="line">          &#125;,</span><br><span class="line">        ),</span><br><span class="line">        RaisedButton(</span><br><span class="line">          child: Text(<span class="string">&quot;停止&quot;</span>),</span><br><span class="line">          onPressed: () &#123;</span><br><span class="line">            controller.stop();</span><br><span class="line">          &#125;,</span><br><span class="line">        )</span><br><span class="line">      ],</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>动画状态监听：在 <strong>forword</strong> 结束之后状态为 <strong>completed</strong>。在 <strong>reverse</strong> 结束之后状态为 <strong>dismissed</strong>。</p></blockquote><h3 id="Tween"><a href="#Tween" class="headerlink" title="Tween"></a>Tween</h3><p>默认情况下，<code>AnimationController</code> 对象值为 <strong>double</strong> 类型，范围是 <strong>0.0 ~ 1.0</strong>。如果我们需要不同的范围&#x2F;数据类型，则可以使用 <code>Tween</code> 来配置动画以生成不同的范围或数据类型的值。要使用 <code>Tween</code> 对象，需要调用其 <code>animate()</code> 方法，然后传入一个控制器对象，同时动画过程中产生的数值由 <code>Tween</code> 的 <code>lerp</code> 方法决定。</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&#x27;package:flutter/material.dart&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> main() =&gt; runApp(AnimationApp());</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AnimationApp</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> MaterialApp(</span><br><span class="line">      title: <span class="string">&quot;animation&quot;</span>,</span><br><span class="line">      home: Scaffold(</span><br><span class="line">        appBar: AppBar(</span><br><span class="line">          title: Text(<span class="string">&#x27;animation&#x27;</span>),</span><br><span class="line">        ),</span><br><span class="line">        body: AnimWidget(),</span><br><span class="line">      ),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 动画是有状态的</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AnimWidget</span> <span class="keyword">extends</span> <span class="title">StatefulWidget</span> </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  State&lt;StatefulWidget&gt; createState() &#123;</span><br><span class="line">    <span class="keyword">return</span> _AnimWidgetState();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">_AnimWidgetState</span> <span class="keyword">extends</span> <span class="title">State</span>&lt;<span class="title">AnimWidget</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="title">with</span> <span class="title">SingleTickerProviderStateMixin</span> </span>&#123;</span><br><span class="line">  AnimationController controller;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">bool</span> forward = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">  Tween&lt;Color&gt; tween;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="keyword">void</span> initState() &#123;</span><br><span class="line">    <span class="keyword">super</span>.initState();</span><br><span class="line"></span><br><span class="line">    controller = AnimationController(</span><br><span class="line">      <span class="comment">// 动画的时长</span></span><br><span class="line">      duration: <span class="built_in">Duration</span>(milliseconds: <span class="number">2000</span>),</span><br><span class="line">      <span class="comment">// 提供 vsync 最简单的方式，就是直接继承 SingleTickerProviderStateMixin</span></span><br><span class="line">      vsync: <span class="keyword">this</span>,</span><br><span class="line">    );</span><br><span class="line">    <span class="comment">// 使用 Color</span></span><br><span class="line">    tween = ColorTween(begin: Colors.blue, end: Colors.yellow);</span><br><span class="line">    <span class="comment">// 添加动画值修改监听</span></span><br><span class="line">    tween.animate(controller)..addListener(() =&gt; setState(() &#123;&#125;));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> Column(</span><br><span class="line">      children: &lt;Widget&gt;[</span><br><span class="line">        Container(</span><br><span class="line">          width: <span class="number">100</span>,</span><br><span class="line">          height: <span class="number">100</span>,</span><br><span class="line">          <span class="comment">// 获取动画当前值</span></span><br><span class="line">          color: tween.evaluate(controller),</span><br><span class="line">        ),</span><br><span class="line">        RaisedButton(</span><br><span class="line">          child: Text(<span class="string">&quot;播放&quot;</span>),</span><br><span class="line">          onPressed: () &#123;</span><br><span class="line">            <span class="keyword">if</span> (forward) &#123;</span><br><span class="line">              controller.forward();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">              controller.reverse();</span><br><span class="line">            &#125;</span><br><span class="line">            forward = !forward;</span><br><span class="line">          &#125;,</span><br><span class="line">        ),</span><br><span class="line">        RaisedButton(</span><br><span class="line">          child: Text(<span class="string">&quot;停止&quot;</span>),</span><br><span class="line">          onPressed: () &#123;</span><br><span class="line">            controller.stop();</span><br><span class="line">          &#125;,</span><br><span class="line">        )</span><br><span class="line">      ],</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Curve"><a href="#Curve" class="headerlink" title="Curve"></a>Curve</h3><p>动画过程默认是线性的，如果需要非线性的，比如：加速、先加速后减速等。Flutter 中可以通过 Curve 来描述动画过程。</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&#x27;package:flutter/material.dart&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> main() =&gt; runApp(AnimationApp());</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AnimationApp</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> MaterialApp(</span><br><span class="line">      title: <span class="string">&quot;animation&quot;</span>,</span><br><span class="line">      home: Scaffold(</span><br><span class="line">        appBar: AppBar(</span><br><span class="line">          title: Text(<span class="string">&#x27;animation&#x27;</span>),</span><br><span class="line">        ),</span><br><span class="line">        body: AnimWidget(),</span><br><span class="line">      ),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 动画是有状态的</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AnimWidget</span> <span class="keyword">extends</span> <span class="title">StatefulWidget</span> </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  State&lt;StatefulWidget&gt; createState() &#123;</span><br><span class="line">    <span class="keyword">return</span> _AnimWidgetState();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">_AnimWidgetState</span> <span class="keyword">extends</span> <span class="title">State</span>&lt;<span class="title">AnimWidget</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="title">with</span> <span class="title">SingleTickerProviderStateMixin</span> </span>&#123;</span><br><span class="line">  AnimationController controller;</span><br><span class="line">  Animation&lt;<span class="built_in">double</span>&gt; animation;</span><br><span class="line">  <span class="built_in">bool</span> forward = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="keyword">void</span> initState() &#123;</span><br><span class="line">    <span class="keyword">super</span>.initState();</span><br><span class="line"></span><br><span class="line">    controller = AnimationController(</span><br><span class="line">      <span class="comment">// 动画的时长</span></span><br><span class="line">      duration: <span class="built_in">Duration</span>(milliseconds: <span class="number">2000</span>),</span><br><span class="line">      <span class="comment">// 提供 vsync 最简单的方式，就是直接继承 SingleTickerProviderStateMixin</span></span><br><span class="line">      vsync: <span class="keyword">this</span>,</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 弹性</span></span><br><span class="line">    animation = CurvedAnimation(parent: controller, curve: Curves.bounceIn);</span><br><span class="line">    <span class="comment">// 使用 Color</span></span><br><span class="line">    animation = Tween(begin: <span class="number">10.0</span>, end: <span class="number">100.0</span>).animate(animation)</span><br><span class="line">      ..addListener(() &#123;</span><br><span class="line">        setState(() =&gt; &#123;&#125;);</span><br><span class="line">      &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> Column(</span><br><span class="line">      children: &lt;Widget&gt;[</span><br><span class="line">        Container(</span><br><span class="line">          <span class="comment">// 不需要转换</span></span><br><span class="line">          width: animation.value,</span><br><span class="line">          height: animation.value,</span><br><span class="line">          <span class="comment">// 获取动画当前值</span></span><br><span class="line">          color: Colors.blue,</span><br><span class="line">        ),</span><br><span class="line">        RaisedButton(</span><br><span class="line">          child: Text(<span class="string">&quot;播放&quot;</span>),</span><br><span class="line">          onPressed: () &#123;</span><br><span class="line">            <span class="keyword">if</span> (forward) &#123;</span><br><span class="line">              controller.forward();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">              controller.reverse();</span><br><span class="line">            &#125;</span><br><span class="line">            forward = !forward;</span><br><span class="line">          &#125;,</span><br><span class="line">        ),</span><br><span class="line">        RaisedButton(</span><br><span class="line">          child: Text(<span class="string">&quot;停止&quot;</span>),</span><br><span class="line">          onPressed: () &#123;</span><br><span class="line">            controller.stop();</span><br><span class="line">          &#125;,</span><br><span class="line">        )</span><br><span class="line">      ],</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="AnimatedWidget"><a href="#AnimatedWidget" class="headerlink" title="AnimatedWidget"></a>AnimatedWidget</h3><p>通过上面的学习我们能够感受到 <code>Animation</code> 对象本身和UI渲染没有任何关系。而通过 <code>addListener()</code> 和 <code>setState()</code> 来更新 UI 这一步其实是通用的，如果每个动画中都加这么一句是比较繁琐的。AnimatedWidget 类封装了调用 <code>setState()</code> 的细节，简单来说就是自动调用 <code>setState()</code>。</p><p>Flutter 中已经封装了很多动画，比如对 widget 进行缩放，可以直接使用 <code>ScaleTransition</code>。</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&#x27;package:flutter/material.dart&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> main() =&gt; runApp(AnimationApp());</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AnimationApp</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> MaterialApp(</span><br><span class="line">      title: <span class="string">&quot;animation&quot;</span>,</span><br><span class="line">      home: Scaffold(</span><br><span class="line">        appBar: AppBar(</span><br><span class="line">          title: Text(<span class="string">&#x27;animation&#x27;</span>),</span><br><span class="line">        ),</span><br><span class="line">        body: AnimWidget(),</span><br><span class="line">      ),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 动画是有状态的</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AnimWidget</span> <span class="keyword">extends</span> <span class="title">StatefulWidget</span> </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  State&lt;StatefulWidget&gt; createState() &#123;</span><br><span class="line">    <span class="keyword">return</span> _AnimWidgetState();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">_AnimWidgetState</span> <span class="keyword">extends</span> <span class="title">State</span>&lt;<span class="title">AnimWidget</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="title">with</span> <span class="title">SingleTickerProviderStateMixin</span> </span>&#123;</span><br><span class="line">  AnimationController controller;</span><br><span class="line">  Animation&lt;<span class="built_in">double</span>&gt; animation;</span><br><span class="line">  <span class="built_in">bool</span> forward = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="keyword">void</span> initState() &#123;</span><br><span class="line">    <span class="keyword">super</span>.initState();</span><br><span class="line"></span><br><span class="line">    controller = AnimationController(</span><br><span class="line">      <span class="comment">// 动画的时长</span></span><br><span class="line">      duration: <span class="built_in">Duration</span>(milliseconds: <span class="number">2000</span>),</span><br><span class="line">      <span class="comment">// 提供 vsync 最简单的方式，就是直接继承 SingleTickerProviderStateMixin</span></span><br><span class="line">      vsync: <span class="keyword">this</span>,</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 弹性</span></span><br><span class="line">    animation = CurvedAnimation(parent: controller, curve: Curves.bounceIn);</span><br><span class="line">    <span class="comment">// 使用 Color</span></span><br><span class="line">    animation = Tween(begin: <span class="number">10.0</span>, end: <span class="number">100.0</span>).animate(animation);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> Column(</span><br><span class="line">      children: &lt;Widget&gt;[</span><br><span class="line">        ScaleTransition(</span><br><span class="line">          child:  Container(</span><br><span class="line">            width: <span class="number">100</span>,</span><br><span class="line">            height: <span class="number">100</span>,</span><br><span class="line">            color: Colors.blue,</span><br><span class="line">          ),</span><br><span class="line">          scale: controller,</span><br><span class="line">        ),</span><br><span class="line">        RaisedButton(</span><br><span class="line">          child: Text(<span class="string">&quot;播放&quot;</span>),</span><br><span class="line">          onPressed: () &#123;</span><br><span class="line">            <span class="keyword">if</span> (forward) &#123;</span><br><span class="line">              controller.forward();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">              controller.reverse();</span><br><span class="line">            &#125;</span><br><span class="line">            forward = !forward;</span><br><span class="line">          &#125;,</span><br><span class="line">        ),</span><br><span class="line">        RaisedButton(</span><br><span class="line">          child: Text(<span class="string">&quot;停止&quot;</span>),</span><br><span class="line">          onPressed: () &#123;</span><br><span class="line">            controller.stop();</span><br><span class="line">          &#125;,</span><br><span class="line">        )</span><br><span class="line">      ],</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Hero-动画"><a href="#Hero-动画" class="headerlink" title="Hero 动画"></a>Hero 动画</h3><p>Hero 动画就是在路由切换时，有一个共享的 Widget 可以在新旧路由间切换，由于共享的 Widget 在新旧路由页面上的位置、外观可能有所差异，所以在路由切换时会逐渐过渡，这样就会产生一个 Hero 动画。</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&#x27;package:flutter/material.dart&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> main() =&gt; runApp(MyApp());</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyApp</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> MaterialApp(</span><br><span class="line">      title: <span class="string">&#x27;Flutter Demo&#x27;</span>,</span><br><span class="line">      home: Scaffold(</span><br><span class="line">          appBar: AppBar(</span><br><span class="line">            title: Text(<span class="string">&quot;主页&quot;</span>),</span><br><span class="line">          ),</span><br><span class="line">          body: Route1()),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 路由A</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Route1</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> Container(</span><br><span class="line">      alignment: Alignment.topCenter,</span><br><span class="line">      child: InkWell(</span><br><span class="line">        child: Hero(</span><br><span class="line">          tag: <span class="string">&quot;avatar&quot;</span>, <span class="comment">// 唯一标记，前后两个路由页 Hero 的 tag 必须相同</span></span><br><span class="line">          child: CircleAvatar(</span><br><span class="line">            backgroundImage: AssetImage(</span><br><span class="line">              <span class="string">&quot;assets/banner.jpeg&quot;</span>,</span><br><span class="line">            ),</span><br><span class="line">          ),</span><br><span class="line">        ),</span><br><span class="line">        onTap: () &#123;</span><br><span class="line">          Navigator.push(context, MaterialPageRoute(builder: (_) &#123;</span><br><span class="line">            <span class="keyword">return</span> Route2();</span><br><span class="line">          &#125;));</span><br><span class="line">        &#125;,</span><br><span class="line">      ),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Route2</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> Center(</span><br><span class="line">      child: Hero(</span><br><span class="line">          tag: <span class="string">&quot;avatar&quot;</span>, <span class="comment">// 唯一标记，前后两个路由页 Hero 的 tag 必须相同</span></span><br><span class="line">          child: Image.asset(<span class="string">&quot;assets/banner.jpeg&quot;</span>)),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="组合动画"><a href="#组合动画" class="headerlink" title="组合动画"></a>组合动画</h3><p>有些时候我们可能会需要执行一个动画序列执行一些复杂的动画。</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&#x27;package:flutter/material.dart&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> main() =&gt; runApp(MyApp());</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyApp</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> MaterialApp(</span><br><span class="line">      title: <span class="string">&#x27;Flutter Demo&#x27;</span>,</span><br><span class="line">      home: Route(),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Route</span> <span class="keyword">extends</span> <span class="title">StatefulWidget</span> </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  State&lt;StatefulWidget&gt; createState() &#123;</span><br><span class="line">    <span class="keyword">return</span> RouteState();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RouteState</span> <span class="keyword">extends</span> <span class="title">State</span>&lt;<span class="title">Route</span>&gt; <span class="title">with</span> <span class="title">SingleTickerProviderStateMixin</span> </span>&#123;</span><br><span class="line">  Animation&lt;Color&gt; color;</span><br><span class="line">  Animation&lt;<span class="built_in">double</span>&gt; width;</span><br><span class="line">  AnimationController controller;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="keyword">void</span> initState() &#123;</span><br><span class="line">    <span class="keyword">super</span>.initState();</span><br><span class="line">    controller = AnimationController(</span><br><span class="line">      <span class="comment">// 动画的时长</span></span><br><span class="line">      duration: <span class="built_in">Duration</span>(milliseconds: <span class="number">2000</span>),</span><br><span class="line">      <span class="comment">// 提供 vsync 最简单的方式，就是直接继承 SingleTickerProviderStateMixin</span></span><br><span class="line">      vsync: <span class="keyword">this</span>,</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 高度动画</span></span><br><span class="line">    width = Tween&lt;<span class="built_in">double</span>&gt;(</span><br><span class="line">      begin: <span class="number">100.0</span>,</span><br><span class="line">      end: <span class="number">300.0</span>,</span><br><span class="line">    ).animate(</span><br><span class="line">      CurvedAnimation(</span><br><span class="line">        parent: controller,</span><br><span class="line">        curve: Interval(</span><br><span class="line">          <span class="comment">// 间隔，前 60% 的动画时间 1200ms 执行高度变化</span></span><br><span class="line">          <span class="number">0.0</span>, <span class="number">0.6</span>,</span><br><span class="line">        ),</span><br><span class="line">      ),</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    color = ColorTween(</span><br><span class="line">      begin: Colors.green,</span><br><span class="line">      end: Colors.red,</span><br><span class="line">    ).animate(</span><br><span class="line">      CurvedAnimation(</span><br><span class="line">        parent: controller,</span><br><span class="line">        curve: Interval(</span><br><span class="line">          <span class="number">0.6</span>, <span class="number">1.0</span>, <span class="comment">// 高度变化完成后 800ms 执行颜色编码</span></span><br><span class="line">        ),</span><br><span class="line">      ),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> Scaffold(</span><br><span class="line">      appBar: AppBar(</span><br><span class="line">        title: Text(<span class="string">&quot;主页&quot;</span>),</span><br><span class="line">      ),</span><br><span class="line">      body: InkWell(</span><br><span class="line">        <span class="comment">/// <span class="language-markdown">1、不用显式的去添加帧监听器，再调用 setState()</span></span></span><br><span class="line">        <span class="comment">/// <span class="language-markdown">2、缩小动画构建的范围，如果没有 builder，setState() 将会在父 widget上下文调用，导致父 widget 的 build 方法重新调用，现在只会导致动画 widget 的 build 重新调用</span></span></span><br><span class="line">        child: AnimatedBuilder(</span><br><span class="line">            animation: controller,</span><br><span class="line">            builder: (context, child) &#123;</span><br><span class="line">              <span class="keyword">return</span> Container(</span><br><span class="line">                color: color.value,</span><br><span class="line">                width: width.value,</span><br><span class="line">                height: <span class="number">100.0</span>,</span><br><span class="line">              );</span><br><span class="line">            &#125;),</span><br><span class="line">        onTap: () &#123;</span><br><span class="line">          controller.forward().whenCompleteOrCancel(() =&gt; controller.reverse());</span><br><span class="line">        &#125;,</span><br><span class="line">      ),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Flutter </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Dart </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>插件</title>
      <link href="/2021/12/16/Flutter/%E6%8F%92%E4%BB%B6/"/>
      <url>/2021/12/16/Flutter/%E6%8F%92%E4%BB%B6/</url>
      
        <content type="html"><![CDATA[<p>在 Flutter 提供的丰富能力场景之外，有时还需要一些系统提供的能力，比如 Android 中使用 Logcat、陀螺仪传感器、推送等等，这些 Flutter 都不能提供有力的支持，因此，需要有一个桥梁去沟通 Flutter 和原生的能力，这就需要 <code>插件</code>。</p><h2 id="什么是插件"><a href="#什么是插件" class="headerlink" title="什么是插件"></a>什么是插件</h2><p>在 Flutter 中，一个插件叫做一个 package，使用 package 的目的就是为了达到模块化，可以创建出可被复用的共享的代码。这和大多数编程语言中的模块、包的概念相同，创建出来的 package 可以在 pubspec.yaml 中直接依赖。</p><p>一个最小化的 package 包含了两部分：</p><ol><li>一个 pubspec.yaml：一个元数据文件，声明了 package 的名称、版本、作者信息等。</li><li>一个 lib 文件夹：包含 package 的公开代码，文件至少要存在 <package-name>.dart 这个文件。（<pakcage-name>.dart 这个文件必须存在，因为这是方便使用的人快速 import 这个 package 来使用它，可以把它理解成一种必须要遵守的规则。）</li></ol><h2 id="package-的种类"><a href="#package-的种类" class="headerlink" title="package 的种类"></a>package 的种类</h2><p>package 可以分为两种：<code>纯 dart 代码</code> 的和 <code>带有特定平台代码</code> 的 package。</p><ol><li>Dart package：这是一个只有 dart 代码的 package，里面包含了 Flutter 的特定功能，所以它依赖于 Flutter 的 Framework，也决定了它只能用在 Flutter 上。</li><li>plugin package：这是一个既包含了 dart 代码编写的 API，又包含了平台特定实现的 package，可以被 Android 和 iOS 调用。</li></ol><h2 id="开发步骤"><a href="#开发步骤" class="headerlink" title="开发步骤"></a>开发步骤</h2><h3 id="开发-Dart-package"><a href="#开发-Dart-package" class="headerlink" title="开发 Dart package"></a>开发 Dart package</h3><p>创建 Dart 包，需使用 <code>--template=package</code> 来执行 <code>flutter create</code></p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">flutter create --template=package hello</span><br></pre></td></tr></table></figure><p>这将在 hello 文件夹下创建一个具有以下专用内容的 package 工程：</p><ul><li><code>lib/hello.dart:</code><ul><li>Package 的 Dart 代码</li></ul></li><li><code>test/hello_test.dart:</code><ul><li>Package 的单元测试代码.</li></ul></li><li>实现 package<ul><li>对于纯 Dart 包，只需在主 lib&#x2F;<package name>.dart 文件内或 lib 目录中的文件中添加功能 。</li><li>要测试软件包，请在 test 目录中添加 unit tests。</li></ul></li></ul><h3 id="开发-plugin-package"><a href="#开发-plugin-package" class="headerlink" title="开发 plugin package"></a>开发 plugin package</h3><h4 id="Step-1-创建-package"><a href="#Step-1-创建-package" class="headerlink" title="Step 1: 创建 package"></a>Step 1: 创建 package</h4><ul><li><p>要创建插件包，请使用 <code>--template=plugin</code> 参数执行 <code>flutter create</code></p></li><li><p>使用 <code>--org</code> 选项指定您的组织，并使用反向域名表示法。该值用于生成的 Android 和 iOS 代码中的各种包和包标识符。</p></li></ul><p><code>flutter create --org com.example --template=plugin hello</code></p><ul><li><p>这将在 hello&#x2F; 文件夹下创建一个具有以下专用内容的插件工程：</p></li><li><p>lib&#x2F;hello.dart:</p><ul><li>插件包的 Dart API.</li></ul></li><li><p>android&#x2F;src&#x2F;main&#x2F;java&#x2F;com&#x2F;yourcompany&#x2F;​hello&#x2F;HelloPlugin.java:</p><ul><li>插件包 API 的 Android 实现.</li></ul></li><li><p>ios&#x2F;Classes&#x2F;HelloPlugin.m:</p><ul><li>插件包 API 的 ios 实现.</li></ul></li><li><p>example&#x2F;:</p><ul><li>一个依赖于该插件的 Flutter 应用程序，来说明如何使用它。默认情况下，插件项目针对 iOS 代码使用 Objective-C，Android 代码使用 Java。如果您更喜欢 Swift 或 Kotlin，则可以使用 -i 或 -a 为 iOS 或 Android 指定语言。例如：</li></ul></li></ul><p><code>flutter create --template=plugin -i swift -a kotlin hello</code></p><h4 id="Step-2-实现包-package"><a href="#Step-2-实现包-package" class="headerlink" title="Step 2: 实现包 package"></a>Step 2: 实现包 package</h4><ul><li><p>由于插件包中包含用多种编程语言编写的多个平台的代码，因此需要一些特定的步骤来确保顺畅的体验。</p></li><li><p>Step 2a: 定义包 API（.dart）插件包的 API 在 Dart 代码中定义。打开主文件夹hello&#x2F; 。找到lib&#x2F;hello.dart。</p></li><li><p>Step 2b: 添加 Android 平台代码（.java &#x2F; .kt）我们建议您使用 Android Studio 编辑 Android 代码。</p></li></ul><p>在 Android Studio 中编辑 Android 平台代码之前，首先确保代码至少已经构建过一次（例如，从 IntelliJ 运行示例应用程序或在终端执行 cd hello&#x2F;example; flutter build apk）。</p><ol><li>启动 Android Studio</li><li>在 ’Welcome to Android Studio’ 对话框选择 ‘Import project’, 或者在菜单栏 ‘File &gt; New &gt; Import Project…‘，然后选择 hello&#x2F;example&#x2F;android&#x2F;build.gradle 文件.</li><li>在 ’Gradle Sync’ 对话框, 选择 ‘OK’.</li><li>在 ’Android Gradle Plugin Update’ 对话框, 选择 ‘Don’t remind me again for this project’.<br>您插件的 Android 平台代码位于 hello&#x2F;java&#x2F;com.yourcompany.hello&#x2F;​HelloPlugin.</li></ol><p>您可以通过按下 ▶ 按钮从 Android Studio 运行示例应用程序.</p><ul><li>Step 2d: 连接 API 和平台代码<br>最后，您需要将用 Dart 代码编写的 API 与平台特定的实现连接起来。这是通过 platform channels 完成的。</li></ul><h4 id="添加文档"><a href="#添加文档" class="headerlink" title="添加文档"></a>添加文档</h4><p>建议将以下文档添加到所有软件包：</p><ol><li>README.md：介绍包的文件</li><li>CHANGELOG.md：记录每个版本中的更改</li><li>LICENSE：包含软件包许可条款的文件</li></ol><h3 id="发布-packages"><a href="#发布-packages" class="headerlink" title="发布 packages"></a>发布 packages</h3><p>一旦你实现了一个包，你可以在 Pub 上发布它 ，这样其他开发人员就可以轻松使用它</p><p>在发布之前，检查 <code>pubspec.yaml</code>、<code>README.md</code> 以及 <code>CHANGELOG.md</code>  文件，以确保其内容的完整性和正确性。</p><p>然后, 运行 dry-run 命令以查看是否都准备 OK 了:</p><p><code>flutter packages pub publish --dry-run</code></p><p>最后, 运行发布命令:</p><p><code>flutter packages pub publish</code></p><h2 id="Plugin-通信原理"><a href="#Plugin-通信原理" class="headerlink" title="Plugin 通信原理"></a>Plugin 通信原理</h2><ul><li>在介绍 Plugin 前，我们先简单了解一下 Flutter：</li></ul><p><img src="https://personal-blog.oss-cn-hangzhou.aliyuncs.com/flutter_design.png"> </p><ul><li>Flutter 框架包括：Framework 和 Engine，他们运行在各自的 Platform 上。</li><li>Framework 是 Dart 语言开发的，包括 Material Design 风格的 Widgets 和 Cupertino(iOS-style) 风格的 Widgets，以及文本、图片、按钮等基础 Widgets；还包括渲染、动画、绘制、手势等基础能力。</li><li>Engine 是 C++ 实现的，包括 Skia（二维图形库）；Dart VM（Dart Runtime）；Text（文本渲染）等。<blockquote><p>实际上，Flutter 的上层能力都是 Engine 提供的。Flutter 正是通过 Engine 将各个 Platform 的差异化抹平。而我们今天要讲的 Plugin，正是通过 Engine 提供的 Platform Channel 实现的通信。</p></blockquote></li><li>Plugin 其实就是一个特殊的 Package。Flutter Plugin 提供 Android 或者 iOS 的底层封装，在 Flutter 层提供组件功能，使 Flutter 可以较方便的调取 Native 的模块。很多平台相关性或者对于 Flutter 实现起来比较复杂的部分，都可以封装成 Plugin。其原理如下</li></ul><p><img src="https://personal-blog.oss-cn-hangzhou.aliyuncs.com/flutter_channel.png"> </p><p>通过上图，我们看到 Flutter App 是通过 Plugin 创建的 Platform Channel 调用的 Native APIs。</p><h4 id="Platform-Channel："><a href="#Platform-Channel：" class="headerlink" title="Platform Channel："></a>Platform Channel：</h4><ol><li>Flutter App (Client)，通过 MethodChannel 类向 Platform 发送调用消息；</li><li>Android Platform (Host)，通过 MethodChannel 类接收调用消息；</li><li>iOS Platform (Host)，通过 FlutterMethodChannel 类接收调用消息。</li></ol><blockquote><p>PS：消息编解码器，是 JSON 格式的二进制序列化，所以调用方法的参数类型必须是可 JSON 序列化的。<br>PS：方法调用，也可以反向发送调用消息。</p></blockquote><ul><li>Android Platform<blockquote><p>FlutterActivity，是 Android 的 Plugin 管理器，它记录了所有的 Plugin，并将 Plugin 绑定到 FlutterView。</p></blockquote></li></ul><ol><li>理解 Platform Channel 工作原理</li></ol><ul><li><p>Flutter 定义了三种不同类型的 Channel，它们分别是</p><ul><li>BasicMessageChannel：用于传递字符串和半结构化的信息。</li><li>MethodChannel：用于传递方法调用（method invocation）。</li><li>EventChannel: 用于数据流（event streams）的通信。</li></ul></li></ul><p>三种 Channel 之间互相独立，各有用途，但它们在设计上却非常相近。每种 Channel 均有三个重要成员变量：</p><ul><li>name:  String 类型，代表 Channel 的名字，也是其唯一标识符。</li><li>messager：BinaryMessenger 类型，代表消息信使，是消息的发送与接收的工具。</li><li>codec: MessageCodec 类型或 MethodCodec 类型，代表消息的编解码器。</li><li>Channel name： 一个 Flutter 应用中可能存在多个 Channel，每个 Channel 在创建时必须指定一个独一无二的 name，Channel 之间使用 name 来区分彼此。当有消息从 Flutter 端发送到 Platform 端时，会根据其传递过来的 channel name 找到该 Channel 对应的 Handler（消息处理器）。</li><li>消息信使：BinaryMessenger</li><li>平台通道数据类型支持和解码器</li><li>标准平台通道使用标准消息编解码器，以支持简单的类似 JSON 值的高效二进制序列化，例如 booleans、numbers,、Strings,、byte buffers,、List,、Maps（请参阅StandardMessageCodec 了解详细信息）。 当您发送和接收值时，这些值在消息中的序列化和反序列化会自动进行。</li></ul><p>下表显示了如何在宿主上接收 Dart 值，反之亦然：</p><table><thead><tr><th>Dart</th><th>Android</th><th>iOS</th></tr></thead><tbody><tr><td>null</td><td>null</td><td>nil (NSNull when nested)</td></tr><tr><td>bool</td><td>java.lang.Boolean</td><td>NSNumber numberWithBool:</td></tr><tr><td>int</td><td>java.lang.Integer</td><td>NSNumber numberWithInt:</td></tr><tr><td>int, if 32 bits not enough</td><td>java.lang.Long</td><td>NSNumber numberWithLong:</td></tr><tr><td>int, if 64 bits not enough</td><td>java.math.BigInteger</td><td>FlutterStandardBigInteger</td></tr><tr><td>double</td><td>java.lang.Double</td><td>NSNumber numberWithDouble:</td></tr><tr><td>Stringj</td><td>ava.lang.String</td><td>NSString</td></tr><tr><td>Uint8List</td><td>byte[]</td><td>FlutterStandardTypedData typedDataWithBytes:</td></tr><tr><td>Int32List</td><td>int[]</td><td>FlutterStandardTypedData typedDataWithInt32:</td></tr><tr><td>Int64List</td><td>long[]</td><td>FlutterStandardTypedData typedDataWithInt64:</td></tr><tr><td>Float64List</td><td>double[]</td><td>FlutterStandardTypedData typedDataWithFloat64:</td></tr><tr><td>List</td><td>java.util.ArrayList</td><td>NSArray</td></tr><tr><td>Map</td><td>java.util.HashMap</td><td>NSDictionary</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> Flutter </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Dart </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>路由与导航</title>
      <link href="/2021/12/15/Flutter/%E8%B7%AF%E7%94%B1%E4%B8%8E%E5%AF%BC%E8%88%AA/"/>
      <url>/2021/12/15/Flutter/%E8%B7%AF%E7%94%B1%E4%B8%8E%E5%AF%BC%E8%88%AA/</url>
      
        <content type="html"><![CDATA[<p>路由（Route）在移动开发中通常指页面（Page）。所谓的路由管理，即使管理页面之间如何跳转，通常也可被称为 <strong>导航管理</strong>。<strong>导航管理</strong> 通常都会维护一个路由栈，路由 <code>入栈（push）</code>操作对应打开一个新页面，路由 <code>出栈（pop）</code>操作对应页面关闭操作，而 <strong>路由管理</strong> 主要是指如何来管理路由栈。</p><h2 id="命名路由"><a href="#命名路由" class="headerlink" title="命名路由"></a>命名路由</h2><p>命名路由（Named Route）：即给路由起一个名字，然后可以通过路由名字直接打开新的路由，这为路由管理带来了一种直观、简单的方式。</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&#x27;package:flutter/material.dart&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> main() =&gt; runApp(MyApp());</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyApp</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> MaterialApp(</span><br><span class="line">      title: <span class="string">&#x27;Flutter Demo&#x27;</span>,</span><br><span class="line">      <span class="comment">// home: MainRoute(),</span></span><br><span class="line">      <span class="comment">// 注册路由表</span></span><br><span class="line">      routes: &#123;</span><br><span class="line">          <span class="comment">/// <span class="language-markdown">&#x27;/&#x27;是特殊地址，第一个页面</span></span></span><br><span class="line">        <span class="string">&quot;/&quot;</span> :(context) =&gt; MainRoute(),</span><br><span class="line">        <span class="string">&quot;new_page&quot;</span>: (context) =&gt; SecondRoute(),</span><br><span class="line">      &#125;,</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MainRoute</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> Scaffold(</span><br><span class="line">      appBar: AppBar(</span><br><span class="line">        title: Text(<span class="string">&quot;主页&quot;</span>),</span><br><span class="line">      ),</span><br><span class="line">      body: Column(</span><br><span class="line">        children: &lt;Widget&gt;[</span><br><span class="line">          Text(<span class="string">&quot;第一个页面&quot;</span>),</span><br><span class="line">          RaisedButton(</span><br><span class="line">            onPressed: () <span class="keyword">async</span> &#123;</span><br><span class="line">              <span class="comment">// 导航到新路由</span></span><br><span class="line">              <span class="keyword">var</span> result = <span class="keyword">await</span> Navigator.pushNamed(context, <span class="string">&quot;new_page&quot;</span>);</span><br><span class="line">              debugPrint(<span class="string">&quot;返回:<span class="subst">$result</span>&quot;</span>);</span><br><span class="line">            &#125;,</span><br><span class="line">            child: Text(<span class="string">&quot;进入第二页&quot;</span>),</span><br><span class="line">          )</span><br><span class="line">        ],</span><br><span class="line">      ),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SecondRoute</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> Scaffold(</span><br><span class="line">      appBar: AppBar(</span><br><span class="line">        title: Text(<span class="string">&quot;第二页&quot;</span>),</span><br><span class="line">      ),</span><br><span class="line">      body: Column(</span><br><span class="line">        children: &lt;Widget&gt;[</span><br><span class="line">          Text(<span class="string">&quot;第一个页面&quot;</span>),</span><br><span class="line">          RaisedButton(</span><br><span class="line">            onPressed: () &#123;</span><br><span class="line">              <span class="comment">// 路由 pop 弹出</span></span><br><span class="line">              Navigator.pop(context, <span class="string">&quot;结束&quot;</span>);</span><br><span class="line">            &#125;,</span><br><span class="line">            child: Text(<span class="string">&quot;返回&quot;</span>),</span><br><span class="line">          )</span><br><span class="line">        ],</span><br><span class="line">      ),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>优点：</p><ol><li>直观；</li></ol><p>缺点：</p><p>1.不能直接传递路由参数；</p><p>假设 SecondRoute，需要接受一个字符串参数 <code>tip</code>，然后再在屏幕中心将 <code>tip</code> 的内容显示出来。因为命名路由需要提前注册到路由表中，所以就无法动态修改 <code>tip</code> 参数。</p><h2 id="自定义路由切换动画"><a href="#自定义路由切换动画" class="headerlink" title="自定义路由切换动画"></a>自定义路由切换动画</h2><p> Material 库中提供了 MaterialPageRoute，它在 Android 上会上下滑动切换。如果想自定义路由切换动画，可以使用 PageRouteBuilder。</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&#x27;package:flutter/material.dart&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> main() =&gt; runApp(MyApp());</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyApp</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> MaterialApp(</span><br><span class="line">      title: <span class="string">&#x27;Flutter Demo&#x27;</span>,</span><br><span class="line">      home: MainRoute(),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MainRoute</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> Scaffold(</span><br><span class="line">      appBar: AppBar(</span><br><span class="line">        title: Text(<span class="string">&quot;主页&quot;</span>),</span><br><span class="line">      ),</span><br><span class="line">      body: Column(</span><br><span class="line">        children: &lt;Widget&gt;[</span><br><span class="line">          Text(<span class="string">&quot;第一个页面&quot;</span>),</span><br><span class="line">          RaisedButton(</span><br><span class="line">            onPressed: () <span class="keyword">async</span> &#123;</span><br><span class="line">              <span class="comment">// 导航到新路由</span></span><br><span class="line">              <span class="keyword">var</span> result = <span class="keyword">await</span> Navigator.push(</span><br><span class="line">                context,</span><br><span class="line">                PageRouteBuilder(</span><br><span class="line">                  <span class="comment">/// <span class="language-markdown">动画时间</span></span></span><br><span class="line">                  transitionDuration: <span class="built_in">Duration</span>(milliseconds: <span class="number">500</span>),</span><br><span class="line">                  pageBuilder: (BuildContext context, Animation animation,</span><br><span class="line">                      Animation secondaryAnimation) &#123;</span><br><span class="line">                    <span class="comment">// 平移</span></span><br><span class="line">                    <span class="keyword">return</span> SlideTransition(</span><br><span class="line">                      <span class="comment">// Tween: 在补间动画中，定义开始点结束点</span></span><br><span class="line">                      position: <span class="keyword">new</span> Tween&lt;Offset&gt;(</span><br><span class="line">                        begin: <span class="keyword">const</span> Offset(<span class="number">1.0</span>, <span class="number">0.0</span>),</span><br><span class="line">                        end: <span class="keyword">const</span> Offset(<span class="number">0.0</span>, <span class="number">0.0</span>),</span><br><span class="line">                      ).animate(animation),</span><br><span class="line">                      child: SecondRoute(),</span><br><span class="line">                    );</span><br><span class="line">                  &#125;,</span><br><span class="line">                ),</span><br><span class="line">              );</span><br><span class="line">              debugPrint(<span class="string">&quot;返回:<span class="subst">$result</span>&quot;</span>);</span><br><span class="line">            &#125;,</span><br><span class="line">            child: Text(<span class="string">&quot;进入第二页&quot;</span>),</span><br><span class="line">          )</span><br><span class="line">        ],</span><br><span class="line">      ),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SecondRoute</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> Scaffold(</span><br><span class="line">      appBar: AppBar(</span><br><span class="line">        title: Text(<span class="string">&quot;第二页&quot;</span>),</span><br><span class="line">      ),</span><br><span class="line">      body: Column(</span><br><span class="line">        children: &lt;Widget&gt;[</span><br><span class="line">          Text(<span class="string">&quot;第一个页面&quot;</span>),</span><br><span class="line">          RaisedButton(</span><br><span class="line">            onPressed: () &#123;</span><br><span class="line">              <span class="comment">// 路由 pop 弹出</span></span><br><span class="line">              Navigator.pop(context, <span class="string">&quot;结束&quot;</span>);</span><br><span class="line">            &#125;,</span><br><span class="line">            child: Text(<span class="string">&quot;返回&quot;</span>),</span><br><span class="line">          )</span><br><span class="line">        ],</span><br><span class="line">      ),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同时我们也可以对动画进行组合</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&#x27;package:flutter/material.dart&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> main() =&gt; runApp(MyApp());</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyApp</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> MaterialApp(</span><br><span class="line">      title: <span class="string">&#x27;Flutter Demo&#x27;</span>,</span><br><span class="line">      home: MainRoute(),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MainRoute</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> Scaffold(</span><br><span class="line">      appBar: AppBar(</span><br><span class="line">        title: Text(<span class="string">&quot;主页&quot;</span>),</span><br><span class="line">      ),</span><br><span class="line">      body: Column(</span><br><span class="line">        children: &lt;Widget&gt;[</span><br><span class="line">          Text(<span class="string">&quot;第一个页面&quot;</span>),</span><br><span class="line">          RaisedButton(</span><br><span class="line">            onPressed: () <span class="keyword">async</span> &#123;</span><br><span class="line">              <span class="comment">// 导航到新路由</span></span><br><span class="line">              <span class="keyword">var</span> result = <span class="keyword">await</span> Navigator.push(</span><br><span class="line">                context,</span><br><span class="line">                PageRouteBuilder(</span><br><span class="line">                  <span class="comment">// 动画时间</span></span><br><span class="line">                    transitionDuration: <span class="built_in">Duration</span>(milliseconds: <span class="number">500</span>),</span><br><span class="line">                    pageBuilder: (BuildContext context, Animation animation,</span><br><span class="line">                        Animation secondaryAnimation) &#123;</span><br><span class="line">                      <span class="comment">// 透明渐变与旋转</span></span><br><span class="line">                      <span class="keyword">return</span> <span class="keyword">new</span> FadeTransition(</span><br><span class="line">                        opacity: animation,</span><br><span class="line">                        child: <span class="keyword">new</span> RotationTransition(</span><br><span class="line">                          turns: <span class="keyword">new</span> Tween&lt;<span class="built_in">double</span>&gt;(begin: <span class="number">0.5</span>, end: <span class="number">1.0</span>)</span><br><span class="line">                              .animate(animation),</span><br><span class="line">                          child: SecondRoute(),</span><br><span class="line">                        ),</span><br><span class="line">                      );</span><br><span class="line">                    &#125;,),</span><br><span class="line">              );</span><br><span class="line">              debugPrint(<span class="string">&quot;返回:<span class="subst">$result</span>&quot;</span>);</span><br><span class="line">            &#125;,</span><br><span class="line">            child: Text(<span class="string">&quot;进入第二页&quot;</span>),</span><br><span class="line">          )</span><br><span class="line">        ],</span><br><span class="line">      ),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SecondRoute</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> Scaffold(</span><br><span class="line">      appBar: AppBar(</span><br><span class="line">        title: Text(<span class="string">&quot;第二页&quot;</span>),</span><br><span class="line">      ),</span><br><span class="line">      body: Column(</span><br><span class="line">        children: &lt;Widget&gt;[</span><br><span class="line">          Text(<span class="string">&quot;第一个页面&quot;</span>),</span><br><span class="line">          RaisedButton(</span><br><span class="line">            onPressed: () &#123;</span><br><span class="line">              <span class="comment">// 路由 pop 弹出</span></span><br><span class="line">              Navigator.pop(context, <span class="string">&quot;结束&quot;</span>);</span><br><span class="line">            &#125;,</span><br><span class="line">            child: Text(<span class="string">&quot;返回&quot;</span>),</span><br><span class="line">          )</span><br><span class="line">        ],</span><br><span class="line">      ),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="路由关键点"><a href="#路由关键点" class="headerlink" title="路由关键点"></a>路由关键点</h2><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&#x27;package:flutter/material.dart&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> main() =&gt; runApp(MyApp());</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyApp</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> MaterialApp(</span><br><span class="line">      title: <span class="string">&#x27;Flutter Demo&#x27;</span>,</span><br><span class="line">      home: Scaffold(</span><br><span class="line">        appBar: AppBar(</span><br><span class="line">          title: Text(<span class="string">&quot;主页&quot;</span>),</span><br><span class="line">        ),</span><br><span class="line">        body: Column(</span><br><span class="line">          children: &lt;Widget&gt;[</span><br><span class="line">            Text(<span class="string">&quot;第一个页面&quot;</span>),</span><br><span class="line">            RaisedButton(</span><br><span class="line">              onPressed: ()  &#123;</span><br><span class="line">                  <span class="comment">// Navigator.push 内部其实就是 Navigator.of(context).push</span></span><br><span class="line">                  Navigator.of(context).push(MaterialPageRoute(builder: (_)&#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">new</span> SecondRoute();</span><br><span class="line">                  &#125;));</span><br><span class="line">              &#125;,</span><br><span class="line">              child: Text(<span class="string">&quot;进入第二页&quot;</span>),</span><br><span class="line">            )</span><br><span class="line">          ],</span><br><span class="line">        ),</span><br><span class="line">      ),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SecondRoute</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> Scaffold(</span><br><span class="line">      appBar: AppBar(</span><br><span class="line">        title: Text(<span class="string">&quot;第二页&quot;</span>),</span><br><span class="line">      ),</span><br><span class="line">      body: Column(</span><br><span class="line">        children: &lt;Widget&gt;[</span><br><span class="line">          Text(<span class="string">&quot;第一个页面&quot;</span>),</span><br><span class="line">          RaisedButton(</span><br><span class="line">            onPressed: () &#123;</span><br><span class="line">              <span class="comment">// 路由 pop 弹出</span></span><br><span class="line">              Navigator.pop(context);</span><br><span class="line">            &#125;,</span><br><span class="line">            child: Text(<span class="string">&quot;返回&quot;</span>),</span><br><span class="line">          )</span><br><span class="line">        ],</span><br><span class="line">      ),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码运行会出现错误：<img src="https://personal-blog.oss-cn-hangzhou.aliyuncs.com/flutter_route_error.png" alt="路由异常"></p><p><code>Navigator</code> 实际上也是一个 Widget，这个异常出现在 <code>Navigator.of(context)</code> 路由器的获取上，而这句代码会 **从当前的 context 的父级一层层向上去查找一个<code>Navigator</code>**，我们当前传递的 context 就是 MyApp，它的父级是 root —— UI 根节点。<code>Navigator</code> 这个 widget 的并不是由 root 创建的，因此在 root 下一级的上下文中无法获得 <code>Navigator</code>。</p><blockquote><p>在之前所有的路由案例中，我们的上下文是 MainRoute，它的父级是 MaterialApp。MaterialApp 内部就会创建一个 Navigator。</p><p>MaterialApp -&gt; _MaterialAppState -&gt; WidgetsApp -&gt; _WidgetsAppState</p><p><img src="https://personal-blog.oss-cn-hangzhou.aliyuncs.com/flutter_navigator_create.png" alt="Navigator 的创建"></p></blockquote><p>所以问题就在于，<code>Navigator</code> 需要通过 MaterialApp 或者它孩子的上下文。</p><h3 id="解决方案一"><a href="#解决方案一" class="headerlink" title="解决方案一"></a>解决方案一</h3><p>按照此笔记最开始的正常路由演示案例来进行修改。</p><h3 id="解决方案二"><a href="#解决方案二" class="headerlink" title="解决方案二"></a>解决方案二</h3><p>使用 <code>Builder</code></p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&#x27;package:flutter/material.dart&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> main() =&gt; runApp(MyApp());</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyApp</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> MaterialApp(</span><br><span class="line">      title: <span class="string">&#x27;Flutter Demo&#x27;</span>,</span><br><span class="line">      home: Scaffold(</span><br><span class="line">        appBar: AppBar(</span><br><span class="line">          title: Text(<span class="string">&quot;主页&quot;</span>),</span><br><span class="line">        ),</span><br><span class="line">        body: Column(</span><br><span class="line">          children: &lt;Widget&gt;[</span><br><span class="line">            Text(<span class="string">&quot;第一个页面&quot;</span>),</span><br><span class="line">            Builder(builder: (context)&#123;</span><br><span class="line">              <span class="keyword">return</span> RaisedButton(</span><br><span class="line">                onPressed: ()  &#123;</span><br><span class="line">                  Navigator.of(context).push(MaterialPageRoute(builder: (_)&#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">new</span> SecondRoute();</span><br><span class="line">                  &#125;));</span><br><span class="line">                &#125;,</span><br><span class="line">                child: Text(<span class="string">&quot;进入第二页&quot;</span>),</span><br><span class="line">              );</span><br><span class="line">            &#125;)</span><br><span class="line">          ],</span><br><span class="line">        ),</span><br><span class="line">      ),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SecondRoute</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> Scaffold(</span><br><span class="line">      appBar: AppBar(</span><br><span class="line">        title: Text(<span class="string">&quot;第二页&quot;</span>),</span><br><span class="line">      ),</span><br><span class="line">      body: Column(</span><br><span class="line">        children: &lt;Widget&gt;[</span><br><span class="line">          Text(<span class="string">&quot;第一个页面&quot;</span>),</span><br><span class="line">          RaisedButton(</span><br><span class="line">            onPressed: () &#123;</span><br><span class="line">              <span class="comment">// 路由 pop 弹出</span></span><br><span class="line">              Navigator.pop(context);</span><br><span class="line">            &#125;,</span><br><span class="line">            child: Text(<span class="string">&quot;返回&quot;</span>),</span><br><span class="line">          )</span><br><span class="line">        ],</span><br><span class="line">      ),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用 Builder 嵌套，Builder 的参数可以看成一个回调，接收自身的 context 并返回布局配置。现在路由是从 Builder 的父亲开始查找啦，自然能找到 Navigator。</p><p><img src="https://personal-blog.oss-cn-hangzhou.aliyuncs.com/flutter_route_builder.png" alt="Builder 源码"></p><h3 id="解决方案三"><a href="#解决方案三" class="headerlink" title="解决方案三"></a>解决方案三</h3><p>使用 <code>navigatorKey</code></p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&#x27;package:flutter/material.dart&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> main() =&gt; runApp(MyApp());</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyApp</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span><br><span class="line">  <span class="keyword">final</span> GlobalKey&lt;NavigatorState&gt; navigatorKey = GlobalKey();</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> MaterialApp(</span><br><span class="line">        <span class="comment">// 指定路由器 widget的key</span></span><br><span class="line">      navigatorKey: navigatorKey,</span><br><span class="line">      title: <span class="string">&#x27;Flutter Demo&#x27;</span>,</span><br><span class="line">      home: Scaffold(</span><br><span class="line">        appBar: AppBar(</span><br><span class="line">          title: Text(<span class="string">&quot;主页&quot;</span>),</span><br><span class="line">        ),</span><br><span class="line">        body: Column(</span><br><span class="line">          children: &lt;Widget&gt;[</span><br><span class="line">            Text(<span class="string">&quot;第一个页面&quot;</span>),</span><br><span class="line">            RaisedButton(</span><br><span class="line">              onPressed: ()  &#123;</span><br><span class="line">                <span class="comment">// 输出Navigator</span></span><br><span class="line">                debugPrint(navigatorKey.currentWidget.runtimeType.toString());</span><br><span class="line">                navigatorKey.currentState.push(MaterialPageRoute(builder: (_)&#123;</span><br><span class="line">                  <span class="keyword">return</span> <span class="keyword">new</span> SecondRoute();</span><br><span class="line">                &#125;));</span><br><span class="line">              &#125;,</span><br><span class="line">              child: Text(<span class="string">&quot;进入第二页&quot;</span>),</span><br><span class="line">            )</span><br><span class="line">          ],</span><br><span class="line">        ),</span><br><span class="line">      ),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SecondRoute</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> Scaffold(</span><br><span class="line">      appBar: AppBar(</span><br><span class="line">        title: Text(<span class="string">&quot;第二页&quot;</span>),</span><br><span class="line">      ),</span><br><span class="line">      body: Column(</span><br><span class="line">        children: &lt;Widget&gt;[</span><br><span class="line">          Text(<span class="string">&quot;第一个页面&quot;</span>),</span><br><span class="line">          RaisedButton(</span><br><span class="line">            onPressed: () &#123;</span><br><span class="line">              <span class="comment">// 路由 pop 弹出</span></span><br><span class="line">              Navigator.pop(context);</span><br><span class="line">            &#125;,</span><br><span class="line">            child: Text(<span class="string">&quot;返回&quot;</span>),</span><br><span class="line">          )</span><br><span class="line">        ],</span><br><span class="line">      ),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://personal-blog.oss-cn-hangzhou.aliyuncs.com/flutter_navigator_create.png" alt="Navigator 的创建"></p><p>在创建 <code>Navigator</code> 的时候，会给一个 <strong>key</strong>，这个 <strong>key</strong> 可以看成一个 Widget的 id。这里的 <strong>_navigator</strong> 就是我们指定的 <strong>navigatorKey</strong> (如果我们没指定，会给默认值的，所以不要疑惑不指定是不是就不创建 <code>Navigator</code> 了）。而通过这个 key，就能够获得这个 <code>Navigator</code>。直接获得了路由自然不需要再去查找了！</p>]]></content>
      
      
      <categories>
          
          <category> Flutter </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Dart </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Dart 类与异步</title>
      <link href="/2021/11/02/Flutter/Dart%20%E7%B1%BB%E4%B8%8E%E5%BC%82%E6%AD%A5/"/>
      <url>/2021/11/02/Flutter/Dart%20%E7%B1%BB%E4%B8%8E%E5%BC%82%E6%AD%A5/</url>
      
        <content type="html"><![CDATA[<p>Dart 是一个面向对象编程语言，每个对象都是一个类的实例，所有的类都继承于 Object。</p><h2 id="类"><a href="#类" class="headerlink" title="类"></a>类</h2><h3 id="命名规则"><a href="#命名规则" class="headerlink" title="命名规则"></a>命名规则</h3><blockquote><p>使用 <code>lowercase_with_underscores</code> 风格来命名库和文件名名字</p><p>使用 <code>UpperCamelCase</code> 风格来命名类型名称</p><p>使用 <code>lowerCamelCase</code> 风格来命名其他的标识符</p><p>推荐使用 <code>lowerCamelCase</code> 来命名常量</p></blockquote><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 每个实例变量都会自动生成一个 getter 方法，非 final 实例变量还会自动生成一个 setter 方法。</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line"><span class="built_in">num</span> x;</span><br><span class="line"><span class="built_in">num</span> _y; <span class="comment">// 使用 _ 开头的表示私有变量，外部无法访问</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h3><p>由于把构造函数参数赋值给实例变量的场景太常见了，Dart 提供了一个语法糖来简化这个操作：</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line"><span class="built_in">num</span> x;</span><br><span class="line"><span class="built_in">num</span> y;</span><br><span class="line"></span><br><span class="line">Point(<span class="keyword">this</span>.x, <span class="keyword">this</span>.y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="命名构造函数"><a href="#命名构造函数" class="headerlink" title="命名构造函数"></a>命名构造函数</h3><p> Dart 并不支持函数的重载，而采用了命名构造函数为一个类实现多个构造函数：</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line"><span class="built_in">num</span> x;</span><br><span class="line"><span class="built_in">num</span> y;</span><br><span class="line"></span><br><span class="line">Point(<span class="keyword">this</span>.x, <span class="keyword">this</span>.y);</span><br><span class="line"></span><br><span class="line">Point.Cool(<span class="keyword">this</span>.y); <span class="comment">// 命名构造方法，命名更加直观的表示这个构造方法的作用与特性</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="常量构造方法"><a href="#常量构造方法" class="headerlink" title="常量构造方法"></a>常量构造方法</h3><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ImmutabelPoint</span></span>&#123;</span><br><span class="line">  <span class="keyword">final</span> <span class="built_in">int</span> x;</span><br><span class="line">  <span class="keyword">final</span> <span class="built_in">int</span> y;</span><br><span class="line">  <span class="comment">// 常量构造方法</span></span><br><span class="line">  <span class="keyword">const</span> ImmutabelPoint(<span class="keyword">this</span>.x,<span class="keyword">this</span>.y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用  new 来创建常量构造方法的对象就和普通的对象没有区别</span></span><br><span class="line"><span class="comment">// 使用 const 来创建多个对象，传递参数一样表示这几个对象是同一个编译期常量对象（必须定义常量构造函数）</span></span><br><span class="line"><span class="keyword">var</span> p1 = <span class="keyword">const</span> ImmutabelPoint(<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line"><span class="keyword">var</span> p2 = <span class="keyword">const</span> ImmutabelPoint(<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line"><span class="built_in">print</span>(p1.hashCode == p2.hashCode);</span><br><span class="line"><span class="built_in">print</span>(p1 == p2);</span><br></pre></td></tr></table></figure><h3 id="工厂构造方法"><a href="#工厂构造方法" class="headerlink" title="工厂构造方法"></a>工厂构造方法</h3><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Manager</span></span>&#123;</span><br><span class="line">  <span class="built_in">int</span> i;</span><br><span class="line">  <span class="keyword">static</span> Manager _instance;</span><br><span class="line">  <span class="comment">// 工厂构造方法 必须返回一个实例对象</span></span><br><span class="line">  <span class="keyword">factory</span> Manager.getInstance()&#123;</span><br><span class="line">    <span class="keyword">if</span> (_instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">      _instance = <span class="keyword">new</span> Manager._newInstance();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> _instance;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 私有的 private 的</span></span><br><span class="line">  Manager._newInstance();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> Manager.getInstance();</span><br></pre></td></tr></table></figure><h3 id="运算符重载"><a href="#运算符重载" class="headerlink" title="运算符重载"></a>运算符重载</h3><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span></span>&#123;</span><br><span class="line">  <span class="comment">// 每一个实例属性变量都会有一个隐式的 get，非 final 还有 set</span></span><br><span class="line">  <span class="built_in">int</span> _x;</span><br><span class="line">  <span class="built_in">int</span> _y;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//x 是方法名</span></span><br><span class="line">  <span class="built_in">int</span> <span class="keyword">get</span> x =&gt; _x;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">set</span> x(<span class="built_in">int</span> x) =&gt; _x = x;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 运算符重载， 定义 + 操作的行为</span></span><br><span class="line">  Point <span class="keyword">operator</span> +(Point othre)&#123;</span><br><span class="line">    <span class="keyword">var</span> point = <span class="keyword">new</span> Point();</span><br><span class="line">    point._x = _x + othre.x;</span><br><span class="line">    <span class="keyword">return</span> point;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">String</span> <span class="keyword">operator</span> -(<span class="built_in">int</span> x)&#123;</span><br><span class="line">   <span class="keyword">return</span> <span class="string">&quot;hahahaha&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="混合"><a href="#混合" class="headerlink" title="混合"></a>混合</h3><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 被 mixin (混入) 的类不能有构造函数</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>  </span>&#123;</span><br><span class="line">  <span class="keyword">void</span> a()&#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;A  的 a 方法!&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span></span>&#123;</span><br><span class="line">  <span class="keyword">void</span> b()&#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;b 方法&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">void</span> a()&#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;B 的 a 方法!&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 满足了我们的多继承的需求</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span> <span class="title">with</span> <span class="title">B</span>, <span class="title">A</span></span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">void</span> c()&#123;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 重写了混入类的 a 方法</span></span><br><span class="line">  <span class="keyword">void</span> a()&#123;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// C 就是 A、B 的混合类</span></span><br><span class="line"><span class="comment">// class C = Object with A, B;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> main()&#123;</span><br><span class="line">  <span class="comment">// 1、自身是第一优先级</span></span><br><span class="line">  <span class="comment">// 2、如果自身没有对应的方法，就从 with 最右边开始查找方法</span></span><br><span class="line">  <span class="keyword">var</span> c = <span class="keyword">new</span> C();</span><br><span class="line">  c.a();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="异步"><a href="#异步" class="headerlink" title="异步"></a>异步</h2><p>Dart 是基于单线程模型的语言。但是在开发当中我们经常会进行耗时操作，比如：网络请求，这种耗时操作会阻塞我们的代码，所以在 Dart 也有并发机制，名叫 <strong>isolate</strong>。</p><h3 id="isolate-机制"><a href="#isolate-机制" class="headerlink" title="isolate 机制"></a>isolate 机制</h3><p>APP 的启动入口 <code>main</code> 函数就是一个类似 Android 主线程的一个主 <code>isolate</code>。和 Java 的 Thread 不同的是，Dart 中的 <code>isolate</code> 无法共享内存。</p><p><img src="https://personal-blog.oss-cn-hangzhou.aliyuncs.com/flutter_isolate_connect.png"></p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&#x27;dart:isolate&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">int</span> i;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> main() &#123;</span><br><span class="line">  i = <span class="number">10</span>;</span><br><span class="line">  <span class="comment">// 创建一个消息接收器</span></span><br><span class="line">  ReceivePort receivePort = <span class="keyword">new</span> ReceivePort();</span><br><span class="line">  <span class="comment">// 创建 isolate</span></span><br><span class="line">  Isolate.spawn(isolateMain, receivePort.sendPort);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 接收其他 isolate 发过来的消息</span></span><br><span class="line">  receivePort.listen((message) &#123;</span><br><span class="line">    <span class="comment">// 发过来 sendPort，则主 isolate 也可以向创建的 isolate 发送消息</span></span><br><span class="line">    <span class="keyword">if</span> (message <span class="keyword">is</span> SendPort) &#123;</span><br><span class="line">      message.send(<span class="string">&quot;好呀好呀!&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="built_in">print</span>(<span class="string">&quot;接到子 isolate 消息：&quot;</span> + message);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 新 isolate 的入口函数</span></span><br><span class="line"><span class="keyword">void</span> isolateMain(SendPort sendPort) &#123;</span><br><span class="line">  <span class="comment">// isolate 是内存隔离的，i 的值是在主 isolate 定义的所以这里获得 null</span></span><br><span class="line">  <span class="built_in">print</span>(i);</span><br><span class="line"></span><br><span class="line">  ReceivePort receivePort = <span class="keyword">new</span> ReceivePort();</span><br><span class="line">  sendPort.send(receivePort.sendPort);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 向主 isolate 发送消息</span></span><br><span class="line">  sendPort.send(<span class="string">&quot;去学习吗？&quot;</span>);</span><br><span class="line"></span><br><span class="line">  receivePort.listen((message) &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;接到主 isolate 消息:&quot;</span> + message);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="event-loop"><a href="#event-loop" class="headerlink" title="event-loop"></a>event-loop</h3><p>可以看到代码中，我们接收消息使用了 <strong>listen</strong> 函数来监听消息，假设我们现在在 <strong>main</strong> 方法最后加入 <strong>sleep</strong> 休眠，会不会影响 <strong>listen</strong> 回调的时机？</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&#x27;dart:io&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">&#x27;dart:isolate&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">int</span> i;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> main() &#123;</span><br><span class="line">  i = <span class="number">10</span>;</span><br><span class="line">  <span class="comment">// 创建一个消息接收器</span></span><br><span class="line">  ReceivePort receivePort = <span class="keyword">new</span> ReceivePort();</span><br><span class="line">  <span class="comment">// 创建 isolate</span></span><br><span class="line">  Isolate.spawn(isolateMain, receivePort.sendPort);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 接收其他 isolate 发过来的消息</span></span><br><span class="line">  receivePort.listen((message) &#123;</span><br><span class="line">    <span class="comment">// 发过来 sendPort，则主 isolate 也可以向创建的 isolate 发送消息</span></span><br><span class="line">    <span class="keyword">if</span> (message <span class="keyword">is</span> SendPort) &#123;</span><br><span class="line">      message.send(<span class="string">&quot;好呀好呀!&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="built_in">print</span>(<span class="string">&quot;接到子 isolate 消息：&quot;</span> + message);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 增加休眠，是否会影响 listen 的时机？</span></span><br><span class="line">  sleep(<span class="built_in">Duration</span>(seconds: <span class="number">2</span>));</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">&quot;休眠完成&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 新 isolate 的入口函数</span></span><br><span class="line"><span class="keyword">void</span> isolateMain(SendPort sendPort) &#123;</span><br><span class="line">  <span class="comment">// isolate 是内存隔离的，i 的值是在主 isolate 定义的所以这里获得 null</span></span><br><span class="line">  <span class="built_in">print</span>(i);</span><br><span class="line"></span><br><span class="line">  ReceivePort receivePort = <span class="keyword">new</span> ReceivePort();</span><br><span class="line">  sendPort.send(receivePort.sendPort);</span><br><span class="line">  <span class="comment">// 向主 isolate 发送消息</span></span><br><span class="line">  sendPort.send(<span class="string">&quot;去学习吗？&quot;</span>);</span><br><span class="line"></span><br><span class="line">  receivePort.listen((message) &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;接到主 isolate 消息：&quot;</span> + message);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果是大概 2s 后，我们的 <strong>listen</strong> 才打印出其他 <code>isolate</code> 发过来的消息，同 <code>Android Handler</code> 类似，在 Dart 运行环境中也是靠事件驱动的，通过 <code>event loop</code> 不停的从队列中获取消息或者事件来驱动整个应用的运行，<code>isolate</code> 发过来的消息就是通过 <strong>loop</strong> 处理。但是不同的是在 Android 中每个线程只有一个 Looper 所对应的 MessageQueue，而 Dart 中有两个队列，一个叫做 <strong>event queue（事件队列）</strong>，另一个叫做 <strong>microtask queue（微任务队列）</strong>。</p><p><img src="https://personal-blog.oss-cn-hangzhou.aliyuncs.com/flutter_message_handler.png"></p><p>Dart 在执行完 main 函数后，就会由 Loop 开始执行两个任务队列中的 Event。首先 Loop 检查微服务队列，依次执行 Event，当 <strong>Microtask queue</strong> 执行完后，就检查 <strong>Event queue</strong> 队列依次执行，在执行 <strong>Event queue</strong> 的过程中，每执行完一个 Event 就再检查一次微服务队列。所以微服务队列优先级高，可以利用微服务进行插队。</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&#x27;dart:io&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> main()&#123;</span><br><span class="line">  <span class="keyword">new</span> File(<span class="string">&quot;~/a.txt&quot;</span>).readAsString().then((content)&#123;</span><br><span class="line">      <span class="built_in">print</span>(content);</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>文件内容永远也无法打印出来，因为 <strong>main</strong> 函数还没执行完。而 <strong>then</strong> 方法是由 Loop 检查 <strong>Event queue</strong> 执行的。</p><p>如果需要往微服务中插入 Event 进行插队：</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&#x27;dart:async&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">&#x27;dart:io&#x27;</span>;</span><br><span class="line"><span class="comment">// 结果是限制性了 microtask 然后执行 then 方法。</span></span><br><span class="line"><span class="keyword">void</span> main() &#123;</span><br><span class="line">  <span class="keyword">new</span> File(<span class="string">&quot;~/a.txt&quot;</span>).readAsString().then((content)&#123;</span><br><span class="line">      <span class="built_in">print</span>(content);</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="comment">// Future. 内部就是调用了 scheduleMicrotask</span></span><br><span class="line">  Future.microtask(()&#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;future: excute microtask&quot;</span>);</span><br><span class="line">  &#125;);</span><br><span class="line"><span class="comment">//  scheduleMicrotask(()&#123;</span></span><br><span class="line"><span class="comment">//    print(&quot;&quot;);</span></span><br><span class="line"><span class="comment">//  &#125;);</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Future"><a href="#Future" class="headerlink" title="Future"></a>Future</h3><p>在 Dart 库中随处可见 <code>Future</code> 对象，通常异步函数返回的对象就是一个 <code>Future</code>。当一个 <code>Future</code> 执行完后，它里面的值就可以使用了，可以使用 <strong>then()</strong> 来在 <code>Future</code> 完成的时候执行其他代码。<code>Future</code> 对象其实就代表了在事件队列中的一个事件的结果。</p><h3 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h3><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 当给到一个不存在的文件地址时会发生异常，这时候可以利用 catchError 捕获此异常。</span></span><br><span class="line"><span class="comment">// then().catchError() 模式就是异步的 try-catch。</span></span><br><span class="line"><span class="keyword">new</span> File(<span class="string">&quot;~/a1.txt&quot;</span>).readAsString().then((content) &#123;</span><br><span class="line">    <span class="built_in">print</span>(content);</span><br><span class="line">  &#125;).catchError((e, s) &#123;</span><br><span class="line">    <span class="built_in">print</span>(s);</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure><h3 id="组合"><a href="#组合" class="headerlink" title="组合"></a>组合</h3><p><code>then()</code> 的返回值同样是一个 <code>Future</code> 对象，可以利用队列的原理进行组合异步任务。</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> File(<span class="string">&quot;~/a.txt&quot;</span>).readAsString().then((content) &#123;</span><br><span class="line">  <span class="built_in">print</span>(content);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">1</span>; <span class="comment">// 1 被转化为 Future&lt;int&gt; 类型返回</span></span><br><span class="line">&#125;).then((i) &#123;</span><br><span class="line">  <span class="built_in">print</span>(i);</span><br><span class="line">&#125;).catchError((e, s) &#123;</span><br><span class="line">  <span class="built_in">print</span>(s);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>上面的方式是等待执行完成读取文件之后，再执行一个新的 <code>Future</code>。如果我们需要等待一组任务都执行完成再统一处理一些事情，可以通过 <code>wait()</code> 完成。</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">Future readDone = <span class="keyword">new</span> File(<span class="string">&quot;~/a.txt&quot;</span>).readAsString();</span><br><span class="line"> <span class="comment">// 延迟 3s</span></span><br><span class="line"> Future delayedDone = Future.delayed(<span class="built_in">Duration</span>(seconds: <span class="number">3</span>));</span><br><span class="line"></span><br><span class="line"> Future.wait([readDone, delayedDone]).then((values) &#123;</span><br><span class="line">    <span class="built_in">print</span>(values[<span class="number">0</span>]); <span class="comment">// 第一个 Future 的结果</span></span><br><span class="line">    <span class="built_in">print</span>(values[<span class="number">1</span>]); <span class="comment">// 第二个 Future 的结果</span></span><br><span class="line"> &#125;);</span><br></pre></td></tr></table></figure><h2 id="Stream"><a href="#Stream" class="headerlink" title="Stream"></a>Stream</h2><p>Stream(流) 在 Dart API 中也经常出现，表示发出的一系列的异步数据。 Stream 是一个异步数据源，它是 Dart 中处理异步事件流的统一 API。</p><p>Future 表示稍后获得的一个数据，所有异步的操作的返回值都用 Future 来表示。但是 Future 只能表示一次异步获得的数据。而 Stream 表示多次异步获得的数据。比如 IO 处理的时候，每次只会读取一部分数据和一次性读取整个文件的内容相比，Stream 的好处是处理过程中内存占用较小。而 File 的 <code>readAsString()</code> 是一次性读取整个文件的内容进来，虽然获得完整内容处理起来比较方便，但是如果文件很大的话就会导致内存占用过大的问题。</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> File(<span class="string">&quot;~/app-release.apk&quot;</span>).openRead().listen((<span class="built_in">List</span>&lt;<span class="built_in">int</span>&gt; bytes) &#123;</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;stream 执行&quot;</span>);  <span class="comment">// 执行多次</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> File(<span class="string">&quot;~/app-release.apk&quot;</span>).readAsBytes().then((_)&#123;</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;future执行&quot;</span>); <span class="comment">// 执行 1 次</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><code>listen()</code> 其实就是订阅这个 Stream，它会返回一个 <code>StreamSubscription</code> 订阅者。订阅者肯定就提供了取消订阅的 <code>cancel()</code>，去掉后我们的 <code>listen</code> 中就接不到任何信息了。除了 <code>cancel()</code> 取消方法之外，我们还可以使用 <code>onData()</code> 重置 <code>listene</code> 方法，<code>onDone</code> 监听完成等等操作。</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">StreamSubscription&lt;<span class="built_in">List</span>&lt;<span class="built_in">int</span>&gt;&gt; listen = <span class="keyword">new</span> File(<span class="string">&quot;~/app-release.apk&quot;</span>).openRead().listen((<span class="built_in">List</span>&lt;<span class="built_in">int</span>&gt; bytes) &#123;</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;stream 执行&quot;</span>);</span><br><span class="line">&#125;);</span><br><span class="line">listen.onData((_)&#123;</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;替代 listene&quot;</span>);</span><br><span class="line">&#125;);</span><br><span class="line">listen.onDone(()&#123;</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;结束&quot;</span>);</span><br><span class="line">&#125;);</span><br><span class="line">listen.onError((e,s)&#123;</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;异常&quot;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 暂停，如果没有继续则会退出程序</span></span><br><span class="line">listen.pause();</span><br><span class="line"><span class="comment">// 继续</span></span><br><span class="line">listen.resume();</span><br></pre></td></tr></table></figure><h3 id="广播模式"><a href="#广播模式" class="headerlink" title="广播模式"></a>广播模式</h3><p>​Stream 有两种订阅模式：<strong>单订阅</strong> 和 <strong>多订阅</strong>。<strong>单订阅</strong> 就是只能有一个订阅者，上面的使用我们都是单订阅模式，而广播是可以有多个订阅者。通过 <strong>Stream.asBroadcastStream()</strong> 可以将一个单订阅模式的 Stream 转换成一个多订阅模式的 Stream，isBroadcast 属性可以判断当前 Stream 所处的模式。</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> stream = <span class="keyword">new</span> File(<span class="string">&quot;~/app-release.apk&quot;</span>).openRead();</span><br><span class="line">stream.listen((<span class="built_in">List</span>&lt;<span class="built_in">int</span>&gt; bytes) &#123;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 错误 单订阅只能有一个订阅者</span></span><br><span class="line"><span class="comment">//  stream.listen((_)&#123;</span></span><br><span class="line"><span class="comment">//    print(&quot;stream执行&quot;);</span></span><br><span class="line"><span class="comment">//  &#125;);</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> broadcastStream = <span class="keyword">new</span> File(<span class="string">&quot;/Users/enjoy/app-release.apk&quot;</span>).openRead().asBroadcastStream();</span><br><span class="line">broadcastStream.listen((_)&#123;</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;订阅者1&quot;</span>);</span><br><span class="line">&#125;);</span><br><span class="line">broadcastStream.listen((_)&#123;</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;订阅者2&quot;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>需要注意的是，多订阅模式如果没有及时添加订阅者则可能丢数据。</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 默认是单订阅</span></span><br><span class="line"><span class="keyword">var</span> stream = Stream.fromIterable([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]);</span><br><span class="line"><span class="comment">// 3s 后添加订阅者 不会丢失数据</span></span><br><span class="line"><span class="keyword">new</span> Timer(<span class="keyword">new</span> <span class="built_in">Duration</span>(seconds: <span class="number">3</span>), () =&gt; stream.listen(<span class="built_in">print</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个流管理器 对一个 stream 进行管理</span></span><br><span class="line"><span class="keyword">var</span> streamController = StreamController.broadcast();</span><br><span class="line"><span class="comment">// 添加</span></span><br><span class="line">streamController.add(<span class="number">1</span>);</span><br><span class="line"><span class="comment">// 先发出事件再订阅 无法接到通知</span></span><br><span class="line">streamController.stream.listen((i)&#123;</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;broadcast:<span class="subst">$i</span>&quot;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 记得关闭</span></span><br><span class="line">streamController.close();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这里没有丢失，因为 stream 通过 asBroadcastStream 转为了多订阅，但是本质是单订阅流，并不改变原始 stream 的实现特性</span></span><br><span class="line"><span class="keyword">var</span> broadcastStream = Stream.fromIterable([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]).asBroadcastStream();</span><br><span class="line"><span class="keyword">new</span> Timer(<span class="keyword">new</span> <span class="built_in">Duration</span>(seconds: <span class="number">3</span>), () =&gt; broadcastStream.listen(<span class="built_in">print</span>));</span><br></pre></td></tr></table></figure><h2 id="async-await"><a href="#async-await" class="headerlink" title="async&#x2F;await"></a>async&#x2F;await</h2><p>使用 <code>async</code> 和 <code>await</code> 的代码是异步的，但是看起来很像同步代码。当我们需要获得 A 的结果，再执行 B，时，你需要 <code>then()-&gt;then()</code>，但是利用 <code>async</code> 与 <code>await</code> 能够非常好的解决回调地狱的问题：</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="comment">// async 表示这是一个异步方法，await 必须再 async 方法中使用</span></span><br><span class="line"><span class="comment">// 异步方法只能返回 void 和 Future</span></span><br><span class="line">Future&lt;<span class="built_in">String</span>&gt; readFile() <span class="keyword">async</span> &#123;</span><br><span class="line">  <span class="comment">// await 等待 future 执行完成再执行后续代码</span></span><br><span class="line">  <span class="built_in">String</span> content = <span class="keyword">await</span> <span class="keyword">new</span> File(<span class="string">&quot;~/a.txt&quot;</span>).readAsString();</span><br><span class="line">  <span class="built_in">String</span> content2 = <span class="keyword">await</span> <span class="keyword">new</span> File(<span class="string">&quot;~/a.txt&quot;</span>).readAsString();</span><br><span class="line">  <span class="comment">// 自动转换为 future</span></span><br><span class="line">  <span class="keyword">return</span> content;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Flutter </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Dart </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Dart 基础</title>
      <link href="/2021/09/29/Flutter/Dart%20%E5%9F%BA%E7%A1%80/"/>
      <url>/2021/09/29/Flutter/Dart%20%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<p>使用一个框架，首先要学习的就是其对应的开发语言，在 Flutter 中，选择 Dart 作为对应的开发语言。</p><p>Dart 在静态语法方面和 Java 非常相似，如类型定义、函数声明、泛型等，动态方面又和 JavaScript 很像，如函数式特性、异步支持等。</p><h2 id="基础类型"><a href="#基础类型" class="headerlink" title="基础类型"></a>基础类型</h2><ol><li>Number</li><li>String</li><li>Boolean</li><li>List</li><li>Map</li><li>Set</li><li>Rune</li><li>Symbol</li></ol><h3 id="Number-数值"><a href="#Number-数值" class="headerlink" title="Number 数值"></a>Number 数值</h3><p><code> num</code> 是数字类型的父类，有两个子类 <code>int</code> 和 <code>double</code>。</p><p>Dart 当中的 int，在编码的时候可以将 int 当成 Java 的 short、int、long 来使用，如果我们写的 Dart 代码超过了 4 个字节，那么 Dart 会将其编译成类似 Java 当中的 Long，否则编译成 Java 中的 short 或者 int。</p><blockquote><p>bitLength 属性：可以查看 num 变量占用几个字节。</p></blockquote><h3 id="String-字符串"><a href="#String-字符串" class="headerlink" title="String 字符串"></a>String 字符串</h3><p> Dart 字符串是 UTF-16 编码的字符序列。可以使用 <strong>单引号</strong> 或者 <strong>双引号</strong> 来创建字符串，<strong>单引号</strong> 和 <strong>双引号</strong> 可以嵌套使用，否则需要使用 <code>\</code> 进行转义。字符串中也可以引用变量与表达式。</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">&quot;Walker&quot;</span>;</span><br><span class="line"><span class="comment">// 如果插入一个简单的标识符，而后面没有紧跟更多的字母数字文本，那么 &#123;&#125; 应该被省略</span></span><br><span class="line"><span class="keyword">var</span> message = <span class="string">&quot;my name is <span class="subst">$name</span>&quot;</span>;</span><br><span class="line"><span class="keyword">var</span> upperMessage = <span class="string">&quot;my name is <span class="subst">$&#123;name.toUpperCase()&#125;</span>!&quot;</span>;</span><br></pre></td></tr></table></figure><p>与 Java 一样可以使用 <code>+</code> 操作符来把字符串拼接，也可以把多个字符串放到一起来实现同样的功能：</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">&quot;my name is &quot;</span> + <span class="string">&quot;Walker&quot;</span>;</span><br></pre></td></tr></table></figure><p>使用 <code>三个单引号或者双引号</code> 可以创建多行字符串对象：</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> str1 = <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">You can create</span></span><br><span class="line"><span class="string">multi-line string like this one.</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> str2 = <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">This is also a </span></span><br><span class="line"><span class="string">multi-line string.</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span>;</span><br></pre></td></tr></table></figure><p>提供一个 <code>r</code> 前缀可以创建一个 <code>原始 raw</code> 字符串：</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">r&quot;换行符：\n&quot;</span>); <span class="comment">// 换行符：\n   r: 不需要转义</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;换行符：\\n&quot;</span>); <span class="comment">// 换行符：\n</span></span><br></pre></td></tr></table></figure><h3 id="Boolean-布尔值"><a href="#Boolean-布尔值" class="headerlink" title="Boolean 布尔值"></a>Boolean 布尔值</h3><p> Dart 有一个名字为 <code>bool</code> 的类型。只有两个对象是布尔类型的：<code>true</code> 和 <code>false</code>。这一点和 <code>Java</code> 没有太大的区别。</p><h3 id="List-列表"><a href="#List-列表" class="headerlink" title="List 列表"></a>List 列表</h3><p>所以编程语言中最常见的集合可能是 <code>数组</code> 或 <code>有序对象组</code>。在 Dart 中，数组就是 <code>List</code> 对象。对 <code>List</code> 进行遍历也和 <code>Java</code> 一样。</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> list = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="built_in">print</span>(list[<span class="number">0</span>]); <span class="comment">// List 下标索引从 0 开始</span></span><br><span class="line">list[<span class="number">2</span>] = <span class="number">5</span>; <span class="comment">// 修改元素</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> list = <span class="built_in">List</span>(<span class="number">1</span>);</span><br><span class="line">list[<span class="number">0</span>] = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在 List 字面量之前添加 const 关键字，可以定义一个不变的 list 对象（编译时常量）</span></span><br><span class="line"><span class="keyword">var</span> list = <span class="keyword">const</span> [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">i.add(<span class="number">1</span>); <span class="comment">// 错误，list 不可变</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// List 遍历</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i <span class="keyword">in</span> list) &#123;</span><br><span class="line"><span class="comment">// todo</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; list.length; i++) &#123;</span><br><span class="line"><span class="comment">// todo</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Map-映射集合"><a href="#Map-映射集合" class="headerlink" title="Map 映射集合"></a>Map 映射集合</h3><p>键值对相关的对象，键和值可以是任何类型的对象，每个 <code>键</code> 只出现一次，一个 <code>值</code> 则可以出现多次。</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> names = &#123;<span class="string">&quot;f&quot;</span>: <span class="string">&quot;Walker&quot;</span>, <span class="string">&quot;s&quot;</span>: <span class="string">&quot;Denial&quot;</span>&#125;;</span><br><span class="line"><span class="keyword">var</span> names = <span class="built_in">Map</span>();</span><br><span class="line">names[<span class="string">&#x27;f&#x27;</span>] = <span class="string">&quot;Walker&quot;</span>;</span><br><span class="line">names[<span class="string">&#x27;s&#x27;</span>] = <span class="string">&quot;Denial&quot;</span>;</span><br></pre></td></tr></table></figure><p>与 List 一样，在 Map 字面量之前添加 <code>const</code> 关键字，可以定义一个编译时常量的 Map。</p><h3 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h3><p>在 Dart 中 <code>Set</code> 是一个元素唯一且无序的集合。 Dart 为 <code>Set</code> 提供了 <code>Set</code> 字面量和 <code>Set</code> 类型。</p><p>下面是通过字面量创建 <code>Set</code> 的一个简单示例：</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> halogens = &#123;<span class="string">&#x27;fluorine&#x27;</span>, <span class="string">&#x27;chlorine&#x27;</span>, <span class="string">&#x27;bromine&#x27;</span>, <span class="string">&#x27;iodine&#x27;</span>, <span class="string">&#x27;astatine&#x27;</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> names = &lt;<span class="built_in">String</span>&gt;&#123;&#125;;</span><br></pre></td></tr></table></figure><p>如果忘记在 {} 上注释类型或赋值到一个未声明类型的变量上，   那么 Dart 会创建一个类型为 <code>Map&lt;dynamic, dynamic&gt;</code> 的对象。</p><p>使用 <code>add()</code> 或 <code>addAll()</code> 为已有的 Set 添加元素：</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> elements = &lt;<span class="built_in">String</span>&gt;&#123;&#125;;</span><br><span class="line">elements.add(<span class="string">&#x27;fluorine&#x27;</span>);</span><br><span class="line">elements.addAll(halogens);</span><br></pre></td></tr></table></figure><p>在 <code>Set</code> 字面量前增加 <code>const</code> ，来创建一个编译时 <code>Set</code> 常量：</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> constantSet = <span class="keyword">const</span> &#123;</span><br><span class="line">  <span class="string">&#x27;fluorine&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;chlorine&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;bromine&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;iodine&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;astatine&#x27;</span>,</span><br><span class="line">&#125;;</span><br><span class="line">constantSet.add(<span class="string">&#x27;helium&#x27;</span>); <span class="comment">// 错误</span></span><br></pre></td></tr></table></figure><h3 id="Rune-用于在字符串中表示-Unicode-字符"><a href="#Rune-用于在字符串中表示-Unicode-字符" class="headerlink" title="Rune 用于在字符串中表示 Unicode 字符"></a>Rune 用于在字符串中表示 Unicode 字符</h3><p> Unicode 为世界上所有的书写系统中使用的每个 <strong>字母</strong>、<strong>数字</strong> 和 <strong>符号</strong> 定义了唯一的数值。Dart 字符串是 <code>UTF-16</code> 位代码单元字符序列，所以在字符串中表达 32 位 Unicode 值需要新的语法。 Rune 就是 <code>UTF-32</code> 字符集 <code>String</code> 对象。</p><p> 表达 Unicode 代码点的常用方法是 \uXXXX，其中 XXXX 是 4 位十六进制值。要指定多于或少于 4 个十六进制数字，需要将值放在大括号中。</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> clapping = <span class="string">&#x27;\u&#123;1f44f&#125;&#x27;</span>; <span class="comment">// 5个16进制 需要使用&#123;&#125;</span></span><br><span class="line"><span class="built_in">print</span>(clapping); <span class="comment">// 👏</span></span><br><span class="line"><span class="comment">// 获得 16 位代码单元</span></span><br><span class="line"><span class="built_in">print</span>(clapping.codeUnits); <span class="comment">// [55357, 56399]</span></span><br><span class="line"><span class="comment">// 获得 unicode 代码</span></span><br><span class="line"><span class="built_in">print</span>(clapping.runes.toList()); <span class="comment">// [128079]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// fromCharCode 根据字符码创建字符串</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">String</span>.fromCharCode(<span class="number">128079</span>));</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">String</span>.fromCharCodes(clapping.runes));</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">String</span>.fromCharCodes([<span class="number">55357</span>, <span class="number">56399</span>]));</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">String</span>.fromCharCode(<span class="number">0x1f44f</span>));</span><br><span class="line"></span><br><span class="line">Runes input = <span class="keyword">new</span> Runes(</span><br><span class="line">  <span class="string">&#x27;\u2665  \u&#123;1f605&#125;  \u&#123;1f60e&#125;  \u&#123;1f47b&#125;  \u&#123;1f596&#125;  \u&#123;1f44d&#125;&#x27;</span>);</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">String</span>.fromCharCodes(input));</span><br></pre></td></tr></table></figure><h3 id="Symbols"><a href="#Symbols" class="headerlink" title="Symbols"></a>Symbols</h3><p>操作符标识符，可以看作 C 中的宏。表示编译时的一个常量。</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> i = #A; <span class="comment">// 常量</span></span><br><span class="line"></span><br><span class="line">main() &#123;</span><br><span class="line">  <span class="built_in">print</span>(i);</span><br><span class="line">  <span class="keyword">switch</span>(i)&#123;</span><br><span class="line">    <span class="keyword">case</span> #A:</span><br><span class="line">      <span class="built_in">print</span>(<span class="string">&quot;A&quot;</span>);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> #B:</span><br><span class="line">      <span class="built_in">print</span>(<span class="string">&quot;B&quot;</span>);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">var</span> b = <span class="keyword">new</span> <span class="built_in">Symbol</span>(<span class="string">&quot;b&quot;</span>);</span><br><span class="line">  <span class="built_in">print</span>(#b == b); <span class="comment">// true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="变量声明"><a href="#变量声明" class="headerlink" title="变量声明"></a>变量声明</h2><p>变量是一个引用，未初始化的变量值是 <strong>null</strong>。</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> num1 = <span class="number">1</span>; <span class="comment">// 声明方式一，使用 var 进行声明，会进行类型推断</span></span><br><span class="line"><span class="built_in">Object</span> num2 = <span class="number">2</span>; <span class="comment">// 声明方式二，使用 Object 进行声明</span></span><br><span class="line"><span class="built_in">dynamic</span> num3 = <span class="number">3</span>; <span class="comment">// 声明方式三，使用动态类型</span></span><br></pre></td></tr></table></figure><h3 id="Object-声明"><a href="#Object-声明" class="headerlink" title="Object 声明"></a>Object 声明</h3><p>与 Java 一样，Object 是所有类的基类，Object 声明的变量可以是任意类型。在 Dart 中，<code>数字</code>、<code>方法</code> 和 <code>null</code> 都是对象。</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Object</span> name = <span class="string">&quot;Hi, Walker&quot;</span>;</span><br><span class="line">name = <span class="string">&quot;Hi, Denial&quot;</span>;</span><br></pre></td></tr></table></figure><h3 id="var-声明"><a href="#var-声明" class="headerlink" title="var 声明"></a>var 声明</h3><p>Dart 中比较推荐使用此种方式声明变量。需要注意点如下：</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 场景一：声明时不进行初始化</span></span><br><span class="line"><span class="keyword">var</span> name; <span class="comment">// 注意！注意！注意！此时 name 没有初始化，那么 name 的类型为 dynamic，类型没有限制</span></span><br><span class="line"><span class="comment">// 以下赋值是正确的</span></span><br><span class="line">name = <span class="string">&quot;Walker&quot;</span>;</span><br><span class="line">name = <span class="number">2021</span>;</span><br><span class="line">name = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 场景二：声明时进行初始化</span></span><br><span class="line"><span class="keyword">var</span> name = <span class="string">&quot;Walker&quot;</span>; <span class="comment">// 注意！此时 name 初始化了，那么 name 的类型为 String，后续只能以 String 类型进行赋值</span></span><br><span class="line"><span class="comment">// 以下赋值是正确的</span></span><br><span class="line">name = <span class="string">&quot;Walker&quot;</span>;</span><br><span class="line"><span class="comment">// 以下赋值是错误的</span></span><br><span class="line">name = <span class="number">2021</span>;</span><br><span class="line">name = <span class="keyword">true</span>;</span><br></pre></td></tr></table></figure><h3 id="dynamic-声明"><a href="#dynamic-声明" class="headerlink" title="dynamic 声明"></a>dynamic 声明</h3><p>dynamic 比较特殊，不是在编译时确定实际类型，而是在运行时。其他行为与 Object 一样。</p><h2 id="final-与-const"><a href="#final-与-const" class="headerlink" title="final 与 const"></a>final 与 const</h2><p> 如果不打算改变一个变量，可以使用 <code>final</code> 和 <code>const</code>，它们可以替代任何类型，不过，只能在声明时初始化，且不能改变。</p><p>从字面上理解，<code>final</code> 与 <code>const</code> 都是 <strong>不可变</strong> 的，看不出区别，但是 <strong><code>final</code> 是运行时</strong> 常量，而 <strong><code>const</code> 是编译器</strong> 常量，它的值在编译期就可以确定，编译时常量能够让代码运行的更高效。</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 正确，值已确定，并且确定时间不冲突</span></span><br><span class="line"><span class="keyword">const</span> name = <span class="string">&quot;Walker&quot;</span>;</span><br><span class="line"><span class="keyword">const</span> name1 = name + <span class="string">&quot;Denial&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 错误，final 不能在编译时确定值，因此 const 也不能确定值</span></span><br><span class="line"><span class="keyword">final</span> name = <span class="string">&quot;Walker&quot;</span>;</span><br><span class="line"><span class="keyword">const</span> name1 = name + <span class="string">&quot;Denial&quot;</span>;</span><br></pre></td></tr></table></figure><blockquote><p>类的变量可以为 <code>final</code>，但不能是 <code>const</code>。如果 <code>const</code> 变量在类中，需要定义为 <code>static const</code> 静态常量。</p></blockquote><h2 id="操作符"><a href="#操作符" class="headerlink" title="操作符"></a>操作符</h2><h3 id="类型判定操作符"><a href="#类型判定操作符" class="headerlink" title="类型判定操作符"></a>类型判定操作符</h3><p><code>as</code>、 <code>is</code>、 和 <code>is!</code> 操作符是在运行时判定对象、类型的操作符。</p><table><thead><tr><th align="center">操作符</th><th align="left">解释</th></tr></thead><tbody><tr><td align="center"><code>as</code></td><td align="left">类型转换</td></tr><tr><td align="center"><code>is</code></td><td align="left">如果对象是指定的类型返回 true</td></tr><tr><td align="center"><code>is!</code></td><td align="left">如果对象是指定的类型返回 false</td></tr></tbody></table><p> <code>as</code> 操作符把对象转换为特定的类型，但是如果无法完成转换则会抛出一个异常。</p><p><code>is</code> 和 Java 中的 <code>instanceof</code> 相同</p><h3 id="赋值操作符"><a href="#赋值操作符" class="headerlink" title="赋值操作符"></a>赋值操作符</h3><p><code>=</code>、<code>+=</code>、<code>\=</code>、<code>*=</code> 这些不必多说，还有一个 <code>??=</code> 操作符用来指定值为 null 的变量的值。</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">b ??= value; <span class="comment">// 如果 b 是 null，则 value 赋值给 b；</span></span><br><span class="line">             <span class="comment">// 如果不是 null，则 b 的值保持不变</span></span><br></pre></td></tr></table></figure><h3 id="条件表达式"><a href="#条件表达式" class="headerlink" title="条件表达式"></a>条件表达式</h3><p>Dart 有两个特殊的操作符可以用来替代 <a href="http://dart.goodev.org/guides/language/language-tour#if-and-else">if-else</a> 语句：</p><ul><li><p><code>condition ? expr1 : expr2</code></p><p>如果 <em>condition</em> 是 true，执行 <em>expr1</em> (并返回执行的结果)； 否则执行 <em>expr2</em> 并返回其结果。</p></li><li><p><code>expr1 ?? expr2</code></p><p>如果 <em>expr1</em> 不为null，返回其值； 否则执行 <em>expr2</em> 并返回其结果。</p></li></ul><h3 id="级联操作符"><a href="#级联操作符" class="headerlink" title="级联操作符"></a>级联操作符</h3><p>​级联操作符 (<code>..</code>) 可以在同一个对象上 连续调用多个函数以及访问成员变量。 使用级联操作符可以避免创建 临时变量， 并且写出来的代码看起来 更加流畅：</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="comment">//StringBuffer write就是Java的append</span></span><br><span class="line"><span class="keyword">var</span> sb = <span class="keyword">new</span> <span class="built_in">StringBuffer</span>();</span><br><span class="line">sb..write(<span class="string">&#x27;foo&#x27;</span>)..write(<span class="string">&#x27;bar&#x27;</span>);</span><br></pre></td></tr></table></figure><h3 id="安全操作符"><a href="#安全操作符" class="headerlink" title="安全操作符"></a>安全操作符</h3><p>Dart 提供了 <code>?.</code> 操作符。左边的操作对象如果为 null 则返回 null。</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="built_in">String</span> sb;</span><br><span class="line"><span class="comment">//空指针</span></span><br><span class="line"><span class="built_in">print</span>(sb.length);</span><br><span class="line"><span class="built_in">print</span>(sb?.length);</span><br></pre></td></tr></table></figure><h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="built_in">int</span> add(<span class="built_in">int</span> i, <span class="built_in">int</span> j) &#123;</span><br><span class="line">  <span class="keyword">return</span> i + j;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 也可以选择忽略类型(不推荐)</span></span><br><span class="line">add(i, j) &#123;</span><br><span class="line">  <span class="keyword">return</span> i + j;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 对于只有一个表达式的方法，可以选择使用缩写语法来定义：</span></span><br><span class="line">add(i, j) =&gt; i + j;</span><br><span class="line"><span class="comment">// 在箭头 (=&gt;) 和分号 (;) 之间只能使用一个表达式。</span></span><br></pre></td></tr></table></figure><h3 id="一等方法对象"><a href="#一等方法对象" class="headerlink" title="一等方法对象"></a>一等方法对象</h3><p>Dart 是一个真正的面向对象语言，方法也是对象并且具有一种类型 <code>Function</code>。 这意味着，方法可以赋值给变量，也可以当做其他方法的参数。可以把方法当做参数调用另外一个方法</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> list = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br><span class="line"><span class="comment">// 将 print 方法作为参数传递给 forEach</span></span><br><span class="line">list.forEach(<span class="built_in">print</span>);</span><br><span class="line"><span class="comment">// 可以将方法赋值给一个变量类型为 Function</span></span><br><span class="line"><span class="keyword">var</span> p = <span class="built_in">print</span>;</span><br><span class="line">list.forEach(p);</span><br></pre></td></tr></table></figure><blockquote><p>方法可以有两种类型的参数：必需的和可选的。 必需的参数需要在参数列表前面， 后面再定义可选参数。</p></blockquote><h3 id="可选命名参数"><a href="#可选命名参数" class="headerlink" title="可选命名参数"></a>可选命名参数</h3><p>把方法的参数放到 <code>&#123;&#125;</code> 中就变成可选 <code>命名参数</code>。</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="built_in">int</span> add(&#123;<span class="built_in">int</span> i, <span class="built_in">int</span> j&#125;) &#123;</span><br><span class="line">  <span class="keyword">if</span>(i == <span class="keyword">null</span> || j == <span class="keyword">null</span>)&#123;</span><br><span class="line">     <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> i + j;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用方法的时候，可以使用这种形式 <code>paramName: value</code> 来指定命名参数。例如：</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 无必须参数</span></span><br><span class="line">add()</span><br><span class="line"><span class="comment">// 选择传递参数</span></span><br><span class="line">add(i:<span class="number">1</span>)</span><br><span class="line"><span class="comment">// 位置无关</span></span><br><span class="line">add(i:<span class="number">1</span>, j:<span class="number">2</span>)</span><br><span class="line">add(j:<span class="number">1</span>, i:<span class="number">2</span>)</span><br></pre></td></tr></table></figure><h3 id="可选位置参数"><a href="#可选位置参数" class="headerlink" title="可选位置参数"></a>可选位置参数</h3><p>把方法的参数放到 <code>[]</code> 中就变成可选位置参数，传值时按照参数位置顺序传递：</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="built_in">int</span> add([<span class="built_in">int</span> i, <span class="built_in">int</span> j]) &#123;</span><br><span class="line">  <span class="keyword">if</span>(i == <span class="keyword">null</span> || j == <span class="keyword">null</span>)&#123;</span><br><span class="line">     <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> i + j;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 1 赋值给 i</span></span><br><span class="line">add(<span class="number">1</span>);</span><br><span class="line"><span class="comment">// 按照顺序赋值</span></span><br><span class="line">add(<span class="number">1</span>,<span class="number">2</span>);</span><br></pre></td></tr></table></figure><h3 id="默认参数值"><a href="#默认参数值" class="headerlink" title="默认参数值"></a>默认参数值</h3><p>在定义方法的时候，可选参数可以使用 <code>=</code> 来定义可选参数的默认值。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int add([int i = 1, int j = 2]) =&gt; i + j;</span><br><span class="line">int add(&#123;int i = 1, int j = 2&#125;) =&gt; i + j;</span><br></pre></td></tr></table></figure><h3 id="匿名方法"><a href="#匿名方法" class="headerlink" title="匿名方法"></a>匿名方法</h3><p>没有名字的方法，称之为匿名方法，也可以称之为 lambda 或者 closure 闭包。匿名方法的声明为：</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">([<span class="built_in">Type</span>] param1, …) &#123; </span><br><span class="line">  codeBlock; </span><br><span class="line">&#125;; </span><br></pre></td></tr></table></figure><p>例如：</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> list = [<span class="string">&#x27;apples&#x27;</span>, <span class="string">&#x27;oranges&#x27;</span>, <span class="string">&#x27;grapes&#x27;</span>, <span class="string">&#x27;bananas&#x27;</span>, <span class="string">&#x27;plums&#x27;</span>];</span><br><span class="line">list.forEach((i) &#123;</span><br><span class="line">  <span class="built_in">print</span>(list[i]);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h2><p>和 Java 不同的是，所有的 Dart 异常是非检查异常。 方法不一定声明了他们所抛出的异常，并且不要求你捕获任何异常。</p><p>Dart 提供了 <code>Exception</code> 和 <code>Error</code> 类型， 以及一些子类型。你还可以定义自己的异常类型。但是，Dart 代码可以抛出任何非 null 对象为异常，不仅仅是实现了 <code>Exception</code> 或者 <code>Error</code> 的对象。</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">&#x27;这是一个异常&#x27;</span>);</span><br><span class="line"><span class="keyword">throw</span> <span class="string">&#x27;这是一个异常&#x27;</span>;</span><br><span class="line"><span class="keyword">throw</span> <span class="number">123</span>;</span><br></pre></td></tr></table></figure><p>与 Java 不同之处在于捕获异常部分，Dart 中捕获异常同样是使用 <code>catch</code> 语句，但是 Dart 中的 <code>catch</code> 无法指定异常类型。需要结合 <code>on</code> 来使用，基本语法如下：</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="number">123</span>;</span><br><span class="line">&#125; <span class="keyword">on</span> <span class="built_in">int</span> <span class="keyword">catch</span>(e) &#123;</span><br><span class="line"><span class="comment">// 使用 on 指定捕获 int 类型的异常对象       </span></span><br><span class="line">&#125; <span class="keyword">catch</span>(e,s) &#123;</span><br><span class="line">    <span class="comment">// 函数 catch() 可以带有一个或者两个参数，第一个参数为抛出的异常对象，第二个为堆栈信息 (StackTrace 对象)</span></span><br><span class="line">    <span class="keyword">rethrow</span>; <span class="comment">// 使用 rethrow 关键字可以把捕获的异常给重新抛出</span></span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Flutter </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Dart </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Flutter 简介</title>
      <link href="/2021/09/22/Flutter/Flutter%20%E7%AE%80%E4%BB%8B/"/>
      <url>/2021/09/22/Flutter/Flutter%20%E7%AE%80%E4%BB%8B/</url>
      
        <content type="html"><![CDATA[<h2 id="什么是-Flutter？"><a href="#什么是-Flutter？" class="headerlink" title="什么是 Flutter？"></a>什么是 Flutter？</h2><p>Flutter 是谷歌的移动 UI 框架，可以快速在 iOS 和 Android 上构建高质量的原生用户界面。Flutter 可以与现有的代码一起工作。在全世界，Flutter 正在被越来越多的开发者和组织使用，并且 Flutter 是完全免费、开源的。</p><h2 id="Flutter-特点"><a href="#Flutter-特点" class="headerlink" title="Flutter 特点"></a>Flutter 特点</h2><ol><li>跨平台移动 UI 框架</li><li>与现有代码一起工作</li><li>完全免费、开源</li></ol><h2 id="Flutter-工作机制"><a href="#Flutter-工作机制" class="headerlink" title="Flutter 工作机制"></a>Flutter 工作机制</h2><p>通过将代码根据不同的平台编译为对应平台的机器码，这样就不需要 Bridge 的存在了，Flutter 自己嵌入了一个 Dart VM，我们编写的代码会被编译成 ARM 的机器码，在 Android 中就是通过 Dart VM 所在的 libflutter.so 完成我们自己编写的代码生成的机器码载入执行。</p><blockquote><p>Android 真机一般都是 ARM 架构的，模拟器是 X86 或 X86_64</p><p>iOS 真机一般也是 ARM，模拟器早起都是 I386，在 5S 的模拟器后就是 X86_64</p></blockquote><h2 id="Flutter-架构"><a href="#Flutter-架构" class="headerlink" title="Flutter 架构"></a>Flutter 架构</h2><p><img src="https://personal-blog.oss-cn-hangzhou.aliyuncs.com/flutter_design.png"></p><h2 id="Flutter-面试题汇总"><a href="#Flutter-面试题汇总" class="headerlink" title="Flutter 面试题汇总"></a>Flutter 面试题汇总</h2><ol><li><a href="https://zhuanlan.zhihu.com/p/102193331">Flutter 这么火， 2020 跳槽都要准备哪些面试题？ </a></li><li><a href="https://www.jianshu.com/p/93821c12a825">Flutter 面试题</a></li><li><a href="https://github.com/wyufeng02/Flutter-Daily-Interview">Flutter 每日一题</a></li><li><a href="https://www.imooc.com/article/293455">Flutter | 金九银十招聘季， 这些面试题祝你一臂之力</a></li><li><a href="https://www.cnblogs.com/yangyxd/p/10449614.html">[Flutter] 一些面试可能会问基础知识</a></li><li><a href="https://www.cnblogs.com/sundaysandroid/p/13470654.html">2019 最新 Flutter 面试知识点集锦（ 一） </a></li><li><a href="https://segmentfault.com/a/1190000021459857">老许， 你要转 Flutter 不要？ 只要你开金口， 面试题现在就给你送来</a></li><li><a href="https://juejin.cn/post/6844903790949171207">一次 Flutter 面试经验， 这些问题你一定要知道！ 必问！ ！ </a></li><li><a href="https://blog.csdn.net/u013095264/article/details/88802822">Flutter 面试点（ 持续更新） </a></li><li><a href="https://juejin.cn/post/6844903843260530701">Flutter 面试知识点集锦</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> Flutter </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 简介 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>跨平台方案对比</title>
      <link href="/2021/09/21/Flutter/%E8%B7%A8%E5%B9%B3%E5%8F%B0%E6%96%B9%E6%A1%88%E5%AF%B9%E6%AF%94/"/>
      <url>/2021/09/21/Flutter/%E8%B7%A8%E5%B9%B3%E5%8F%B0%E6%96%B9%E6%A1%88%E5%AF%B9%E6%AF%94/</url>
      
        <content type="html"><![CDATA[<p> 从事 APP 开发多年，在享受 APP 带来的性能及丰富的 API 同时，也避免不了原生 APP 带来的弊端，比如：</p><ol><li>Android 团队与 iOS 团队由于人数、技术水平等方面不同，导致进度难以统一；</li><li>需要同时维护 2 个团队，但是又在做重复的事情，比如：登录、列表、输入、输出等等，成本很高；</li><li>遇到紧急需求，难以进行动态处理，只能重新发布安装包，用户体验较差；</li></ol><p>那么，有没有一种能同时开发两端的技术呢？</p><p>答案当然是有的，并且随着技术的进步，方案也在不停的演进，依据技术的演进，简单将其分为三代跨平台技术。</p><h2 id="第一代跨平台技术：Web-容器时代"><a href="#第一代跨平台技术：Web-容器时代" class="headerlink" title="第一代跨平台技术：Web 容器时代"></a>第一代跨平台技术：Web 容器时代</h2><p>简而盖之，就是使用系统提供的 <strong>浏览器内核</strong>，运行 <code>前端</code> 代码，解决了上面提到的 <strong>痛点</strong>。</p><p><img src="https://personal-blog.oss-cn-hangzhou.aliyuncs.com/cross_plaform_web.png"></p><p>优点：</p><ol><li>开发效率高：H5 代码只需要开发一次，就能同时在多个系统运行，因此大大降低了开发成本；</li><li>生态成熟：Web 开发技术、社区和资源非常丰富，开发效率很高；</li><li>动态化：支持；</li></ol><p>基于以上这些优点，衍生出了 <strong>Cordova(PhoneGap)<strong>、</strong>Ionic</strong> 和 <strong>微信小程序</strong>。</p><p>但是，这种技术方案也存在缺点，例如：</p><ol><li>性能差：一个完整的 H5 页面的展示要经历浏览器空间的加载、解析和渲染三大过程，性能消耗要比原生开发增加 N 个数量级，一边加载、一边解析、一边渲染，体验较差；</li></ol><h2 id="第二代跨平台技术：泛-Web-容器方案"><a href="#第二代跨平台技术：泛-Web-容器方案" class="headerlink" title="第二代跨平台技术：泛 Web 容器方案"></a>第二代跨平台技术：泛 Web 容器方案</h2><p>基于第一代的 H5 加载、解析、渲染问题，第二代技术将绘制和渲染交给原生处理，提升用户体验。</p><p><img src="https://personal-blog.oss-cn-hangzhou.aliyuncs.com/cross_plaform_web_native.png"></p><p>优点：</p><ol><li>性能较好：绘制和渲染交由原生系统接管；</li><li>效率中等：一套代码两处使用，简单需求开发高效，特定交互或者复杂需求等仍需要对原生平台控件进行拓展时效率很低；</li><li>生态较为成熟：经过数年发展，有不少成熟的第三方工具、工具类；</li><li>动态化：支持；</li></ol><p>由于涉及到原生渲染，那么不可避免的就会遇到原生所带来的问题，缺点如下：</p><ol><li>兼容性较差：与原生空间桥接无法做到两个平台无缝接管，对于特定交互或辅助需求等仍需要对原生空间进行拓展，效率无法保持高效；</li><li>学习难度大：负责业务需求开发对于开发要求需学会 <strong>前端</strong>、<strong>Android</strong>、<strong>iOS</strong>；</li></ol><h2 id="第三代跨平台技术：自绘引擎开发方案"><a href="#第三代跨平台技术：自绘引擎开发方案" class="headerlink" title="第三代跨平台技术：自绘引擎开发方案"></a>第三代跨平台技术：自绘引擎开发方案</h2><p>结合前两种技术方案的优点和缺点，第三代技术采用 <strong>自绘引擎</strong> 方案，即解决了渲染问题，又解决了使用原生控件带来的兼容性问题。</p><p><img src="https://personal-blog.oss-cn-hangzhou.aliyuncs.com/cross_plaform_flutter.png"></p><p>优点：</p><ol><li>效率高：一套代码可以同时运行在 iOS 和 Android 平台，基本无须单独适配；</li><li>性能好：重写了一整套包括底层渲染逻辑和上层开发语言的完整解决方案；</li></ol><p>由于出现时间并不是太久，并且需要自绘引擎，所以也有其对应的缺点：</p><ol><li>生态：尚不成熟，不过目前社区比较活跃，未来可期；</li><li>动态化：不支持；</li></ol><h2 id="三代跨平台技术对比"><a href="#三代跨平台技术对比" class="headerlink" title="三代跨平台技术对比"></a>三代跨平台技术对比</h2><table><thead><tr><th align="center">开发方案</th><th align="center">Web 容器</th><th align="center">React Native</th><th align="center">Weex</th><th align="center">Flutter</th></tr></thead><tbody><tr><td align="center">类型</td><td align="center">Web 容器</td><td align="center">泛 Web 容器</td><td align="center">泛 Web 容器</td><td align="center">自绘引擎</td></tr><tr><td align="center">支持平台</td><td align="center">Android&#x2F;iOS&#x2F;Web</td><td align="center">Android&#x2F;iOS</td><td align="center">Android&#x2F;iOS&#x2F;Web</td><td align="center">Android&#x2F;iOS</td></tr><tr><td align="center">开发语言</td><td align="center">JavaScript</td><td align="center">JavaScript(React)</td><td align="center">JavaScript(Vue)</td><td align="center">Dart</td></tr><tr><td align="center">技术栈</td><td align="center">前端</td><td align="center">偏前端</td><td align="center">偏前端</td><td align="center">偏客户端</td></tr><tr><td align="center">动态化能力</td><td align="center">✅</td><td align="center">✅</td><td align="center">✅</td><td align="center">❌</td></tr><tr><td align="center">渲染性能</td><td align="center">差</td><td align="center">一般</td><td align="center">一般</td><td align="center">好</td></tr><tr><td align="center">滑动性能</td><td align="center">差</td><td align="center">一般</td><td align="center">一般</td><td align="center">好</td></tr><tr><td align="center">页面级支持</td><td align="center">✅</td><td align="center">✅</td><td align="center">✅</td><td align="center">✅</td></tr><tr><td align="center">区块级支持</td><td align="center">❌</td><td align="center">✅</td><td align="center">✅</td><td align="center">✅</td></tr><tr><td align="center">开发效率</td><td align="center">高</td><td align="center">一般</td><td align="center">一般</td><td align="center">一般</td></tr><tr><td align="center">维护成本</td><td align="center">低</td><td align="center">一般</td><td align="center">高</td><td align="center">低</td></tr><tr><td align="center">系统升级适配成本</td><td align="center">低</td><td align="center">中</td><td align="center">中</td><td align="center">低</td></tr><tr><td align="center">社区生态</td><td align="center">活跃</td><td align="center">活跃</td><td align="center">不活跃</td><td align="center">活跃</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> Flutter </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 跨平台 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>版本管理规范</title>
      <link href="/2021/08/12/%E5%85%B6%E4%BB%96/%E7%89%88%E6%9C%AC%E7%AE%A1%E7%90%86%E8%A7%84%E8%8C%83/"/>
      <url>/2021/08/12/%E5%85%B6%E4%BB%96/%E7%89%88%E6%9C%AC%E7%AE%A1%E7%90%86%E8%A7%84%E8%8C%83/</url>
      
        <content type="html"><![CDATA[<h1 id="版本管理规范"><a href="#版本管理规范" class="headerlink" title="版本管理规范"></a>版本管理规范</h1><h2 id="1-提交日志前缀说明"><a href="#1-提交日志前缀说明" class="headerlink" title="1. 提交日志前缀说明"></a>1. 提交日志前缀说明</h2><table><thead><tr><th align="center">类型</th><th>描述</th></tr></thead><tbody><tr><td align="center">build</td><td>修改项目构建系统（例如：glup、webpack、rollup 的配置等）的提交</td></tr><tr><td align="center">ci</td><td>修改项目继续集成流程（例如：Travis、Jenkins、GitLab CI、Circle 等）的提交</td></tr><tr><td align="center">docs</td><td>文档更新</td></tr><tr><td align="center">feat(feature 简写)</td><td>新增功能</td></tr><tr><td align="center">merge</td><td>分支合并</td></tr><tr><td align="center">fix</td><td>bug 修复</td></tr><tr><td align="center">perf</td><td>性能, 体验优化</td></tr><tr><td align="center">refactor</td><td>重构代码（既没有新增功能，也没有修复 bug）</td></tr><tr><td align="center">style</td><td>不影响程序逻辑的代码修改（修改空白字符，格式缩进，补全缺失的分号等，没有改变代码逻辑）</td></tr><tr><td align="center">test</td><td>新增测试用例或是更新现有测试</td></tr><tr><td align="center">revert</td><td>回滚某个更早之前的提交</td></tr><tr><td align="center">chore</td><td>不属于以上类型的其他类型</td></tr></tbody></table><h2 id="2-分支创建流程"><a href="#2-分支创建流程" class="headerlink" title="2. 分支创建流程"></a>2. 分支创建流程</h2><p>以 <code>feature</code> 为例：</p><ol><li>确认需求及需求版本号；</li><li>从 <code>development</code> 分支克隆出分支，命名规则：<code>feature/&#123;版本号&#125;</code>；</li><li>开发人员拉取 <code>feature/&#123;版本号&#125;</code> 分支代码并创建自己开发分支，命名规则：<code>feature/&#123;版本号&#125;_&#123;开发人员名称&#125;</code> (如果当次开发人员需求多，可以再次细分为多个部分，例如：feature&#x2F;{版本号}_{开发人员名称}_part1)；</li><li>开发人员开发并自测完毕后，代码提交到 <code>feature/&#123;版本号&#125;</code> 分支；</li><li>整体需求测试通过后，<code>feature/&#123;版本号&#125;</code> 代码合并到 <code>development</code> 分支；</li><li>按照正常发布流程进行发布；</li></ol><p><img src="https://personal-blog.oss-cn-hangzhou.aliyuncs.com/flow_gitlab.png"></p><h2 id="3-分支保留规则"><a href="#3-分支保留规则" class="headerlink" title="3. 分支保留规则"></a>3. 分支保留规则</h2><ol><li>保留每次需求汇总分支，示例：<code>feature/&#123;版本号&#125;</code>；</li><li>删除当次开发人员个人分支；</li></ol><h2 id="4-分支创建记录管理示例"><a href="#4-分支创建记录管理示例" class="headerlink" title="4. 分支创建记录管理示例"></a>4. 分支创建记录管理示例</h2><table><thead><tr><th align="center">版本</th><th align="left">需求概述</th><th align="left">创建日期</th><th align="center">编辑人</th></tr></thead><tbody><tr><td align="center"><a href="https://walkerdenial.com/">20210614</a></td><td align="left">1. 需求 1<br/>2.  需求 2<br/>3.  需求 3</td><td align="left">2021-06-17</td><td align="center">Jack</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> 其他 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 版本 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>代码规范</title>
      <link href="/2021/08/05/%E5%89%8D%E7%AB%AF/%E5%89%8D%E7%AB%AF%E4%BB%A3%E7%A0%81%E8%A7%84%E8%8C%83/"/>
      <url>/2021/08/05/%E5%89%8D%E7%AB%AF/%E5%89%8D%E7%AB%AF%E4%BB%A3%E7%A0%81%E8%A7%84%E8%8C%83/</url>
      
        <content type="html"><![CDATA[<h1 id="前端代码规范"><a href="#前端代码规范" class="headerlink" title="前端代码规范"></a>前端代码规范</h1><h2 id="1-import-顺序"><a href="#1-import-顺序" class="headerlink" title="1. import 顺序"></a>1. import 顺序</h2><p>不推荐:</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">React</span>, &#123; useEffect, useState, useRef &#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; saleRefund &#125; <span class="keyword">from</span> <span class="string">&#x27;@/services/api&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">PageContainer</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;@ant-design/pro-layout&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> type &#123; <span class="title class_">ProColumns</span>, <span class="title class_">ActionType</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;@ant-design/pro-table&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="title class_">ProTable</span> <span class="keyword">from</span> <span class="string">&#x27;@ant-design/pro-table&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="title class_">SellMode</span> <span class="keyword">from</span> <span class="string">&#x27;./components/SellMode&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="title class_">ViewDetails</span> <span class="keyword">from</span> <span class="string">&#x27;./components/viewDetails&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="title class_">BillingMsg</span> <span class="keyword">from</span> <span class="string">&#x27;./components/billingMsg&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="title class_">RefundMsg</span> <span class="keyword">from</span> <span class="string">&#x27;./components/refundMsg&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="title class_">Tab</span> <span class="keyword">from</span> <span class="string">&#x27;@/assets/images/tab.png&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; formatTime &#125; <span class="keyword">from</span> <span class="string">&#x27;@/utils/utils&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; getListActiveVersion &#125; <span class="keyword">from</span> <span class="string">&#x27;./utils/index&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; showErrorMessage &#125; <span class="keyword">from</span> <span class="string">&#x27;@/mamagement/Notification&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> styles <span class="keyword">from</span> <span class="string">&quot;./index.less&quot;</span>;</span><br></pre></td></tr></table></figure><p>推荐：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// node_modules</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">React</span>, &#123; useEffect, useState, useRef &#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">PageContainer</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;@ant-design/pro-layout&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> type &#123; <span class="title class_">ProColumns</span>, <span class="title class_">ActionType</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;@ant-design/pro-table&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="title class_">ProTable</span> <span class="keyword">from</span> <span class="string">&#x27;@ant-design/pro-table&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 项目公共模块</span></span><br><span class="line"><span class="keyword">import</span> &#123; formatTime &#125; <span class="keyword">from</span> <span class="string">&#x27;@/utils/utils&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; showErrorMessage &#125; <span class="keyword">from</span> <span class="string">&#x27;@/mamagement/Notification&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; saleRefund &#125; <span class="keyword">from</span> <span class="string">&#x27;@/services/api&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当前业务耦合模块</span></span><br><span class="line"><span class="keyword">import</span> &#123; getListActiveVersion &#125; <span class="keyword">from</span> <span class="string">&#x27;./utils/index&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="title class_">SellMode</span> <span class="keyword">from</span> <span class="string">&#x27;./components/SellMode&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="title class_">ViewDetails</span> <span class="keyword">from</span> <span class="string">&#x27;./components/viewDetails&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="title class_">BillingMsg</span> <span class="keyword">from</span> <span class="string">&#x27;./components/billingMsg&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="title class_">RefundMsg</span> <span class="keyword">from</span> <span class="string">&#x27;./components/refundMsg&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 图片、字体等资源</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">Tab</span> <span class="keyword">from</span> <span class="string">&#x27;@/assets/images/tab.png&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 样式文件</span></span><br><span class="line"><span class="keyword">import</span> styles <span class="keyword">from</span> <span class="string">&quot;./index.less&quot;</span>;</span><br></pre></td></tr></table></figure><p>在规范前的引入是无序的，一个文件可能会很乱，但是当你打开大量文件时候，尝试找到一个特定的包真的很难。</p><p>使用规范之后的方式对导入的包进行分组，通过 <strong>空格行分割</strong> 每个模块。又因为所有文件将保持一致，就可以删除注释了。</p><h2 id="2-尽可能使用解构"><a href="#2-尽可能使用解构" class="headerlink" title="2. 尽可能使用解构"></a>2. 尽可能使用解构</h2><p>防止不必要的嵌套和重复（将对象的属性值保存为局部变量）。</p><ol><li>对象成员嵌套越深，读取速度也就越慢。所以好的经验法则是：如果在函数中需要 <strong>多次</strong> 读取一个对象属性，最佳做法是将该属性值保存在局部变量中，避免多次查找带来的性能开销（对象变量避免嵌套过深）</li><li>函数参数越少越好，如果参数超过两个，要使用 ES6 的解构语法，这样就不用考虑参数的顺序了</li><li>使用参数默认值 替代使用条件语句进行赋值</li></ol><p>不推荐:</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">Page</span> = (<span class="params">deliveryCompany, carrierName, driverInfo, driverInfo</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">        <span class="language-xml"><span class="tag">&lt;<span class="name">Descriptions.Item</span> <span class="attr">label</span>=<span class="string">&quot;供应商&quot;</span>&gt;</span>&#123;deliveryCompany || &#x27;未知&#x27;&#125;<span class="tag">&lt;/<span class="name">Descriptions.Item</span>&gt;</span></span></span><br><span class="line">        <span class="language-xml"><span class="tag">&lt;<span class="name">Descriptions.Item</span> <span class="attr">label</span>=<span class="string">&quot;承运商&quot;</span>&gt;</span>&#123;carrierName || &#x27;未知&#x27;&#125;<span class="tag">&lt;/<span class="name">Descriptions.Item</span>&gt;</span></span></span><br><span class="line">        <span class="language-xml"><span class="tag">&lt;<span class="name">Descriptions.Item</span> <span class="attr">label</span>=<span class="string">&quot;司机&quot;</span>&gt;</span>&#123;driverInfo.driver || &#x27;未知&#x27;&#125;<span class="tag">&lt;/<span class="name">Descriptions.Item</span>&gt;</span></span></span><br><span class="line">        <span class="language-xml"><span class="tag">&lt;<span class="name">Descriptions.Item</span> <span class="attr">label</span>=<span class="string">&quot;联系方式&quot;</span>&gt;</span>&#123;driverInfo.contact || &#x27;未知&#x27;&#125;<span class="tag">&lt;/<span class="name">Descriptions.Item</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>推荐:</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> defaultValue = <span class="string">&#x27;未知&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="title function_">Page</span> = dataDetail =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> &#123;</span><br><span class="line">    deliveryCompany = defaultValue,</span><br><span class="line">    carrierName = defaultValue,</span><br><span class="line">    driverInfo = &#123; <span class="attr">driver</span>: defaultValue, <span class="attr">contact</span>: defaultValue &#125;,</span><br><span class="line">  &#125; = props;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> &#123; driver, contact &#125; = driverInfo;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">        <span class="language-xml"><span class="tag">&lt;<span class="name">Descriptions.Item</span> <span class="attr">label</span>=<span class="string">&quot;供应商&quot;</span>&gt;</span>&#123;deliveryCompany&#125;<span class="tag">&lt;/<span class="name">Descriptions.Item</span>&gt;</span></span></span><br><span class="line">        <span class="language-xml"><span class="tag">&lt;<span class="name">Descriptions.Item</span> <span class="attr">label</span>=<span class="string">&quot;承运商&quot;</span>&gt;</span>&#123;carrierName&#125;<span class="tag">&lt;/<span class="name">Descriptions.Item</span>&gt;</span></span></span><br><span class="line">        <span class="language-xml"><span class="tag">&lt;<span class="name">Descriptions.Item</span> <span class="attr">label</span>=<span class="string">&quot;司机&quot;</span>&gt;</span>&#123;driver&#125;<span class="tag">&lt;/<span class="name">Descriptions.Item</span>&gt;</span></span></span><br><span class="line">        <span class="language-xml"><span class="tag">&lt;<span class="name">Descriptions.Item</span> <span class="attr">label</span>=<span class="string">&quot;联系方式&quot;</span>&gt;</span>&#123;contact&#125;<span class="tag">&lt;/<span class="name">Descriptions.Item</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-变量和方法的命名约定"><a href="#3-变量和方法的命名约定" class="headerlink" title="3. 变量和方法的命名约定"></a>3. 变量和方法的命名约定</h2><p>关于代码，有一点很重要，就是要知道一个方法将返回什么，或者通过变量名轻松理解变量的含义（变量语义化），比如：</p><ol><li>JS 采用 <strong>Camel Case 小驼峰式</strong> 命名</li><li>避免名称冗余，保证语义明确</li><li>每个常量都需要有意义的变量名（不然看代码的人不知道这个常量表示什么意思）</li></ol><table><thead><tr><th align="center">动词</th><th align="left">含义</th></tr></thead><tbody><tr><td align="center">can</td><td align="left">判断是否可执行某个动作</td></tr><tr><td align="center">has</td><td align="left">判断是否含有某个值</td></tr><tr><td align="center">is</td><td align="left">判断是否为某个值</td></tr><tr><td align="center">get</td><td align="left">获取某个值</td></tr><tr><td align="center">set</td><td align="left">设置某个值</td></tr></tbody></table><p>不推荐:</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title class_">User</span>.<span class="property">cat</span> = <span class="literal">true</span>;</span><br><span class="line"><span class="title class_">User</span>.<span class="property">admin</span> = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">NewUser</span>(<span class="params">age</span>) &#123;</span><br><span class="line">  <span class="title class_">User</span>.<span class="property">age</span> = <span class="number">150</span> - age;</span><br><span class="line">  <span class="keyword">return</span> <span class="title class_">User</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">add_photo</span>(<span class="params">photo</span>) &#123;</span><br><span class="line">  <span class="title class_">User</span>.<span class="property">photo</span> = photo;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>推荐:</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> user = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">user.<span class="property">hasCat</span> = <span class="literal">true</span>;</span><br><span class="line"><span class="title class_">User</span>.<span class="property">isAdmin</span> = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> maxAge = <span class="number">150</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">getUser</span>(<span class="params">age</span>) &#123;</span><br><span class="line">  <span class="title class_">User</span>.<span class="property">age</span> = maxAge - age;</span><br><span class="line">  <span class="keyword">return</span> <span class="title class_">User</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">setUserPhoto</span>(<span class="params">photo</span>) &#123;</span><br><span class="line">  <span class="title class_">User</span>.<span class="property">photo</span> = photo;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为了命名变量和方法保持一致性，在以下方面保持一致：</p><ol><li>对于布尔类型使用：is, has,should 做前缀</li><li>对于方法使用 get&#x2F;set 做前缀</li><li>变量和方法都使用驼峰命名</li><li>使用 ES6 的 const 定义常量</li></ol><h2 id="4-删除弃用代码"><a href="#4-删除弃用代码" class="headerlink" title="4. 删除弃用代码"></a>4. 删除弃用代码</h2><p>很多时候有些代码已经没有用了，但是没有及时去删除，这样导致代码里面包括很多注释的代码块，好的习惯是提交代码前记得删除已经确认弃用的代码。</p><p>不推荐:</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// queryUserInfo();</span></span><br><span class="line"><span class="title function_">newQueryUserInfo</span>();</span><br></pre></td></tr></table></figure><p>推荐:</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title function_">newQueryUserInfo</span>();</span><br></pre></td></tr></table></figure><h2 id="5-保持必要的注释"><a href="#5-保持必要的注释" class="headerlink" title="5. 保持必要的注释"></a>5. 保持必要的注释</h2><p>代码注释不是越多越好，保持必要的业务逻辑注释，至于函数的用途、代码逻辑等，要通过语义化的命令、简单明了的代码逻辑，来让阅读代码的人快速看懂。</p><h2 id="6-遵守-Hooks-规则"><a href="#6-遵守-Hooks-规则" class="headerlink" title="6. 遵守 Hooks 规则"></a>6. 遵守 Hooks 规则</h2><p>不要在 <strong>循环</strong>、<strong>条件</strong> 和 <strong>嵌套函数</strong> 内调用 Hooks。当你想有条件地使用某些 Hooks 时，请在这些 Hooks 中写入条件。</p><p>不推荐:</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (name !== <span class="string">&quot;&quot;</span>) &#123;</span><br><span class="line">  <span class="title function_">useEffect</span>(<span class="keyword">function</span> <span class="title function_">persistForm</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">localStorage</span>.<span class="title function_">setItem</span>(<span class="string">&quot;formData&quot;</span>, name);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>推荐:</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title function_">useEffect</span>(<span class="keyword">function</span> <span class="title function_">persistForm</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (name !== <span class="string">&quot;&quot;</span>) &#123;</span><br><span class="line">    <span class="variable language_">localStorage</span>.<span class="title function_">setItem</span>(<span class="string">&quot;formData&quot;</span>, name);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="7-使用-useContext-避免-prop-drilling"><a href="#7-使用-useContext-避免-prop-drilling" class="headerlink" title="7. 使用 useContext 避免 prop drilling"></a>7. 使用 useContext 避免 prop drilling</h2><p>prop-drilling 是 React 应用程序中的常见问题，指的是将数据从一个父组件向下传递，经过各层组，直到到达指定的子组件，而其他嵌套组件实际上并不需要它们。 React Context 是一项功能，它提供了一种通过组件树向下传递数据的方法，这种方法无需在组件之间手动传 props。父组件中定义的 React Context 的值可由其子级通过 useContext Hook 访问。</p><h3 id="7-1-组件声明"><a href="#7-1-组件声明" class="headerlink" title="7.1 组件声明"></a>7.1 组件声明</h3><p>组件名称和定义该组件的文件名称建议要保持一致。</p><p>不推荐:</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">FooterComponent</span> <span class="keyword">from</span> <span class="string">&quot;./FooterComponent/index&quot;</span>;</span><br></pre></td></tr></table></figure><p>推荐:</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">Footer</span> <span class="keyword">from</span> <span class="string">&quot;./Footer/index&quot;</span>;</span><br></pre></td></tr></table></figure><h3 id="7-2-React-中的命名"><a href="#7-2-React-中的命名" class="headerlink" title="7.2 React  中的命名"></a>7.2 React  中的命名</h3><ol><li><strong>组件名称</strong>： 推荐使用大驼峰命名;</li><li><strong>属性名称</strong>： React DOM 使用小驼峰命令来定义属性的名称，而不使用 HTML 属性名称的命名约定；</li><li><strong>style 样式属性</strong>： 采用小驼峰命名属性的 JavaScript 对象；</li></ol><p>不推荐:</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 组件名称</span></span><br><span class="line">myComponent;</span><br><span class="line"><span class="comment">// 属性名称</span></span><br><span class="line">onclick;</span><br><span class="line"><span class="comment">// 样式属性</span></span><br><span class="line">backgroundcolor;</span><br></pre></td></tr></table></figure><p>推荐:</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 组件名称</span></span><br><span class="line"><span class="title class_">MyComponent</span>;</span><br><span class="line"><span class="comment">// 属性名称</span></span><br><span class="line">onClick;</span><br><span class="line"><span class="comment">// 样式属性</span></span><br><span class="line">backgroundColor;</span><br></pre></td></tr></table></figure><h3 id="7-3-对齐"><a href="#7-3-对齐" class="headerlink" title="7.3 对齐"></a>7.3 对齐</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 推荐</span></span><br><span class="line">&lt;<span class="title class_">Foo</span></span><br><span class="line">  superLongParam=<span class="string">&quot;bar&quot;</span></span><br><span class="line">  anotherSuperLongParam=<span class="string">&quot;baz&quot;</span></span><br><span class="line">/&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果组件的属性可以放在一行（一个属性时）就保持在当前一行中</span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">Foo</span> <span class="attr">bar</span>=<span class="string">&quot;bar&quot;</span> /&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 多行属性采用缩进</span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">Foo</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">  <span class="attr">superLongParam</span>=<span class="string">&quot;bar&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">  <span class="attr">anotherSuperLongParam</span>=<span class="string">&quot;baz&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;<span class="name">Quux</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">Foo</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 不推荐</span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">Foo</span> <span class="attr">superLongParam</span>=<span class="string">&quot;bar&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">     <span class="attr">anotherSuperLongParam</span>=<span class="string">&quot;baz&quot;</span> /&gt;</span></span></span><br></pre></td></tr></table></figure><h3 id="7-4-引号"><a href="#7-4-引号" class="headerlink" title="7.4 引号"></a>7.4 引号</h3><p>JSX 的 <strong>属性</strong> 都采用 <strong>双引号</strong>，其他的 JS 都使用 <strong>单引号</strong> ，因为 JSX 属性不能包含转义的引号, 所以当输入 “don’t” 这类的缩写的时候用双引号会更方便。</p><p>不推荐:</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;<span class="title class_">Foo</span> bar=<span class="string">&#x27;bar&#x27;</span> /&gt;</span><br><span class="line"></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">Foo</span> <span class="attr">style</span>=<span class="string">&#123;&#123;</span> <span class="attr">left:</span> &quot;<span class="attr">20px</span>&quot; &#125;&#125; /&gt;</span></span></span><br></pre></td></tr></table></figure><p>推荐:</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;<span class="title class_">Foo</span> bar=<span class="string">&quot;bar&quot;</span> /&gt;</span><br><span class="line"></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">Foo</span> <span class="attr">style</span>=<span class="string">&#123;&#123;</span> <span class="attr">left:</span> &#x27;<span class="attr">20px</span>&#x27; &#125;&#125; /&gt;</span></span></span><br></pre></td></tr></table></figure><h3 id="7-5-为你的组件接收公共变量做好准备"><a href="#7-5-为你的组件接收公共变量做好准备" class="headerlink" title="7.5 为你的组件接收公共变量做好准备"></a>7.5 为你的组件接收公共变量做好准备</h3><p>不推荐:</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">UserInfo</span> = (<span class="params">props</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; name, gender, age &#125; = props;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">div</span>&gt;</span>姓名:&#123;name&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">div</span>&gt;</span>性别:&#123;gender&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">div</span>&gt;</span>年龄:&#123;age&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>推荐:</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">UserInfo</span> = (<span class="params">props</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; name, gender, age, ...rest &#125; = props;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> &#123;<span class="attr">...rest</span>&#125;&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">div</span>&gt;</span>姓名:&#123;name&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">div</span>&gt;</span>性别:&#123;gender&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">div</span>&gt;</span>年龄:&#123;age&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="7-6-组件遵循单一职责原则"><a href="#7-6-组件遵循单一职责原则" class="headerlink" title="7.6 组件遵循单一职责原则"></a>7.6 组件遵循单一职责原则</h3><p>组件遵循单一职责原则（Single Responsibility Principle）可以让你轻松创建和贡献代码，并保持代码库的整洁。即容器组件与傻瓜组件。</p><ol><li>容器组件负责数据的请求与获取，props&#x2F;state 的更新</li><li>傻瓜组件只负责接收 props，抛出事件</li></ol><h2 id="8-使用类型检查器"><a href="#8-使用类型检查器" class="headerlink" title="8. 使用类型检查器"></a>8. 使用类型检查器</h2><p>不推荐:</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">UserInfo</span> = (<span class="params">props</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; name, gender, age &#125; = props;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">div</span>&gt;</span>姓名:&#123;name&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">div</span>&gt;</span>性别:&#123;gender&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">div</span>&gt;</span>年龄:&#123;age&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>推荐:</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">interface <span class="title class_">UserInfoProps</span> = &#123;</span><br><span class="line"><span class="attr">name</span>: string;</span><br><span class="line"><span class="attr">gender</span>: string;</span><br><span class="line"><span class="attr">age</span>: number;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">UserInfo</span> = (<span class="params">props: UserInfoProps</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; name, gender, age &#125; = props;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">div</span>&gt;</span>姓名:&#123;name&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">div</span>&gt;</span>性别:&#123;gender&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">div</span>&gt;</span>年龄:&#123;age&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="9-为组件绑定事件处理器"><a href="#9-为组件绑定事件处理器" class="headerlink" title="9. 为组件绑定事件处理器"></a>9. 为组件绑定事件处理器</h2><p>React 为组件绑定事件处理器提供 4 种方法，有 public class fields 语法、构造函数中进行绑定、在回调中使用箭头函数、使用 Function.prototype.bind 进行绑定，我们推荐 <strong>使用 public class fields 语法</strong>，在不满足需求情况下使用箭头函数的写法（传递参数给事件处理器）。</p><p>不推荐:</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title function_">constructor</span>(<span class="params">props</span>) &#123;</span><br><span class="line">   <span class="variable language_">super</span>(props);</span><br><span class="line">   <span class="variable language_">this</span>.<span class="property">handleClick</span> = <span class="variable language_">this</span>.<span class="property">handleClick</span>.<span class="title function_">bind</span>(<span class="variable language_">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">handleClick</span>(<span class="params"></span>)&#123;</span><br><span class="line">   <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;this is:&#x27;</span>, <span class="variable language_">this</span>);</span><br><span class="line">&#125;</span><br><span class="line">&lt;button onClick=&#123;<span class="variable language_">this</span>.<span class="property">handleClick</span>&#125;&gt; <span class="title class_">Click</span> me &lt;/button&gt;</span><br></pre></td></tr></table></figure><p>推荐:</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">handleClick = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">   <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;this is:&#x27;</span>, <span class="variable language_">this</span>);</span><br><span class="line">&#125;</span><br><span class="line">&lt;button onClick=&#123;<span class="variable language_">this</span>.<span class="property">handleClick</span>&#125;&gt; <span class="title class_">Click</span> me &lt;/button&gt;</span><br></pre></td></tr></table></figure><h2 id="10-使用参数默认值"><a href="#10-使用参数默认值" class="headerlink" title="10. 使用参数默认值"></a>10. 使用参数默认值</h2><p>使用参数默认值 替代 使用条件语句进行赋值。</p><p>不推荐:</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">createMicrobrewery</span>(<span class="params">name</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> breweryName = name || <span class="string">&quot;Hipster Brew Co.&quot;</span>;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>推荐:</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">createMicrobrewery</span>(<span class="params">name = <span class="string">&quot;Hipster Brew Co.&quot;</span></span>) &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="11-不要写全局方法"><a href="#11-不要写全局方法" class="headerlink" title="11. 不要写全局方法"></a>11. 不要写全局方法</h2><p>不推荐:</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">diff</span> = <span class="keyword">function</span> <span class="title function_">diff</span>(<span class="params">comparisonArray</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> hash = <span class="keyword">new</span> <span class="title class_">Set</span>(comparisonArray);</span><br><span class="line">  <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="title function_">filter</span>(<span class="function"><span class="params">elem</span> =&gt;</span> !hash.<span class="title function_">has</span>(elem));</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>推荐:</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SuperArray</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Array</span> &#123;</span><br><span class="line">  <span class="title function_">diff</span>(<span class="params">comparisonArray</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> hash = <span class="keyword">new</span> <span class="title class_">Set</span>(comparisonArray);</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="title function_">filter</span>(<span class="function"><span class="params">elem</span> =&gt;</span> !hash.<span class="title function_">has</span>(elem));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="12-页面跳转数据传递"><a href="#12-页面跳转数据传递" class="headerlink" title="12. 页面跳转数据传递"></a>12. 页面跳转数据传递</h2><p>页面跳转，例如 A 页面跳转到 B 页面，需要将 A 页面的数据传递到 B 页面，推荐使用 <strong>路由参数</strong> 进行传参，而不是将需要传递的数据保存内存，然后在 B 页面取出内存的数据，因为如果在 B 页面刷新会导致内存数据丢失，导致 B 页面无法正常显示数据。</p><h1 id="相关三方工具参考内容"><a href="#相关三方工具参考内容" class="headerlink" title="相关三方工具参考内容"></a>相关三方工具参考内容</h1><table><thead><tr><th align="center">名称</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center"><a href="http://eslint.cn/docs/rules/">ESLint</a></td><td align="center">ESLint 是一个开源的 JavaScript 代码检查工具，由 Nicholas C. Zakas 于2013年6月创建。代码检查是一种静态的分析，常用于寻找有问题的模式或者代码，并且不依赖于具体的编码风格。对大多数编程语言来说都会有代码检查，一般来说编译程序会内置检查工具。</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> 代码规范 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>排版指北</title>
      <link href="/2021/08/04/%E5%86%99%E4%BD%9C/%E6%8E%92%E7%89%88%E6%8C%87%E5%8C%97/"/>
      <url>/2021/08/04/%E5%86%99%E4%BD%9C/%E6%8E%92%E7%89%88%E6%8C%87%E5%8C%97/</url>
      
        <content type="html"><![CDATA[<p>一篇语句通顺、排版美观的文章可以提升读者的阅读体验，让人有赏心悦目之感。</p><h1 id="1-空格"><a href="#1-空格" class="headerlink" title="1 空格"></a>1 空格</h1><h2 id="1-1-中英文之间需要增加空格"><a href="#1-1-中英文之间需要增加空格" class="headerlink" title="1.1 中英文之间需要增加空格"></a>1.1 中英文之间需要增加空格</h2><p>正确：</p><blockquote><p>在 LeanCloud 上，数据存储是围绕 <code>AVObject</code> 进行的。</p></blockquote><p>错误：</p><blockquote><p>在LeanCloud上，数据存储是围绕<code>AVObject</code>进行的。</p></blockquote><p>例外：</p><blockquote><p>「豆瓣FM」等产品名词，按照官方所定义的格式书写。</p></blockquote><h2 id="1-2-中文与数字之间需要增加空格"><a href="#1-2-中文与数字之间需要增加空格" class="headerlink" title="1.2 中文与数字之间需要增加空格"></a>1.2 中文与数字之间需要增加空格</h2><p>正确：</p><blockquote><p>今天出去买菜花了 5000 元。</p></blockquote><p>错误：</p><blockquote><p> 今天出去买菜花了5000元。</p></blockquote><h2 id="1-3-数字与单位之间无需增加空格"><a href="#1-3-数字与单位之间无需增加空格" class="headerlink" title="1.3 数字与单位之间无需增加空格"></a>1.3 数字与单位之间无需增加空格</h2><p>正确：</p><blockquote><p>我家入户光纤宽带有 10Gbps，SSD 一共有 10TB。</p></blockquote><p>错误：</p><blockquote><p>我家入户光纤宽带有 10 Gbps，SSD 一共有 10 TB。</p></blockquote><p>另外，度 &#x2F; 百分比与数字之间不需要增加空格：</p><p>正确：</p><blockquote><p>今天是 36° 的高温。</p><p>新款 MBP 有 15% 的 CPU 性能提升。</p></blockquote><p>错误：</p><blockquote><p>今天是 36 ° 的高温。</p><p>新款 MBP 有 15 % 的 CPU 性能提升。</p></blockquote><h2 id="1-4-全角标点与其他字符之间不加空格"><a href="#1-4-全角标点与其他字符之间不加空格" class="headerlink" title="1.4 全角标点与其他字符之间不加空格"></a>1.4 全角标点与其他字符之间不加空格</h2><p>正确：</p><blockquote><p>刚刚买了部新 iPhone X，好开心。</p></blockquote><p>错误：</p><blockquote><p>刚刚买了部新 iPhone X ，好开心。</p></blockquote><h2 id="1-5-每段文字的开头不需要空两格"><a href="#1-5-每段文字的开头不需要空两格" class="headerlink" title="1.5 每段文字的开头不需要空两格"></a>1.5 每段文字的开头不需要空两格</h2><p>正确：</p><blockquote><p>我想表达的是什么呢？</p></blockquote><p>错误：</p><blockquote><p> &nbsp;&nbsp;我想表达的是什么呢？</p></blockquote><h1 id="2-标点符号"><a href="#2-标点符号" class="headerlink" title="2 标点符号"></a>2 标点符号</h1><h1 id="2-1-不重复使用标点符号"><a href="#2-1-不重复使用标点符号" class="headerlink" title="2.1 不重复使用标点符号"></a>2.1 不重复使用标点符号</h1><p>正确：</p><blockquote><p>德国队居然赢了！</p></blockquote><p>错误：</p><blockquote><p> 德国队居然赢了！！！</p></blockquote><h2 id="2-2-省略号请使用标准用法"><a href="#2-2-省略号请使用标准用法" class="headerlink" title="2.2 省略号请使用标准用法"></a>2.2 省略号请使用标准用法</h2><p>正确：</p><blockquote><p>……（中文输入法下：shift + 6）</p></blockquote><p>错误：</p><blockquote><p> …</p></blockquote><h1 id="3-全角和半角"><a href="#3-全角和半角" class="headerlink" title="3 全角和半角"></a>3 全角和半角</h1><h2 id="3-1-使用全角中文标点"><a href="#3-1-使用全角中文标点" class="headerlink" title="3.1 使用全角中文标点"></a>3.1 使用全角中文标点</h2><p>正确：</p><blockquote><p>嗨！你知道吗？</p></blockquote><p>错误：</p><blockquote><p> 嗨!你知道吗?</p></blockquote><h2 id="3-2-数字使用半角字符"><a href="#3-2-数字使用半角字符" class="headerlink" title="3.2 数字使用半角字符"></a>3.2 数字使用半角字符</h2><p>正确：</p><blockquote><p>这件蛋糕只卖 1000 元。</p></blockquote><p>错误：</p><blockquote><p>这件蛋糕只卖 𝟏 𝟎 𝟎 𝟎 元。</p></blockquote><p>例外：</p><blockquote><p>在设计稿、宣传海报中如出现少量数字的情形时，为方便文字对齐，是可以使用全角数字的。</p></blockquote><h2 id="3-3-遇到完整的英文整句、特殊名词，其内容使用半角标点"><a href="#3-3-遇到完整的英文整句、特殊名词，其内容使用半角标点" class="headerlink" title="3.3 遇到完整的英文整句、特殊名词，其内容使用半角标点"></a>3.3 遇到完整的英文整句、特殊名词，其内容使用半角标点</h2><p>正确：</p><blockquote><p>乔布斯那句话是怎么说的？「Stay hungry, stay foolish.」</p><p>推荐你阅读《Hackers &amp; Painters: Big Ideas from the Computer Age》，非常的有趣。</p></blockquote><p>错误：</p><blockquote><p>乔布斯那句话是怎么说的？「Stay hungry，stay foolish。」</p><p>推荐你阅读《Hackers &amp; Painters：Big Ideas from the Computer Age》，非常的有趣。</p></blockquote><h1 id="4-名词"><a href="#4-名词" class="headerlink" title="4 名词"></a>4 名词</h1><h2 id="4-1-专有名词使用正确的大小写"><a href="#4-1-专有名词使用正确的大小写" class="headerlink" title="4.1 专有名词使用正确的大小写"></a>4.1 专有名词使用正确的大小写</h2><p>大小写相关用法原属于英文书写范畴，这里只对部分易错用法进行简述。</p><p>正确：</p><blockquote><p>使用 GitHub 登录</p><p>我们的客户端有 GitHub、Foursquare、Microsoft Corporation、Google、Facebook, Inc.。</p></blockquote><p>错误：</p><blockquote><p>使用 github 登录</p><p>我们的客户端有 Github、foursquare、microsoft Corporation、google、facebook, Inc.。</p></blockquote><h2 id="4-2-不要使用不地道的缩写"><a href="#4-2-不要使用不地道的缩写" class="headerlink" title="4.2 不要使用不地道的缩写"></a>4.2 不要使用不地道的缩写</h2><p>正确：</p><blockquote><p>我们需要一位熟悉 JavaScript、HTML5，至少理解一种框架（如 Backbone.js、AngularJS、React 等）的前端开发者。</p></blockquote><p>错误：</p><blockquote><p>我们需要一位熟悉 Js、h5，至少理解一种框架（如 backbone、angular、RJS 等）的 FED。</p></blockquote><h1 id="5-其他"><a href="#5-其他" class="headerlink" title="5 其他"></a>5 其他</h1><h2 id="5-1-链接之间增加空格"><a href="#5-1-链接之间增加空格" class="headerlink" title="5.1 链接之间增加空格"></a>5.1 链接之间增加空格</h2><p>用法：</p><blockquote><p>欢迎访问 <a href="https://walkerdenial.com/">WalkerDenial</a> 的主页。</p></blockquote><p>对比用法：</p><blockquote><p>欢迎访问<a href="https://walkerdenial.com/">WalkerDenial</a>的主页。</p></blockquote><h2 id="5-2-简体中文使用直角引号"><a href="#5-2-简体中文使用直角引号" class="headerlink" title="5.2 简体中文使用直角引号"></a>5.2 简体中文使用直角引号</h2><p>用法：</p><blockquote><p>「老师，『有条不紊』的『紊』是什么意思？」</p></blockquote><p>对比用法：</p><blockquote><p>“老师，’有条不紊’的’紊’是什么意思？”</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 写作 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 排版 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基础知识</title>
      <link href="/2021/04/21/%E5%89%8D%E7%AB%AF/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
      <url>/2021/04/21/%E5%89%8D%E7%AB%AF/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</url>
      
        <content type="html"><![CDATA[<h1 id="基础数据类型"><a href="#基础数据类型" class="headerlink" title="基础数据类型"></a>基础数据类型</h1><ol><li>Number – 数字，双精度 64 位格式</li><li>String – 字符串</li><li>Boolean – 布尔</li><li>Symbol – 符号</li><li>null – 空</li><li>undefined – 未定义</li><li>Object – 对象<ol><li>Function – 函数</li><li>Array – 数组</li><li>Date – 日期</li><li>RegExp – 正则表达式</li></ol></li></ol><blockquote><p>Tip1: NaN + Number &#x3D; NaN</p><p>Tip2: Infinity&#x2F;-Infinity</p><p>Tip3: false、0、空字符串(“”)、NaN、null 和 undefined 被转换为 false</p></blockquote><h1 id="关键字说明"><a href="#关键字说明" class="headerlink" title="关键字说明"></a>关键字说明</h1><ol><li>let：仅限于块作用域，不可对同一名称二次声明；</li><li>var：可以是全局作用于，可以对同一名称二次声明；</li><li>const：let 的补充，相当于 final 类型，不可修改；</li></ol>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>文件系统</title>
      <link href="/2021/03/20/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/"/>
      <url>/2021/03/20/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/</url>
      
        <content type="html"><![CDATA[<p><img src="https://personal-blog.oss-cn-hangzhou.aliyuncs.com/OS_chapter_7.png"></p><h1 id="1-文件管理的基本概念"><a href="#1-文件管理的基本概念" class="headerlink" title="1 文件管理的基本概念"></a>1 文件管理的基本概念</h1><h2 id="1-1-文件管理的任务"><a href="#1-1-文件管理的任务" class="headerlink" title="1.1 文件管理的任务"></a>1.1 文件管理的任务</h2><p>研究文件系统有两种不同的观点，一种是用户的观点，另一种是操作系统的观点。</p><p>从用户的观点看文件系统，主要关系文件由什么组成，如何命名，如何保护文件，可以进行何种操作等等。</p><p>从操作系统的观点看文件系统，主要关心文件目录是怎样实现的，怎样管理存储空间，文件存储位置，磁盘实际运作方式（与设备管理的接口），存取速度，磁盘利用率等等。</p><p>什么是文件？在计算机系统中，程序或数据都可以是文件，但这是一种较为模糊的说法。文件可以被解释为一组带标识的、在逻辑上有完整意义的信息项的序列。这里所谓「标识」是指文件名，「信息项」构成了文件的内容。</p><p>所谓文件系统，是操作系统中统一管理信息资源的一种软件。它管理文件的存储、检索、更新，提供安全可靠的共享和保护手段，并且方便用户使用。</p><p>作为一个统一的文件管理机构，文件系统应具有下述功能：</p><ol><li>统一管理文件的存储空间，试试存储空间的分配与回收；</li><li>实现文件从名字空间到外存地址空间的映射。即实现文件的按名称存取，以对用户透明的方式管理名字空间；</li><li>实现文件信息的共享，并提供文件的保护和保密措施；</li><li>向用户提供一个方便使用的接口（提供对文件系统操作命令，以及提供对文件的操作命令：信息存取、加工等）；</li><li>系统维护及向用户提供有关信息；</li><li>保持文件系统的执行效率。文件系统在操作系统接口中占的比例最大，用户使用操作系统的感觉在很大程度上取决于对文件系统的使用效果；</li><li>提供与 I&#x2F;O 的统一接口；</li></ol><h2 id="1-2-文件的存储介质及存取方式"><a href="#1-2-文件的存储介质及存取方式" class="headerlink" title="1.2 文件的存储介质及存取方式"></a>1.2 文件的存储介质及存取方式</h2><p>文件系统是建立在大容量外存设备上的，因此文件的组织方式与存储介质存在千丝万缕的联系，没有存储设备，就没有文件系统。</p><p>常见的外存储设备有一下几种介质：</p><ol><li>磁带；</li><li>磁盘：分为硬盘和软盘，软盘由于存储容量小，易磨损，保存不便已经被淘汰，磁盘由于其存储容量大以及成本低而得到广泛应用；</li><li>光盘；</li><li>闪存；</li></ol><p>文件常用的存取方法有：</p><ol><li>顺序存取：按从前到后的次序依次访问文件的各个信息项；</li><li>随机存取：又称直接存取，即允许用户按任意的次序、直接存取文件中的任意一个记录，或者根据存取命令把读写指针移到文件中的指定记录处读写；</li></ol><h2 id="1-3-文件的分类"><a href="#1-3-文件的分类" class="headerlink" title="1.3 文件的分类"></a>1.3 文件的分类</h2><h3 id="1-3-1-按文件的用途分类"><a href="#1-3-1-按文件的用途分类" class="headerlink" title="1.3.1 按文件的用途分类"></a>1.3.1 按文件的用途分类</h3><ol><li>系统文件：操作系统和各种系统应用程序和数据所组成的文件；</li><li>库函数文件：标准子程序及常用应用程序组成的文件允许用户对其进行读取、执行，但不允许对其进行修改；</li><li>用户文件：用户委托文件系统保存的文件；</li></ol><h3 id="1-3-2-按文件的组织形式分类"><a href="#1-3-2-按文件的组织形式分类" class="headerlink" title="1.3.2 按文件的组织形式分类"></a>1.3.2 按文件的组织形式分类</h3><ol><li>普通文件：主要指文件的组织格式为文件系统中所规定的最一般格式的文件，文件的内容是一般的数据或程序，例如由字符流组成的文件。普通文件既包括系统文件，也包括用户文件、库函数文件和用户实用程序文件等；</li><li>目录文件：由文件的目录构成的特殊文件；</li><li>特殊文件：以文件形成存在和访问的设备，可进行查找目录等操作，但对文件的读写会对应于对设备的读写，并由设备驱动程序来完成具体的读写操作；</li></ol><h3 id="1-3-3-一些常见的文件分类方式"><a href="#1-3-3-一些常见的文件分类方式" class="headerlink" title="1.3.3 一些常见的文件分类方式"></a>1.3.3 一些常见的文件分类方式</h3><p>按文件的保护方式：</p><ol><li>只读文件；</li><li>读写文件；</li><li>可执行文件；</li><li>无保护文件；</li></ol><p>按信息的流向分类：</p><ol><li>输入文件；</li><li>输出文件；</li><li>输入输出文件；</li></ol><p>按文件的存放时间可划分为：</p><ol><li>临时文件；</li><li>永久文件；</li><li>档案文件；</li></ol><p>按文件所使用的介质类型分类：</p><ol><li>磁盘文件；</li><li>磁带文件；</li><li>卡片文件；</li><li>打印文件；</li></ol><p>按文件的组织结构分类：</p><ol><li>逻辑文件；</li><li>物理文件；</li><li>顺序文件；</li><li>链接文件；</li><li>索引文件；</li></ol><h3 id="1-3-4-UNIX-类操作系统中文件的分类"><a href="#1-3-4-UNIX-类操作系统中文件的分类" class="headerlink" title="1.3.4 UNIX 类操作系统中文件的分类"></a>1.3.4 UNIX 类操作系统中文件的分类</h3><ol><li>普通文件：内部无结构的一串平滑的字符所组成的文件；</li><li>目录文件：由文件目录项所构成的文件；</li><li>特殊文件：在 UNIX 类操作系统中，把 I&#x2F;O 设备也看成是一种文件 — 特殊文件；</li></ol><p>上述种种文件系统的分类，其目的是：</p><ol><li>对不同文件进行管理，提高系统效率；</li><li>提高文件系统的用户界面友好性；</li></ol><h1 id="2-文件的逻辑结构和物理结构"><a href="#2-文件的逻辑结构和物理结构" class="headerlink" title="2 文件的逻辑结构和物理结构"></a>2 文件的逻辑结构和物理结构</h1><p>任何一种文件都有其内在的文件结构。用户看到的是经过抽象的文件结构，这就是文件的逻辑结构。实际上，文件的逻辑结构就是从用户角度看文件，研究文件的组织形式。</p><p>除了文件的逻辑结构，文件还有其物理结构，也就是文件子啊实际的存储空间存储时的结构。</p><h2 id="2-1-文件的逻辑结构"><a href="#2-1-文件的逻辑结构" class="headerlink" title="2.1 文件的逻辑结构"></a>2.1 文件的逻辑结构</h2><p>文件的逻辑结构是面向用户的文件的组织结构，是用户看到的文件的组织结构。操作系统在设计时需要掌握如下原则。</p><h3 id="2-1-1-设计文件逻辑结构的原则"><a href="#2-1-1-设计文件逻辑结构的原则" class="headerlink" title="2.1.1 设计文件逻辑结构的原则"></a>2.1.1 设计文件逻辑结构的原则</h3><p>与文件的逻辑结构相联系的是逻辑文件的存取方式，即用户如何访问文件。</p><ol><li>易于操作：用户对文件的操作是经常的，而且是大量的。因此，文件系统提供给用户的对文件的操作手段应当方便，用户易学易用；</li><li>查找快捷：用户经常需要进行对文件的查找或对文件内信息的查找，设计的文件逻辑结构应便于在尽可能短时间内完成查找；</li><li>修改方便：当用户需要对文件信息进行修改时，给定的逻辑结构应使文件系统尽可能少地变动文件中的记录或基本信息单位；</li><li>空间紧凑：应使文件的信息占据尽可能小的存储空间；</li></ol><p>显然，对于字符流的无结构文件来说，查找文件中的基本信息单位，例如某个单词，是比较困难的。但反过来，字符流的无结构文件管理简单，用户可以方便地对其进行操作。所以，对基本信息单位操作不多的文件较适于采用字符流的无结构形式，例如，源程序文件、目标代码文件等。</p><h3 id="2-1-2-文件的逻辑结构"><a href="#2-1-2-文件的逻辑结构" class="headerlink" title="2.1.2 文件的逻辑结构"></a>2.1.2 文件的逻辑结构</h3><p>文件的逻辑结构就是用户所看到的文件的组织形式。文件逻辑结构是一种经过抽象的结构，所描述的是文件中信息的组织形式，与文件在物理介质上的具体存储结构不同。</p><p>可以按逻辑结构把文件划分成三类：</p><ol><li>无结构的字符流式文件；</li><li>定长记录文件和不定长记录文件构成的记录树；</li></ol><p>定长记录文件和不定长记录文件可以统称为记录式文件。</p><p>下面介绍这些逻辑结构：</p><p><strong>1. 流式文件</strong></p><p>流式文件是有序字符的集合，其长度为该文件所包含的字符个数，所以又称为字符流文件。在流式文件中，构成文件的基本单位是字符。</p><p>可以任务流式文件就是一串有开头和结尾的连续字符。在这串字符中，不存在任何可以视为结构的组织形式，所以可以说，流式文件无结构。</p><p><strong>2. 记录式文件</strong></p><p>记录式文件是一组有序记录的集合。在记录式文件中，构成文件的基本单位是记录。</p><p>记录是一个具有特定意义的信息单位，它由该记录在文件中的逻辑地址（相对位置）与记录名所对应的一组键、属性及其属性值所组成，可按键进行查找。</p><p>记录式文件可分定长记录文件和不定长记录文件两种。</p><p>在定长记录文件中，各个记录长度相等。在检索时，可以根据记录号 i 及记录长度 L 就可以确定该记录的逻辑地址。</p><p>在不定长记录文件汇总，各个记录的长度不等，在查找时，必须从第一个记录起一个记录一个记录地查找，直到找到所需的记录。</p><p>记录式的有结构文件可把文件中的记录按各种不同的方式排列，构成不同的逻辑结构，以便用户对文件中的记录进行修改、追加、查找和管理等操作。</p><h2 id="2-2-文件的物理结构"><a href="#2-2-文件的物理结构" class="headerlink" title="2.2 文件的物理结构"></a>2.2 文件的物理结构</h2><ol><li>顺序结构；</li><li>链接结构；</li><li>索引结构；</li></ol><h2 id="2-3-UNIX-的三级索引结构"><a href="#2-3-UNIX-的三级索引结构" class="headerlink" title="2.3 UNIX 的三级索引结构"></a>2.3 UNIX 的三级索引结构</h2><p>UNIX 操作系统的 i 结点是一种多级索引文件结构，是多级索引结构文件在 UNIX 中的具体实现。i 结点在一般多级索引结构文件的基础上，进行了结构上的变化，克服了索引结构的缺点。掌握了 i 结点也就掌握了多级索引文件结构的工作原理。</p><p>i 结点的基本思想是，给每个文件赋予一张称为 i 结点的小表，在这张小表中列出了文件属性和文件中各块在磁盘上的地址。</p><h1 id="3-文件目录的实现"><a href="#3-文件目录的实现" class="headerlink" title="3 文件目录的实现"></a>3 文件目录的实现</h1><h2 id="3-1-文件控制块"><a href="#3-1-文件控制块" class="headerlink" title="3.1 文件控制块"></a>3.1 文件控制块</h2><p>在操作系统中，为了管理大量的文件，为每个文件都设置一个描述性数据结构 — 文件控制块（FCB，File Control Block），把所有文件的文件控制块有机地组织起来，就构成了文件控制块的一个有序集合，称为文件目录。</p><p>文件目录实际就是文件符号名刀文件物理地址之间的一种映射机制。</p><p>文件控制块 FCB 是系统为管理文件而设置的一个数据结构。FCB 是文件存在的标志，它记录了系统管理文件所需要的全部信息。</p><p>在文件控制块中的信息可以分成文件存取控制信息、文件结构信息和文件管理信息。</p><p>FCB 通常应包括以下内容：</p><ol><li>文件名：用户给文件取的名称；</li><li>文件号：是系统在文件创建时所指定的一个编号，文件号唯一地标识一个文件，即在一个文件系统中，文件号是不重复的；</li><li>用户名：记录了该文件创建者的名称；</li><li>文件地址：记录了与文件在存储介质中的物理位置有关的信息；</li><li>文件长度：保存有该文件的长度；</li><li>文件类型：这与该文件系统的文件类型的划分方法有关；</li><li>文件属性：指出文件是只读式文件、可读写文件还是只可执行文件；</li><li>共享计数；</li><li>文件的建立日期；</li><li>保存期限：指预计该文件的保管时间；</li><li>最后修改日期；</li><li>最后访问日期；</li><li>口令：指为了文件的安全和文件信息的保密所设置的访问文件的密码；</li><li>文件逻辑结构：指出该文件是流式文件还是记录式文件；</li><li>文件物理结构：标识了该文件内部的物理结构是顺序结构、链接结构还是索引结构；</li></ol><h2 id="3-2-文件目录和当前目录"><a href="#3-2-文件目录和当前目录" class="headerlink" title="3.2 文件目录和当前目录"></a>3.2 文件目录和当前目录</h2><p>文件目录是实现用户按名存取文件的一种手段。在用户要求读一个文件时，系统便从文件目录中查找用户所指定文件是否存在，并核对是否有权使用。一个好的目录结构应该既能方便用户的检索，又能保证文件的安全。</p><p>文件数量较少时，在文件目录中朝招文件比较简单。在文件数量比较多时，文件目录的组织与管理的重要性就突出了。为了能够方便用户的检索和文件的管理，根据实际的需要，一般把文件目录设计成一级（单级）目录结构、二级目录结构和多级目录结构。</p><p>文件系统向用户提供了一个当前正在使用的目录，称为「当前目录」，又称「工作目录」。如果需要，用户可随意更改当前目录。</p><h2 id="3-3-目录项和目录文件"><a href="#3-3-目录项和目录文件" class="headerlink" title="3.3 目录项和目录文件"></a>3.3 目录项和目录文件</h2><p>目录项是用于管理目录的基本数据结构，一般而言是定长的记录。目录文件就是目录项的有序集合，通常可以保存到外存储设备上。</p><h3 id="3-3-1-目录项"><a href="#3-3-1-目录项" class="headerlink" title="3.3.1 目录项"></a>3.3.1 目录项</h3><p>当用户建立一个新文件时，与该文件有关的一些信息与属性记录在该文件的文件控制块内。为了便于管理，通常将文件控制块做成定长数据结构的一个记录，存储在目录文件中。而这样的每一个记录称为目录项。若文件控制块的数据量较大，还可以采用目录项分解法来进行存储，在目录项中存储重要的信息，其余信息存储子啊其他数据块中。</p><p>所以，一个目录项必定对应一个文件。</p><h3 id="3-3-2-目录文件"><a href="#3-3-2-目录文件" class="headerlink" title="3.3.2 目录文件"></a>3.3.2 目录文件</h3><p>多个文件的文件控制块集中在一起组成了文件的目录。通常，文件目录以文件形式保存起来，这个文件就被称为目录文件。目录文件是每项纪录长度固定的记录式文件。</p><p>在目录文件中，每一条定长的记录就是目录项。如果某个系统中的文件比较多，对应的目录文件显然也比较长。有时，为了节省内存的控件，就把目录文件保存在外存储器上，在需要时，才把目录文件调入内存。</p><h2 id="3-4-目录项分解法"><a href="#3-4-目录项分解法" class="headerlink" title="3.4 目录项分解法"></a>3.4 目录项分解法</h2><p>为了加快目录检索可采用目录项分解法，即把目录项（FCB）分为两部分，符号目录项（次部）和基本目录项（主部）。其中，符号目录项包含文件名以及相应的文件号；而基本目录项包含了除文件名外文件控制块的其他全部信息。</p><h2 id="3-5-UNIX-的文件目录实现"><a href="#3-5-UNIX-的文件目录实现" class="headerlink" title="3.5 UNIX 的文件目录实现"></a>3.5 UNIX 的文件目录实现</h2><p>UNIX 目录中为每个文件保留了一项，每个目录项包含了两个域，文件名（14 个字节）和 i 结点的编号（2 个字节）。</p><p>UNIX 的 i 结点包含一些属性。这些属性包括文件大小、三个时间（创建时间、最后访问时间，最后修改时间）、所有者、所在组、保护信息以及一个计数（用户记录指向 i 结点的目录项的数量）。最后一个域是为了连接而设的。当一个新的连接加到一个 i 结点上，i 结点里的计数就会加 1。当移走一个连接时，该计数就减 1。当计数为 0 时，就收回该 i 结点，并将对于的磁盘块放进空闲表。</p><p>UNIX 普通文件的物理结构是三级索引结构。</p><h2 id="3-6-FAT-文件系统的实现"><a href="#3-6-FAT-文件系统的实现" class="headerlink" title="3.6 FAT 文件系统的实现"></a>3.6 FAT 文件系统的实现</h2><p>FAT 是 File Allocation Table（文件分配表）的缩写。FAT 是一个简单的文件系统，最初为 DOS 操作系统设计，适用于小容量的磁盘，具有简单的目录结构。为了向后兼容，也为了方便用户升级，目前新版本的 Windows 仍然提供对 FAT 的支持。</p><p>文件分配表位于卷的开头，为了防止文件系统遭到破坏，FAT 文件系统保存了两个文件分配表，这样当其中一个遭到破坏时可以保护卷。此外，文件分配表和根目录必须存储在磁盘上一个固定的位置，这样才可以正确地找到启动系统所需要的文件。</p><p><strong>（1）引导扇区</strong></p><p>引导扇区（Boot Sector）包含用于描述卷的各种信息，利用这些信息才可以访问文件系统。</p><p><strong>（2）文件分配表</strong></p><p>文件分配表包含关于卷上每个簇的如下类型信息：</p><ol><li>未使用（0x0000）；</li><li>被文件所使用的的簇；</li><li>坏簇（0XFFF7）；</li><li>文件中的最后一簇（0XFFF8~0XFFFF）；</li></ol><p><strong>（3）根目录</strong></p><p>在 FAT16 文件系统中，位于根目录下的每个文件和子目录在根目录区中都包含一个目录项。根目录与其他目录之间唯一的区别是根目录位于磁盘上一个特殊的位置并且具有固定的大小。每个目录项的大小为 32 字节，其内容包括文件名、扩展名、属性字节、最后一次修改时间和日期、文件长度、第一簇的编号等。</p><h1 id="4-文件存储空间管理"><a href="#4-文件存储空间管理" class="headerlink" title="4 文件存储空间管理"></a>4 文件存储空间管理</h1><h2 id="4-1-磁盘空间管理"><a href="#4-1-磁盘空间管理" class="headerlink" title="4.1 磁盘空间管理"></a>4.1 磁盘空间管理</h2><p>在计算机系统中，存储空间是一种宝贵的资源。外存储设备中的空间容量虽然比较大，但也不是无限的，故对文件删除之后而不再使用的空间，必须加以回收，然后在建立文件等操作中重新利用。</p><p>对于制度的存储设备（如 CD-ROM 光盘），无所谓回收，也无所谓动态分配，这种存储设备在物理上就是不可重用的。</p><p>为了进行存储空间的分配与回收，在外存储设备上设置有空闲空间登记表，该表动态跟踪该外存储设备上所有还没有分配给任何文件的空闲块的数据和块号。</p><p>该空闲空间等级表虽然称为表，但不一定是以一个二维表格的形式实现。从方便、高效和安全的角度考虑，通常把空间空间登记表放在存储介质上。</p><p>对空闲空间表的访问与修改工作是经常发生的。在进行文件删除、文件建立、写文件等等操作中都会访问和修改空闲空间表。</p><h2 id="4-2-磁盘空间的分配回收算法"><a href="#4-2-磁盘空间的分配回收算法" class="headerlink" title="4.2 磁盘空间的分配回收算法"></a>4.2 磁盘空间的分配回收算法</h2><ol><li>位示图：利用一串二进制位（bit）的值来反映磁盘空间的分配使用情况。</li><li>空闲块表：专门为空闲块建立一张表，该表记录外存储器全部空闲的物理块：包括每个空闲块的第一个空闲物理块号和该空闲块中空闲物理块的个数。</li><li>空闲块链表：将外存储器中所有的空闲物理块连成一个链表，用一个空闲块首指针指向第一个空闲块，随后的每个空闲块中都含有指向下一个空闲块的指针，最后一块的指针为空，表示链尾，这样就构成了一个空闲块链表。</li></ol><h1 id="5-文件系统的实现"><a href="#5-文件系统的实现" class="headerlink" title="5 文件系统的实现"></a>5 文件系统的实现</h1><h2 id="5-1-系统打开文件表"><a href="#5-1-系统打开文件表" class="headerlink" title="5.1 系统打开文件表"></a>5.1 系统打开文件表</h2><p>系统打开文件表专门用于保存已打开文件的文件控制块，通常放在内存。除了保存已打开文件的文件控制块之外，在该表格中还保存了共享计数、修改标志灯信息。其中，由于允许多个进程同时打开同一个文件，所以共享计数标出有几个进程打开同一个文件；修改标志是指文件控制块或 i 结点的内容是否被修改过，如果修改过，则关闭文件时需要将文件控制块写回磁盘。</p><h2 id="5-2-用户打开文件表"><a href="#5-2-用户打开文件表" class="headerlink" title="5.2 用户打开文件表"></a>5.2 用户打开文件表</h2><p>每个进程都有一个「用户打开文件表」。以 UNIX 为例，该表的内容有文件描述符、打开方式、读写指针、系统打开文件表入口等。</p><p>另外在进程的进程控制块 PCB 中，还记录了「用户打开文件表」的位置。</p><h1 id="6-文件及文件目录的操作"><a href="#6-文件及文件目录的操作" class="headerlink" title="6 文件及文件目录的操作"></a>6 文件及文件目录的操作</h1><h2 id="6-1-典型的文件操作"><a href="#6-1-典型的文件操作" class="headerlink" title="6.1 典型的文件操作"></a>6.1 典型的文件操作</h2><p>文件系统是提供给用户使用的、用户可以进行按名存取所需要的文件。在文件系统的实现中，为用户提供使用文件的手段是文件系统的重要任务之一。下面介绍几个常用的进行文件操作的系统调用。</p><p><strong>1. 建立文件</strong></p><p>用户首先调用文件系统的「建立文件」操作，在请求调用该操作时，提供所要创建的文件的文件名及若干参数：用户名、文件名、存取方式、存储设备类型、记录格式、记录长度等。</p><p>系统依据用户提供的文件名及若干参数，为这一新创建的文件分配一个文件控制块，填写文件控制块中的有关项。</p><p>建立文件的实质是建立文件的文件控制块 FCB，并建立必要的存储空间，分配空的 FCB。从而建立起系统与文件的联系。</p><p><strong>2. 打开文件</strong></p><p>打开文件，是使用文件的第一步，任何一个文件使用前都要先打开，即把文件控制块 FCB 送到内存。</p><p>打开文件的系统调用的一般格式为空：fd &#x3D; open（文件路径名，打开方式）</p><p>打开文件时，系统主要完成以下工作：</p><ol><li>根据文件路径名查目录，找到 FCB 主部；</li><li>根据打开方式、共享说明和用户身份检查访问合法性；</li><li>根据文件号查系统打开文件表，看文件是否已被打开。如果是，共享计数加 1；否则，将外存中的 FCB 主部等信息填入系统打开文件表空表项，共享计数置为 1；</li><li>在用户打开文件表中取以空表项，填写打开方式等，并指向系统打开文件表对应表项；</li></ol><p>返回信息：fd：文件描述符，是一个非负整数，用于以后读写文件；</p><p><strong>3. 读文件</strong></p><p>打开文件后，就可以读取文件中的信息。</p><p>读文件系统调用的一般格式为：read（文件名，（文件内位置），要读的长度，内存目的地址）。</p><p>隐含参数：文件主。</p><p>读写方式可为读、写和既读又写等。</p><p>读文件时，系统主要完成以下工作：</p><ol><li>检查长度是否问正整数：若是，进行下一步 2)，否则，转向 10)；</li><li>根据文件名查找目录，确定该文件在目录中的位置；</li><li>根据隐含参数中的文件主和目录中该文件的存储权限数据，检查是否有读权，若是，则进行下一步 4)；否则转向 10)；</li><li>由文件内位置与要读的长度计算最末位置，将其余目录中的文件长度比较，超过否？若是，则转向 10)；否则进行下一步 5)。也可将参数中的长度修正为目录中的文件长度；</li><li>根据参数中的位置、长度和目录中的映射信息，确定物理块号、需要独处的块数等读盘参数（参数准备完毕后，进行物理的读盘操作，读盘操作可能要进行多次）；</li><li>根据下一块号读至内存缓冲区；</li><li>取出要读的内容，也许要进行成组的分解，将取出的内容送至参数中的内存目的地址；</li><li>根据块内长度或起始块号 + 块数，确定是否还读下一块，同时确定下一块块号，若是，则转向 5)；否则，进行下一步 9)；</li><li>正常返回；</li><li>错误返回，返回相应的错误号；</li></ol><p><strong>4. 写文件</strong></p><p>写文件系统调用的一般格式为：write（文件名，纪录键，内存位置）。</p><p>把内存中指定单元的数据作为指定的一个记录写入指定文件中，系统还将为其分配物理块，以便把记录信息写到外存上。</p><p><strong>5. 关闭文件</strong></p><p>若文件暂时不用，则应将它关闭。文件关闭后一般不能存取，若要存取，则必须再次打开。</p><p>关闭文件系统调用的一般格式为：close（文件名）。</p><p>系统根据用户提供的文件名或文件描述符，在该文件的文件控制块上做修改。例如，将该文件的共享用户数减 1，减 1 后若值为 0，则将文件控制块置上「非活跃」标志，若该文件控制块内容被修改过，则要写回外存。</p><p><strong>6. 删除文件</strong></p><p>删除文件系统调用的一般格式为：delete（文件名）。</p><p>系统根据用户提供的文件名或文件描述符，检查此次删除的合法性，若合法，则收回该文件所占用的文件控制块及物理块等资源。</p><p><strong>7. 指针定位</strong></p><p>指针定位的一般格式为：seek（fd，新指针的位置）。</p><p>指针定位时，系统主要完成以下工作：</p><ol><li>由 fd 检查用户打开文件表，找到对应的入口；</li><li>将用户打开文件表中文件读写指针位置设为新指针的位置，供后续读写命令存取该指针处文件内容；</li></ol><p>在不同的文件系统中，文件操作的种类是不同的，文件操作的命令种类会有所变化，调用名和参数也都不同。上述这些类型，只是文件操作中的一些典型例子。其他的文件操作如：读取文件属性，设置文件属性，修改文件名称等。</p><h2 id="6-2-典型的目录操作"><a href="#6-2-典型的目录操作" class="headerlink" title="6.2 典型的目录操作"></a>6.2 典型的目录操作</h2><ol><li>create：创建目录；</li><li>delete：删除目录；</li><li>opendir：打开目录；</li><li>closedir：关闭目录；</li><li>readdir：系统调用 readdir 返回打开目录的下一目录项；</li><li>rename：文件可换名；</li><li>link：链接技术允许在多个目录中出现同一文件；</li><li>unlink：删除目录项；</li></ol><h1 id="7-文件系统的性能"><a href="#7-文件系统的性能" class="headerlink" title="7 文件系统的性能"></a>7 文件系统的性能</h1><h2 id="7-1-磁盘高速缓存"><a href="#7-1-磁盘高速缓存" class="headerlink" title="7.1 磁盘高速缓存"></a>7.1 磁盘高速缓存</h2><p>其基本思想是，系统在内存中保存一些磁盘块，这些磁盘块在逻辑上属于磁盘，内存的这一区域被称为块高速缓存。运行时，系统检查所有的读请求，看所需的文件块是否在块高速缓存中。如果在，则可直接在内存中进行读操作；否则，首先要启动磁盘，将所需块读到高速缓存中，再复制到其他内存区域。如果内存区域中的高速缓存已满，则需要按照一定的算法淘汰一些较少使用的磁盘块，让出高速缓存空间。</p><p>块高速缓存的内容需要定期写回到磁盘上，以保存对磁盘块的修改。但是，如果在修改过的磁盘块写回磁盘之前，系统出现故障，则文件系统有可能会处于不一致的状态。特别是一些未被写回的块是 i 结点块、目录块或者包含空闲表的磁盘块时，这个问题尤为严重。这一问题称为文件系统一致性问题。</p><p>缓存的一种应用是记录的成组。</p><p><strong>记录的成组：</strong> 把若干个逻辑记录合成一组存储一物理块的工作称「记录的成组」，每块中的逻辑记录个数称「块因子」。</p><p><strong>记录的分解：</strong>对应前述纪录成组的操作，有必要考虑从一组逻辑记录中把一个逻辑记录分离出来的操作，这种操作称为「记录的分解」。</p><h2 id="7-2-RAID-技术"><a href="#7-2-RAID-技术" class="headerlink" title="7.2 RAID 技术"></a>7.2 RAID 技术</h2><p>磁盘是机械设备，一方面速度慢，另一方面会出现故障。为解决此问题，RAID 技术被提了出来，RAID 技术主要是解决上述两个问题，因此，在组成 RAID 的结构上有多种方法。</p><p>RAID0 采用多个磁盘并行以提高读写速度；</p><p>RAID1 用磁盘镜像的方法来提高存储的可靠性；</p><p>RAID2 和 RAID3 以「位」或「字节」作为并行单位；</p><p>RAID4 的并行单位是「块」，为提高可靠性加入了校验，校验码是独立存储的；</p><p>RAID5 与 RAID4 相同，但是检验码以「块」为单位与数据块一起随机存储在磁盘块中；</p><p>其他的 RAID 结构都是上述各种方法的组合或扩展，最常用的是 RAID1 + 0 以及 RAID5。</p><h1 id="8-文件共享、保护和保密"><a href="#8-文件共享、保护和保密" class="headerlink" title="8 文件共享、保护和保密"></a>8 文件共享、保护和保密</h1><h2 id="8-1-文件共享"><a href="#8-1-文件共享" class="headerlink" title="8.1 文件共享"></a>8.1 文件共享</h2><p>文件共享是指一个文件可以允许多个用户共同使用。文件共享不仅是完成共同任务所必须的，而且还带来许多好处：</p><ol><li>节省文件所占用的存储空间；</li><li>免除系统复制文件的工作；</li><li>减少用户大量重复性劳动；</li><li>减少实际输入输出文件的次数；</li><li>实现进程间相互通信；</li></ol><p>在允许文件共享的系统中，必须对共享文件进行管理。从共享的时间段上看，共享文件的使用有两种情况：</p><ol><li>文件可以同时使用；</li><li>文件不允许同时使用；</li></ol><p>在文件共享的具体方式上，有三种文件的共享形式：</p><ol><li>文件被多个用户使用，由存取权限控制；</li><li>文件被多个程序使用，但分别用自己的读写指针；</li><li>文件被多个程序使用，但共享读写指针；</li></ol><h2 id="8-2-文件存取控制"><a href="#8-2-文件存取控制" class="headerlink" title="8.2 文件存取控制"></a>8.2 文件存取控制</h2><ol><li>建立副本：把同一个文件保存到多个存储介质上，这些存储介质可以是同类的，也可以是不同类型的；</li><li>定时转储：每隔一定的时间就把文件转储到其他的存储介质上；</li><li>规定文件的存储权限：① 采用树形目录结构；② 存取控制表；</li></ol><h2 id="8-3-UNIX-的文件使用权限管理方案"><a href="#8-3-UNIX-的文件使用权限管理方案" class="headerlink" title="8.3 UNIX 的文件使用权限管理方案"></a>8.3 UNIX 的文件使用权限管理方案</h2><ol><li>存取控制矩阵：系统以一个二维矩阵来试试文件的存储控制。其中一维代表所有的用户，另一维代表所有的文件；</li><li>二级存取控制：设立两个存取级别。在低一级，把用户按某种关系划分为若干用户组，进行对访问者的识别；在第二集，进行对操作权限的识别；</li></ol><h2 id="8-4-文件的保密措施"><a href="#8-4-文件的保密措施" class="headerlink" title="8.4 文件的保密措施"></a>8.4 文件的保密措施</h2><ol><li>隐藏文件目录；</li><li>设置口令；</li><li>使用密码；</li><li>病毒防范；</li></ol>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>存储管理</title>
      <link href="/2021/03/20/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E5%AD%98%E5%82%A8%E7%AE%A1%E7%90%86/"/>
      <url>/2021/03/20/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E5%AD%98%E5%82%A8%E7%AE%A1%E7%90%86/</url>
      
        <content type="html"><![CDATA[<p>计算机系统中的存储器可以分成两类：<strong>内存储器（简称内存）</strong>和 <strong>外存储器（简称外存）</strong>。处理器可以直接访问内存，但不能直接访问外存。处理器要通过启动相应的输入&#x2F;输出设备后才能使外存与内存交换信息。</p><p><img src="https://personal-blog.oss-cn-hangzhou.aliyuncs.com/OS_chapter_6.png"></p><h1 id="1-存储管理的任务"><a href="#1-存储管理的任务" class="headerlink" title="1 存储管理的任务"></a>1 存储管理的任务</h1><p>在计算机系统中，存储器是处理器处理的信息的来源于归宿，占据着重要地位。到目前为止，最先进的计算机科学技术能够提供的存储设备的速度，仍然明显地慢于同级别的中央处理器的速度。而且由于成本等方面的原因，任何一种存储设备都无法在速度上与容量两个方面同时满足用户的需求。</p><h2 id="1-1-内存空间的划分"><a href="#1-1-内存空间的划分" class="headerlink" title="1.1 内存空间的划分"></a>1.1 内存空间的划分</h2><p><img src="https://personal-blog.oss-cn-hangzhou.aliyuncs.com/OS_storage_system.png"></p><p>快速存储设备和大容量存储设备必须构成为统一的整体，由操作系统协调这些存储器的使用。对于内存速度和容量的要求是，内存的直接存取速度尽量快到与处理器存取速度相匹配，其容量大道能装下当前运行的程序与数据，否则处理器执行速度就会受到内存速度和容量的影响而得不到充分发挥。各种速度和容量的存储器硬件，在操作系统协调之下形成了一种存储器层次结构，或称存储体系。</p><h2 id="1-2-内存空间的分配和回收"><a href="#1-2-内存空间的分配和回收" class="headerlink" title="1.2 内存空间的分配和回收"></a>1.2 内存空间的分配和回收</h2><p>内存空间一般分为两部分：</p><ol><li>系统区，用以存储操作系统常驻内存部分，用户不能占用这部分空间；</li><li>用户区，分配给用户使用，用于装入并存储用户程序和数据，这部分的信息随时都在发生变化；</li></ol><p>存储管理实质上就是管理供用户使用的那部分空间。</p><p>内存管理问题主要包括：</p><ol><li>内存管理方法</li><li>内存的分配和释放算法；</li><li>虚拟存储器的管理；</li><li>控制内存和外存之间的数据流动方法；</li><li>地址变换技术；</li><li>内存数据保护与共享技术等；</li></ol><p>内存分配有两种方式：</p><ol><li>静态分配：程序要求的内存空间是在目标模块连接装入内存时确定并分配的，并且在程序运行过程中不允许再申请或在内存中「搬家」，即分配工作是在程序运行前一次性完成；</li><li>动态分配：程序要求的基本内存空间是在目标模块装入时确定并分配的，但是在程序运行过程中允许申请附加的内存空间或在内存中「搬家」，即分配工作可以再程序运行前及运行过程中逐步完成；</li></ol><p>一个有效的存储分配机制，应对用户提出的需求予以快速响应，为之分配相应的存储空间，在用户程序不再需要它时及时回收，以供其他用户使用。为此，应该具有以下功能：</p><ol><li>记住每个存储区域的状态。内存空间哪些是分配了的，哪些是空闲的？这就需要设置相应的分配表格，记录内存空间使用状态；</li><li>实施分配。当用户提出申请时，按需要进行分配，并修改相应的分配表格。分配方式有静态分配和动态分配两种；</li><li>回收。接收用户释放的区域，并修改相应的分配表格；</li></ol><h2 id="1-3-存储保护问题"><a href="#1-3-存储保护问题" class="headerlink" title="1.3 存储保护问题"></a>1.3 存储保护问题</h2><p>存储保护的目的在于为多个程序共享内存提供保障，使在内存中的各道程序，只能访问它自己的区域，避免各道程序间相互干扰。特别是当一道程序发生错误时，不至于影响其他程序的运行，更要防止破坏系统程序。存储保护通常需要有硬件支持，并由软件配合实现。</p><p>存储保护的内容包括：</p><ol><li>保护系统程序区不被用户有意或无意的侵犯；</li><li>不允许用户程序读写不属于自己地址空间的数据，如系统区地址空间、其他用户程序的地址空间；</li></ol><h2 id="1-4-存储共享"><a href="#1-4-存储共享" class="headerlink" title="1.4 存储共享"></a>1.4 存储共享</h2><p>所谓的存储共享是指两个或多个进程公用内存中相同区域，这样不仅能使多道程序动态地共享内存，提高内存利用率，而且还能共享内存中某个区域的信息。共享的内容包括代码共享和数据共享，特别是代码共享要求代码必须是纯代码。</p><p>存储共享的一个目的是通过代码共享节省内存空间，提高内存利用率；另一个目的是通过数据共享实现进程通信。</p><h2 id="1-5-地址转换、地址重定位"><a href="#1-5-地址转换、地址重定位" class="headerlink" title="1.5 地址转换、地址重定位"></a>1.5 地址转换、地址重定位</h2><p>当用户程序进入计算机系统请求执行时，存储管理要为它分配合适的内存空间，这个分配到的内存空间可能是从某单元开始的一组连续的地址空间。该地址空间的起始地址是不固定的，而且逻辑地址与分到的内存空间的绝对地址经常不一致。因此，每个逻辑地址再内存中也没有一个固定的绝对地址与之对应。程序执行时不能按照其逻辑地址到内存中存取信息，处理器必须按照实际地址去访问内存才能保证程序的正确执行。</p><p>为了保证程序的正确执行，必须根据分配给程序的内存区域对程序中指令和数据的存储地址进行重定位，即要把逻辑地址转换成绝对地址。</p><p>包逻辑地址转换成绝对地址的工作称「地址重定位」或「地址转换」，又称「地址映射」。重定位的方式可以有「静态重定位」和「动态重定位」两种。</p><h3 id="1-5-1-静态重定位"><a href="#1-5-1-静态重定位" class="headerlink" title="1.5.1 静态重定位"></a>1.5.1 静态重定位</h3><p>内存在装入一个程序时，要把程序中的指令地址和数据地址全部转换成绝对地址。由于地址转换工作时在程序开始执行前集中完成的，所以在程序执行过程中就无须再进行地址转换工作，这种地址转换方式称「静态重定位」。</p><h3 id="1-5-2-动态重定位"><a href="#1-5-2-动态重定位" class="headerlink" title="1.5.2 动态重定位"></a>1.5.2 动态重定位</h3><p>内存在装入程序时，不进行地址转换，而是直接把程序装入到分配的内存区域中。在程序执行过程中，每当执行一条指令时都由硬件的地址转换机构将指令中的逻辑地址转换成绝对地址。这种方式的地址转换是在程序执行时动态完成的，故称为「动态重定位」。</p><h1 id="2-可变分区存储管理方案"><a href="#2-可变分区存储管理方案" class="headerlink" title="2 可变分区存储管理方案"></a>2 可变分区存储管理方案</h1><h2 id="2-1-可变分区管理基本工作原理"><a href="#2-1-可变分区管理基本工作原理" class="headerlink" title="2.1 可变分区管理基本工作原理"></a>2.1 可变分区管理基本工作原理</h2><p>可变分区是指系统不预先划分固定分区，而是在装入程序时划分内存分区，使为程序分配的分区的大小正好等于该程序的需求量，且分区的个数是可变的。显然，可变分区有较大的灵活性，较之固定分区能获得较好的内存利用率。</p><h2 id="2-2-内存分配表"><a href="#2-2-内存分配表" class="headerlink" title="2.2 内存分配表"></a>2.2 内存分配表</h2><p>用于固定分区管理的内存分配表是一张分区说明表，按顺序每个分区在分区说明表中对应一个表目。表目内容包括分区序号、分区大小、分区起始地址以及使用状态（空闲或占用）。一个程序在运行时，先要根据其对内存的需求量，按一定的分配策略在分区说明表中查找空闲分区。若能找到合乎需要的分区，就将该分区分配给程序，并将该分区置为占用状态。当程序完成时释放这块分区内存，由系统回收，并在分区说明表中将回收的分区重新置为空闲状态。</p><p>内存分配表由两张表格组成。一个是已分配区表，记录已装入的程序在内存中占用分区的起始地址和长度，用标志位指出占用分区的程序名。另一个是空闲表，记录内存中可供分配的空闲区的起始地址和长度，用标志位指出该分区是未分配的空闲区。由于已占分区和空闲区的个数不定，因此，两张表格中都应设置适当的空栏目，分别用以登记新内存分配表。</p><h2 id="2-3-内存分配与回收算法"><a href="#2-3-内存分配与回收算法" class="headerlink" title="2.3 内存分配与回收算法"></a>2.3 内存分配与回收算法</h2><p>常用的分配算法：</p><ol><li>最先适应算法：最先适应算法，又称顺序分配算法，当接到内存申请时，顺序查找分区说明表，找到第一个满足申请长度的空闲区，将其分割并分配；</li><li>最优适应算法：当接到内存申请时，查找分区说明表，找到第一个能满足申请长度的最小空闲区，将其分割并分配；</li><li>最坏适应算法：当接到内存申请时，查找分区说明表，找到能满足申请要求的最大空闲区；</li></ol><h2 id="2-4-紧缩技术"><a href="#2-4-紧缩技术" class="headerlink" title="2.4 紧缩技术"></a>2.4 紧缩技术</h2><p>解决碎片问题的办法是在适当时刻警醒碎片整理，通过移动内存中的程序，把所有空闲碎片合并成一个连续的大空闲区且放在内存的一端，而把所有程序占用区放在内存的另一端，这一技术成为「紧缩技术」，或「压缩技术」。</p><p>紧缩技术可以集中分散的空闲区，提高内存的利用率，便于进程动态扩充内存。采用紧缩技术要注意以下问题：</p><ol><li>紧缩技术会增加系统的开销；</li><li>移动是有条件的；</li></ol><h1 id="3-覆盖技术和交换技术"><a href="#3-覆盖技术和交换技术" class="headerlink" title="3 覆盖技术和交换技术"></a>3 覆盖技术和交换技术</h1><h2 id="3-1-覆盖技术"><a href="#3-1-覆盖技术" class="headerlink" title="3.1 覆盖技术"></a>3.1 覆盖技术</h2><p>覆盖技术是指一个程序的若干程序段，或几个程序的某些部分共享某一个存储空间。覆盖技术的实现时把程序划分为若干个功能上相对独立的程序段，按照其自身的逻辑结构使那些不会同时执行的程序段共享同一块内存区域。未执行的程序段先保存在磁盘上，当有关程序段的前一部分执行结束后，把后续程序段调入内存，覆盖前面的程序段。</p><p>覆盖技术不需要任何来自操作系统的特殊支持，可以完全由用户实现，即覆盖技术是用户程序自己附加的控制。覆盖技术要求程序员提供一个清楚的覆盖结构，即程序员要把一个程序划分成不同的程序段，并规定好它们的执行和覆盖的顺序。操作系统则根据程序员提供的覆盖结构，完成程序段之间的覆盖。</p><p>覆盖技术可以由编译程序提供支持。此时被覆盖的块是由程序员或编译程序预先（在执行前）确定的。总之，覆盖可以从用户级彻底解决内存小装不下程序的问题。</p><h2 id="3-2-交换技术"><a href="#3-2-交换技术" class="headerlink" title="3.2 交换技术"></a>3.2 交换技术</h2><p>交换技术又称对换技术。在分时系统中，用户的进程比内存能容纳的数量要多，这就需要在磁盘上保存那些内存放不下的进程。在需要运行这些进程时，再将它们装入内存。</p><p>进程从内存移到磁盘，并再移回内存称为交换。</p><p>交换技术是进程在内存与外存之间的动态调度，是由操作系统控制的。系统可以将那些不在运行中的进程或其一部分调出内存，暂时存储在外存上的一个后备存储区（称为盘交换区）中，以腾出内存空间给现在需要内存空间的进程，后者可能需要从外存换入内存，以后再降换出的进程调入内存继续执行。</p><p>交换技术的目的是尽可能达到「足够快地交换进程，以使当处理器调度程序想重新调度处理器时，总有进程在内存中处于就绪（准备执行）状态」的理想状态，从而提高内存利用率。</p><h1 id="4-虚拟页式存储管理方案"><a href="#4-虚拟页式存储管理方案" class="headerlink" title="4 虚拟页式存储管理方案"></a>4 虚拟页式存储管理方案</h1><p>虚拟存储管理是由操作系统在硬件支持下把两级存储器（内存和外存）统一实施管理，达到「扩充」内存的目的，呈现给用户的是一个远远大于内存容量的编程空间，即虚存。程序、数据、堆栈的大小可以超过内存的大小，操作系统把程序当前使用的部分保留在内存，而把其他部分保存在磁盘上，并在需要时在内存和磁盘之间动态交换。虚拟存储管理支持多道程序设计技术。</p><h2 id="4-1-虚拟地址空间和虚拟地址"><a href="#4-1-虚拟地址空间和虚拟地址" class="headerlink" title="4.1 虚拟地址空间和虚拟地址"></a>4.1 虚拟地址空间和虚拟地址</h2><p>存储管理部件首先把内存分成大小相等的许多区，把每个区称为「物理页面」，物理页面是进程内存空间分配的物理单位。同时，要求程序中的逻辑地址也进行分页，页的大小与物理页面的大小一致。</p><p>此时「逻辑地址」可被称为虚拟地址。</p><p>这样，就可把程序信息按页存放到物理页面中。于是，页式存储器提供编程使用的虚拟地址由两部分组成：虚拟页号和页内地址。</p><h2 id="4-2-页表的作用和页表项的内容"><a href="#4-2-页表的作用和页表项的内容" class="headerlink" title="4.2 页表的作用和页表项的内容"></a>4.2 页表的作用和页表项的内容</h2><p>页式存储管理要有硬件的地址转换机构作支持。同时，要为每个被装入内存的进程提供一张页表。该页表所在内存的起始地址和长度作为现场信息存储在该进程的进程控制块中。一旦进程被调度进入处理器执行，这些信息将被作为恢复现场信息送入系统的地址映射机制中的寄存器里。</p><p>页表指出该程序虚拟地址中的页号与所占用的物理页面号之间的对应关系。页表的长度有程序拥有的页面数而定，故每个程序的页表长度可能是不同的。</p><p>页表又是硬件进行地址转换的依据，每执行一条指令时按虚拟地址中的页号查页表。若页表中无此页号，则产生一个「地址错」的程序性中断事件。若页表中有此页号，则可得到对应的物理页面号，按计算公式可转换成访问的内存的物理地址。</p><p>物理地址的计算公式为：<center>物理地址 &#x3D; 物理页面号 x 块长 + 页内地址</center></p><p>物理页面号又称为页帧和页框号。</p><p>在虚拟也是存储管理中，页表项的设计如下：</p><ol><li>物理页面号：页面在内存中时所对应的物理页面号；</li><li>有效位：又称驻留位、存在位，表示该页是在内存还是在磁盘；</li><li>访问位：访问位表示该页在内存期间是否被访问过；</li><li>修改位：修改位表示该页在内存中是否被修改过；</li><li>保护位：是否能读&#x2F;写；</li></ol><p>其中，访问位和修改位可以用来决定置换哪个页面，具体由页面置换算法决定。</p><h2 id="4-3-地址转换过程与-TLB"><a href="#4-3-地址转换过程与-TLB" class="headerlink" title="4.3 地址转换过程与 TLB"></a>4.3 地址转换过程与 TLB</h2><p>一般而言，页式存储管理中的页表是存储在内存中的。于是，当要按给定的虚拟地址进行读写时，必须访问两次内存。第一次按页号读出页表中对应的块号，第二次按计算出来的绝对地址进行读写。两次访问内存显然延长了指令的执行周期，降低了执行速度。</p><p>为了提高存取速度，有两种方法：</p><ol><li>在地址映射机制中增加一组告诉寄存器保存页表，这需要大量的硬件开销，在经济上不可行；</li><li>在地址映射机制中增加一个小容量的联想寄存器（相连寄存器），它由高速缓冲存储器组成；</li></ol><p>利用高速缓冲存储器存储当前访问最频繁的少数活动页面的页号，这个高速缓冲存储器称为「转换检测缓冲区」（Translation Lookaside Buffer，TLB）。</p><p>TLB 中登记了页表中的一部分页号与物理页面号的对应关系。根据程序的存储访问局部性原理，在一段时间内总是经常访问少数几页，若所这些页等级在 TLB 中，显然可快速查找并提高指令执行速度。</p><p>TLB 内容的更新原理如下：当某一用户程序需要存取数据时，根据该数据所在的逻辑页号在 TLB 中找出对应的物理页面号，然后拼接页内地址，以形成物理地址；如果在 TLB 中没有相应的逻辑页号，则地址映射仍然通过内存中的页表进行；在得到物理页面号后需将该块号填到 TLB 的空闲单元中；若 TLB 中没有空闲单元，则根据淘汰算法淘汰某一行，再填入新得到的页号和块号。</p><p>实际上，查找 TLB 和查找内存页表是并行进行的，一旦发现 TLB 中有与所查页号一致的逻辑页号就停止朝招内存页表，而直接利用 TLB 中的逻辑页号。</p><h2 id="4-4-缺页异常处理"><a href="#4-4-缺页异常处理" class="headerlink" title="4.4 缺页异常处理"></a>4.4 缺页异常处理</h2><p>若在页表中发现所要访问的页面不在内存，则产生缺页异常。当发生缺页异常时，操作系统必须在内存中选择一个页面将其移除内存，以便为即将调入的页面让出空间。如果要移走的页面在内存期间已经被修改过，就必须把它写会磁盘以更新该页在磁盘上的副本。如果该页没有被修改过，那么它在磁盘上的副本仍然是最新的，则不需要写回，调入的页直接覆盖被淘汰的页。</p><p>整个缺页处理过程简单阐述如下：</p><ol><li>根据当前执行指令中的逻辑地址查页表的有效位，判断该页是否在内存；</li><li>该页标志位「0」，形成缺页异常。保留线程，中断装置通过交换 PSW 让操作系统的中断处理程序占用处理器；</li><li>操作系统处理缺页异常，寻找一个空闲的页面；</li><li>若有空闲页，则把磁盘上读出的信息装入该页面中；</li><li>修改页表及内存分配表，表示该页已在内存；</li><li>如果内存中无空闲项，则按某种算法选择一个已在内存的页面，把它暂时调出内存。若在执行中该页面已被修改过，则要把该页信息重新写回到磁盘上，否则不必重新写回磁盘。当一页被暂时调出内存后，让出的内存空间用来存储当前需要使用的页面。页面被调出或装入之后都要对页表及内存分配表作修改；</li><li>恢复现场，重新执行被中断的指令。当重新执行该指令时，由于要访问的页面已被装入内存，所以可正常执行下去；</li></ol><h1 id="5-典型的页面置换算法"><a href="#5-典型的页面置换算法" class="headerlink" title="5 典型的页面置换算法"></a>5 典型的页面置换算法</h1><h2 id="5-1-最佳页面置换算法（OPT）"><a href="#5-1-最佳页面置换算法（OPT）" class="headerlink" title="5.1 最佳页面置换算法（OPT）"></a>5.1 最佳页面置换算法（OPT）</h2><p>OPT 算法淘汰以后不再需要的或者在最长时间以后才会用到的页面。这一算法一般不可能实现，但它可以作为衡量其他页面淘汰算法优劣的一个标准。</p><h2 id="5-2-先进先出算法（FIFO）"><a href="#5-2-先进先出算法（FIFO）" class="headerlink" title="5.2 先进先出算法（FIFO）"></a>5.2 先进先出算法（FIFO）</h2><p>总是选择最先装入内存的一页调出，或者说是把驻留在内存中时间最长的一页调出。</p><h2 id="5-3-第二次机会算法（Second-Chance）"><a href="#5-3-第二次机会算法（Second-Chance）" class="headerlink" title="5.3 第二次机会算法（Second Chance）"></a>5.3 第二次机会算法（Second Chance）</h2><p>检查进入内存时间最久页面的 R 位，如果是 0，那么这个页面既老又没有被使用，可以立刻置换掉；如果是 1，就将 R 位清 0，并把该页面放到链表的尾端，修改其进入时间，然后继续搜索。</p><p>这一算法称为第二次机会算法，其基本思想是寻找一个最佳的时钟间隔以来没有被访问过的页面。如果所有的页面都被访问过了，该算法就退化为 FIFO 算法。</p><h2 id="5-4-时钟算法（Clock）"><a href="#5-4-时钟算法（Clock）" class="headerlink" title="5.4 时钟算法（Clock）"></a>5.4 时钟算法（Clock）</h2><p>把所有的页面都保存在一个类似时钟面的环形链表中，一个表针指向最老的页面。当发生缺页时，算法首先检查表针指向的页面，如果它的 R 为是 0 就置换该页面，并把新的页面插入这个位置，然后把表针前移一个位置；如果 R 位是 1 就清除 R 位并把表针前移一个位置，重复这个过程直到找到了一个 R 位为 0 的页面为止。由于这个算法的工作方式，就将它称为时钟算法。</p><h2 id="5-5-最近最少使用算法（LRU）"><a href="#5-5-最近最少使用算法（LRU）" class="headerlink" title="5.5 最近最少使用算法（LRU）"></a>5.5 最近最少使用算法（LRU）</h2><p>在缺页发生时，首先淘汰掉最长时间未被使用过的页面。</p><h2 id="5-6-颠簸或抖动"><a href="#5-6-颠簸或抖动" class="headerlink" title="5.6 颠簸或抖动"></a>5.6 颠簸或抖动</h2><p>在虚存中，页面可能在内存与外存之间频繁地调度，有可能出现抖动或颠簸。点系统出现这一现象时，系统用于调度页面所需要的时间比进程实际运行所占用的时间还多，系统效率会急剧下降。</p><p>颠簸是由于缺页率高而引起的。例如，由于页面置换算法不合理，可能出现刚被淘汰出去的一页，又要被访问，因而又要把它调入的情况，如此反复，使整个西戎的页面调入调出工作非常频繁。</p>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>死锁</title>
      <link href="/2021/03/19/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%AD%BB%E9%94%81/"/>
      <url>/2021/03/19/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%AD%BB%E9%94%81/</url>
      
        <content type="html"><![CDATA[<p>在多道程序系统中，同时有多个进程并发运行，共享系统资源，从而提高了系统资源利用率，提高了系统的处理能力。但是，当一个进程提出资源申请在进行分配使用时，在一定条件下会导致系统发生一种随机性错误 — 死锁（Deadlock）。这是因为，一方面，资源总是有限的，并且有些资源是独占型的，进程对资源的占用是互斥的；另一方面，进程使用多个资源有先后顺序，在一个进程申请与释放资源的过程中，其他的进程也不断地申请资源与释放资源。异步前进的各个进程会因申请与释放资源顺序安排不当，造成这种僵局。另外，在进程使用某种同步或通信工具时发送、接收的次序安排不当，也会造成类似现象。</p><p><img src="https://personal-blog.oss-cn-hangzhou.aliyuncs.com/OS_chapter_5.png"></p><h1 id="1-死锁的产生"><a href="#1-死锁的产生" class="headerlink" title="1 死锁的产生"></a>1 死锁的产生</h1><h2 id="1-1-死锁的定义"><a href="#1-1-死锁的定义" class="headerlink" title="1.1 死锁的定义"></a>1.1 死锁的定义</h2><p>所谓死锁是指在多道程序系统中的一种现象，一组进程中的每一个进程均无限期地等待被该组进程中的另一个进程所占有且永远不会释放的资源。系统发生这种现象称为系统处于死锁状态，简称死锁。处于死锁状态的进程称为死锁进程。</p><h2 id="1-2-死锁产生的原因"><a href="#1-2-死锁产生的原因" class="headerlink" title="1.2 死锁产生的原因"></a>1.2 死锁产生的原因</h2><ol><li>竞争资源，系统资源在分配时出现失误，进程间对资源的相互争夺而造成僵局；</li><li>多道程序运行时，进程推进顺序不合理；</li></ol><p>按照资源的使用性质，一般把系统中的资源分成两类：</p><ol><li>永久性资源（可重用资源），是指系统中可供进程重复使用、长期存在的资源，如内存、外部设备、处理器等硬件资源，以及各种数据文件、表格、共享程序代码等软件资源；</li><li>临时性资源（消耗性资源），是指由某个进程所产生、只为另一个进程使用一次或经过短暂时间后便不再使用的资源，如 I&#x2F;O 和时钟中断信号、同步信号、消息等；</li></ol><p>永久性资源和临时性资源都可能导致死锁发生。</p><h2 id="1-3-死锁产生的必要条件"><a href="#1-3-死锁产生的必要条件" class="headerlink" title="1.3 死锁产生的必要条件"></a>1.3 死锁产生的必要条件</h2><ol><li>互斥条件：资源时独占的且排他使用；</li><li>不可剥夺条件：又称不可抢占或不可强占；</li><li>请求和保持条件：又称部分分配或占有申请；</li><li>循环等待条件：又称环路等待；</li></ol><h1 id="2-死锁预防"><a href="#2-死锁预防" class="headerlink" title="2 死锁预防"></a>2 死锁预防</h1><h2 id="2-1-死锁预防的概念"><a href="#2-1-死锁预防的概念" class="headerlink" title="2.1 死锁预防的概念"></a>2.1 死锁预防的概念</h2><p>死锁预防是指在任何系统操作前（例如分配资源、调度进程等），事先评估系统的可能情况，严格采取措施使得死锁的四个必要条件不成立。</p><p>死锁预防的基本思想是防范于未然。</p><h2 id="2-2-资源的静态分配策略"><a href="#2-2-资源的静态分配策略" class="headerlink" title="2.2 资源的静态分配策略"></a>2.2 资源的静态分配策略</h2><p>在预防死锁的静态分配策略中，资源分配的原则如下：</p><p>一个进程在申请新资源的要求不能立即得到满足时，便处于等待状态。而一个处于等待状态的进程的全部资源可以被剥夺。就是说，这些资源隐式地释放了，被剥夺的资源重新加入到资源表中。仅当该进程重新获得它原有的资源以及得到新申请的资源时，才能重新启动执行。这种方法破坏了不可剥夺条件。</p><h2 id="2-3-资源的有序分配法"><a href="#2-3-资源的有序分配法" class="headerlink" title="2.3 资源的有序分配法"></a>2.3 资源的有序分配法</h2><p>基本思想是将系统中所有资源顺序编号。一般原则是，较为紧缺、稀少的资源的编号较大。进程申请资源时，必须严格按照资源编号的顺序进行，否则系统不予分配。即一个进程只有得到编号小的资源，才能申请编号较大的资源；释放资源时，应按编号递减的次序进行。</p><p>采用资源有序分配策略，破坏了死锁四个必要条件中的循环等待条件。</p><h1 id="3-死锁避免"><a href="#3-死锁避免" class="headerlink" title="3 死锁避免"></a>3 死锁避免</h1><h2 id="3-1-死锁避免的概念"><a href="#3-1-死锁避免的概念" class="headerlink" title="3.1 死锁避免的概念"></a>3.1 死锁避免的概念</h2><p>死锁避免的基本思想是：系统对进程发出的每一个系统能够满足的资源申请进行动态检查，并根据检查结果决定是否分配资源；如果分配后系统可能发生死锁，则不予分配，否则予以分配。这是一种保证系统不进入死锁状态的动态策略。</p><p>死锁避免和死锁预防的区别在于，死锁预防是设法至少破坏产生死锁的四个必要条件之一，严格地防止死锁的出现。而死锁避免则不那么严格地限制产生死锁的必要条件的存在，因为即使死锁的必要条件存在，也不一定发生死锁。死锁避免是在系统运行过程中注意避免死锁的最终发生。</p><h2 id="3-2-安全状态与安全序列"><a href="#3-2-安全状态与安全序列" class="headerlink" title="3.2 安全状态与安全序列"></a>3.2 安全状态与安全序列</h2><p>由于在避免死锁的策略中允许进程动态地申请资源，因而，系统需提供某种方法，在进行资源分配之前，先分析资源分配的安全性。当估计到可能有死锁发生时，就应设法避免死锁的发生。</p><p>如果操作系统能保证所有的进程子啊有限时间内得到需要的全部资源，则称系统处于「安全状态」，否则说系统是不安全的。</p><p>所谓安全状态是指，如果存在一个由系统中所有进程构成的安全序列 { P<sub>1</sub>，···，P<sub>n</sub> }，则系统处于安全状态。一个进程序列 { P<sub>1</sub>，···，P<sub>n</sub> } 是安全的，如果对于其中每一个进程 P<sub>i</sub>（1 ≤ i ≤ n），它以后尚需要的资源量不超过系统当前剩余资源量与所有进程 P<sub>j</sub>（j ＜i）当前占有资源量之和。系统处于安全状态则不会发生死锁。</p><p>如果不存在任何一个安全序列，则系统处于不安全状态。不安全状态不一定导致死锁，但死锁状态一定是不安全状态。即系统若处于不安全状态则可能发生死锁。</p><h1 id="4-死锁的检测与解除"><a href="#4-死锁的检测与解除" class="headerlink" title="4 死锁的检测与解除"></a>4 死锁的检测与解除</h1><p>假如系统为进程分配资源时，不采取任何限制性措施来避免和预防死锁，减少因避免和预防死锁策略带来的开销，同时本着提高资源利用率的原则分配资源，但操作系统在运行过程中，不断地监督进程的执行和资源占用状态，判定死锁是否真的发生；并且，一旦死锁发生，则采取专门的措施解除死锁，并以最小代价使整个系统恢复正常，这就是死锁的检测和解除。</p><h2 id="4-1-死锁检测的时机"><a href="#4-1-死锁检测的时机" class="headerlink" title="4.1 死锁检测的时机"></a>4.1 死锁检测的时机</h2><p>操作系统可定时运行一个「死锁检测」程序，该程序按一定的算法去检测系统中是否存在死锁。检测死锁的实质是确定是否存在「循环等待」条件，检测算法确定死锁的存在并识别出于死锁有关的进程和资源，以供系统采取适当的解除死锁措施。</p><p>通常，死锁检测可以再任何一次资源分配后，也可以再每次调度后，或者利用定时器定时运行检测，还有一种方法是当系统中某个进程长期位于阻塞状态或阻塞进程过多时，启动死锁检测程序。</p><h2 id="4-2-死锁检测算法"><a href="#4-2-死锁检测算法" class="headerlink" title="4.2 死锁检测算法"></a>4.2 死锁检测算法</h2><ol><li>为每个进程和每个资源指定唯一编号；</li><li>设置一张资源分配状态表，每个表目包含「资源号」和占有该资源的「进程号」两项，资源分配表中记录了每个资源正在被哪个进程所占有；</li><li>设置一张进程等待分配表，每个表目包含「进程号」和该进程所等待的「资源号」两项；</li><li>算法规则：当任一进程 P<sub>j</sub> 申请一个已被其他进程占用的资源 r<sub>i</sub> 时，进行死锁检测算法通过反复查找资源分配表和进程等待表，来确定进程 P<sub>j</sub> 对资源 r<sub>i</sub> 的请求是否导致形成环路，若是，便确定出现死锁。</li></ol><h2 id="4-3-死锁的解除方法"><a href="#4-3-死锁的解除方法" class="headerlink" title="4.3 死锁的解除方法"></a>4.3 死锁的解除方法</h2><ol><li>剥夺资源：使用挂起&#x2F;激活机制挂起一些进程，剥夺它们占有的资源给死锁进程，以解除死锁，待以后条件满足时，再激活被挂起的进程；</li><li>撤销进程：撤销死锁进程，将它们占有的资源分配给另一些死锁进程，直到死锁解除为止；</li></ol><h1 id="5-资源分配图"><a href="#5-资源分配图" class="headerlink" title="5 资源分配图"></a>5 资源分配图</h1><p>资源分配图是死锁的一种准确而形象地描述，通过资源分配图，可以对当前系统资源分配和申请情况一目了然，便于对死锁进行分析并采取对策。</p><h2 id="5-1-资源分配图"><a href="#5-1-资源分配图" class="headerlink" title="5.1 资源分配图"></a>5.1 资源分配图</h2><p>资源分配图是一张有向图，一个系统资源分配图 SRAG（System Resource Allocation Graph）可定义为一个二元组，即 SRAG &#x3D; （V，E），其中 V 是顶点的集合，而 E 是有向边的集合。</p><p>顶点集合可分为两种部分：P &#x3D; （P<sub>1</sub>，···，P<sub>n</sub>），是由系统内的所有进程组成的集合，每一个 P<sub>i</sub> 代表一个进程；R &#x3D; （r<sub>1</sub>，···，r<sub>n</sub>），是系统内所有资源组成的集合，每一个 r<sub>i</sub> 代表一类资源。</p><h2 id="5-2-死锁定理"><a href="#5-2-死锁定理" class="headerlink" title="5.2 死锁定理"></a>5.2 死锁定理</h2><ol><li>如果资源分配图中没有环路，则系统没有死锁；</li><li>如果资源分配图中出现了环路，则系统中可能存在死锁；</li></ol><p>① 如果处于环路中的每个资源类中均只包含一个资源实例，则环路的存在即意味着死锁的存在。此时，环路是死锁的充分必要条件；</p><p>② 如果处于环路中的每个资源类中资源实例的个数不全为 1，则环路的存在是产生死锁的必要条件而不是充分条件；</p><h2 id="5-3-资源分配图化简方法"><a href="#5-3-资源分配图化简方法" class="headerlink" title="5.3 资源分配图化简方法"></a>5.3 资源分配图化简方法</h2><p>所谓化简是指若一个进程的所有资源请求均能被满足，可以设想该进程得到其所需的全部资源，最终完成任务，运行完毕，并释放锁占有的全部资源。在这种情况下，则称资源分配图可以被该进程化简。加入一个资源分配图可被其所有进程化简，那么称该图是可化简的，否则称该图是不可化简的。</p><p>化简方法如下：</p><ol><li>在资源分配图中，找出一个既非等待又非鼓励的进程节点 P<sub>i</sub>，由于 P<sub>i</sub> 可获得它所需要的全部资源，且运行完成后释放它所占有的全部资源，故可在资源分配图中消去 P<sub>i</sub> 所有的申请边和分配边，使之称为既无申请边又无分配边的孤立结点；</li><li>将 P<sub>i</sub> 所释放的资源分配给申请它们的进程，即在资源分配图中将这些进程对资源的申请边改为分配边；</li><li>重复 1、2 两步骤，直到找不到符合条件的进程结点；</li></ol><p>经过化简后，若能消去资源分配图中的所有边，使所有进程都成为孤立结点，则该图是可完全化简的；否则为不可化简的。</p>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>进程同步与互斥</title>
      <link href="/2021/03/19/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%BF%9B%E7%A8%8B%E5%90%8C%E6%AD%A5%E4%B8%8E%E4%BA%92%E6%96%A5/"/>
      <url>/2021/03/19/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%BF%9B%E7%A8%8B%E5%90%8C%E6%AD%A5%E4%B8%8E%E4%BA%92%E6%96%A5/</url>
      
        <content type="html"><![CDATA[<p>在一个计算机系统中存在着多个进程，这些进程之间可能有逻辑上的关系，也可能没有逻辑上的关系。进程之间无论是否存在逻辑上的关系，由于它们都要共享或竞争一个计算机系统中的资源，所以不可避免地会互相发生作用。</p><p><img src="https://personal-blog.oss-cn-hangzhou.aliyuncs.com/OS_chapter_4.png"></p><h1 id="1-进程间的相互作用"><a href="#1-进程间的相互作用" class="headerlink" title="1 进程间的相互作用"></a>1 进程间的相互作用</h1><h2 id="1-1-与时间有关的错误"><a href="#1-1-与时间有关的错误" class="headerlink" title="1.1 与时间有关的错误"></a>1.1 与时间有关的错误</h2><p>一个进程由于自身或外界的原因而可能被中断，且断点是不固定的。至于一个进程被中断后，哪个进程可以先运行，而被中断的进程在什么时候再去占用处理器等问题，则与进程调度策略有关。</p><p>进程执行的速度是不能由进程自身控制的。对于相关进程来说，可能有若干并发进程同时使用共享资源，即一个进程一次使用未结束，另一进程也开始使用，形成交替使用共享资源。</p><h2 id="1-2-进程同步互斥举例"><a href="#1-2-进程同步互斥举例" class="headerlink" title="1.2 进程同步互斥举例"></a>1.2 进程同步互斥举例</h2><p>同步举例：进程 A 和进程 B 共享缓冲器，如果不同步，就会出现数据丢失或重复读。</p><p>互斥举例：多个进程在竞争使用打印机、变量、表格等资源。</p><h1 id="2-进程互斥"><a href="#2-进程互斥" class="headerlink" title="2 进程互斥"></a>2 进程互斥</h1><p>在系统中，许多进程常常需要共享资源，而这些资源往往要求排他性的使用，即一次只能为一个进程服务，因此，各进程间只能互斥使用这些资源，进程间的这种关系就是进程的互斥。</p><h2 id="2-1-临界区"><a href="#2-1-临界区" class="headerlink" title="2.1 临界区"></a>2.1 临界区</h2><p>若在系统中的某些资源一次只允许一个进程使用，则这类资源成为临界资源或共享变量，而在进程中访问临界资源的程序称为临界区。</p><h2 id="2-2-临界区的使用规则"><a href="#2-2-临界区的使用规则" class="headerlink" title="2.2 临界区的使用规则"></a>2.2 临界区的使用规则</h2><ol><li>当临界区为空时，若有一个进程要求进入临界区，应允许它立即进入临界区 — 有空让进；</li><li>若有一个进程已在临界区时，其他要求进入临界区的进程必须等待 – 无空等待；</li><li>当没有进程在临界区，而同时有多个进程要求进入临界区，只能让其中之一进入临界区，其他进程必须等待 – 多种择一；</li><li>任一进程进入临界区的要求应在有限时间满足 — 有限等待；</li><li>处于等待状态的进程应放弃占用处理器 — 让权等待；</li></ol><h2 id="2-3-进程互斥为题的传统解决方案"><a href="#2-3-进程互斥为题的传统解决方案" class="headerlink" title="2.3 进程互斥为题的传统解决方案"></a>2.3 进程互斥为题的传统解决方案</h2><p>以打印机为例，采用队列存放请求，按顺序取出数据并进行作业。</p><h1 id="3-进程同步"><a href="#3-进程同步" class="headerlink" title="3 进程同步"></a>3 进程同步</h1><p>进程的同步是指进程之间一种直接的协同工作关系，一些进程相互合作，共同完成一项任务。进程之间的同步也是进程间的一种直接制约关系，一个进程的执行依赖另一个进程的消息，当一个进程执行到某一点时，必须得到另一个进程发来的消息，在没有得到另一个进程的消息时该进程应该等待，直到消息到达才被唤醒，继续程序的执行。</p><h1 id="4-信号量机制"><a href="#4-信号量机制" class="headerlink" title="4 信号量机制"></a>4 信号量机制</h1><h2 id="4-1-信号量的定义"><a href="#4-1-信号量的定义" class="headerlink" title="4.1 信号量的定义"></a>4.1 信号量的定义</h2><p>信号量是一种特殊的变量，它的表面形式是一个整形变量附加一个队列；而且，它只能被特殊的操作（即 P 操作和 V 操作）使用。P 操作和 V 操作都是原语。</p><h2 id="4-2-P、V-操作的定义"><a href="#4-2-P、V-操作的定义" class="headerlink" title="4.2 P、V 操作的定义"></a>4.2 P、V 操作的定义</h2><p>P：等待；</p><p>V：发信号；</p><h2 id="4-3-信号量和-P、V-操作的物理含义"><a href="#4-3-信号量和-P、V-操作的物理含义" class="headerlink" title="4.3 信号量和 P、V 操作的物理含义"></a>4.3 信号量和 P、V 操作的物理含义</h2><p>P 操作和 V 操作是对信号量 S 进行的，有关信号量 S 和 P、V 操作的物理含义可以进一步说明如下。</p><p>信号量 S 表示某类可用的临界资源。对于不同的临界资源，则用不同的信号量表示。</p><p>当 S &gt; 0 时，S 值的大小表示某类可用资源的数量，即表示有该类资源可以分配。</p><p>当 S &lt; 0 时，表示没有可分配的资源数量，其 S 的绝对值表示排在 S 信号量的等待队列中进程的数目。</p><p>每执行一次 P 操作，意味着请求的进程分配到一个资源；每执行一次 V 操作，意味着进程释放了一个资源。</p><h1 id="5-经典的同步互斥问题"><a href="#5-经典的同步互斥问题" class="headerlink" title="5 经典的同步互斥问题"></a>5 经典的同步互斥问题</h1><h2 id="5-1-生产者-—-消费者问题"><a href="#5-1-生产者-—-消费者问题" class="headerlink" title="5.1 生产者 — 消费者问题"></a>5.1 生产者 — 消费者问题</h2><p>设有一个生产者进程 P，一个消费者进程 Q，它们通过一个缓冲区联系起来，缓冲区只能容纳一个产品，生产者不断地生产产品，然后往空缓冲区送产品；而消费者则不断地从缓冲区中取出产品，并消费掉。</p><h2 id="5-2-读者-—-写者问题"><a href="#5-2-读者-—-写者问题" class="headerlink" title="5.2 读者 — 写者问题"></a>5.2 读者 — 写者问题</h2><p>假设有某个共享文件 F，系统允许若干进程对文件 F 进行读或写。这里把要读文件的进程称为读者，把要写文件的进程称为写者。读者和写者必须遵守如下的规定：</p><ol><li>多个进程可以同时读文件 F；</li><li>任一个进程在对文件 F 进行写时，不允许其他进程对文件进行读或写；</li><li>当有进程正在读文件时不允许任何进程去写文件；</li></ol><h1 id="6-管程机制"><a href="#6-管程机制" class="headerlink" title="6 管程机制"></a>6 管程机制</h1><p>采用信号量及 P、V 同步机制来编写并发程序，对于共享变量及信号量变量的操作将被分散于各个进程中，其缺点如下：</p><ol><li>程序易读性差；</li><li>程序不利于修改和维护；</li><li>正确性难以保证；</li></ol><h2 id="6-1-管程的概念"><a href="#6-1-管程的概念" class="headerlink" title="6.1 管程的概念"></a>6.1 管程的概念</h2><p>一个管程是一个由过程、变量及数据结构等组成的一个集合，它们组成一个特殊的模块或软件包。进程可在任何需要的时候调用管程中的过程，但它们不能在管程之外声明的过程中直接访问管程内的数据结构。</p><p>一个管程由四个部分组成：</p><ol><li>管程名称；</li><li>共享数据的说明；</li><li>对数据进行操作的一组过程；</li><li>对共享数据赋初值的语句；</li></ol><p>管程能保障共享资源的互斥执行，即一次只能有一个进程可以在管程内活动。该性能是由管程本身实现的。因此，程序员可以不必显示地编写程序代码去实现这种同步制约。</p><p>管程具有三个主要的特性：</p><ol><li>模块化，一个管程是一个基本程序单位，可以单独编译；</li><li>抽象数据类型，管程是一种特殊的数据类型，其中不仅有数据，而且有对数据进行操作的代码；</li><li>信息隐蔽，管程是半透明的，管程中的外部过程（函数）实现了某些功能，管程中的外部过程（函数）实现了某些功能，至于这些功能是怎样实现的，在其外部则是不可见的；</li></ol><p>管程有一个很重要的特性，即任一时刻管程中只能有一个活跃进程，这一特性使管程能有效地完成互斥。</p><h2 id="6-2-Hoare-管程及设计思想"><a href="#6-2-Hoare-管程及设计思想" class="headerlink" title="6.2 Hoare 管程及设计思想"></a>6.2 Hoare 管程及设计思想</h2><p>在设计 Hoare 管程时，由于管程是互斥进入的，所以当一个进程试图进入一个已被占用的管程时它应当在管程的入口处等待，因而在管程的入口处应当有一个进程等待队列，称作入口等待队列。如果进程 P 唤醒进程 Q，则 P 等待 Q 继续，如果进程 Q 在执行又唤醒进程 R，则 Q 等待 R 继续，···，如此，在管程内部，由于执行唤醒称作，可能会出现多个等待进程，因而还需要有一个进程等待队列，这个等待队列被称为紧急等待队列。它的优先级应当高于入口等待队列的优先级 signal(c)：如果 c 链为空，则相当于空操作，执行此操作的进程继续；否则唤醒第一个等待者，执行此操作的进程的 PCB 入紧急等待队列的尾部。</p><h1 id="7-进程通信"><a href="#7-进程通信" class="headerlink" title="7 进程通信"></a>7 进程通信</h1><p>一个进程在运行过程中，可能需要与其他进程进行信息交换。进程间交换的信息流可多可少，少的只是交换一些已定义的状态值或数值，例如信号量和 P、V 操作；多的则可交换大量信息。P、V 操作是一类低级通信原语，不能承担进程间大量信息的交换任务，因此需要引入新的进程通信原语，解决大量信息交换问题。</p><h2 id="7-1-共享内存"><a href="#7-1-共享内存" class="headerlink" title="7.1 共享内存"></a>7.1 共享内存</h2><p>在相互通信的进程之间设有一个公共内存区，一组进程向该公共内存中写，另一组进程从公共内存中读，通过这种方式实现两组进程间的信息交换。</p><p>这种通信模式需要解决两个问题：</p><ol><li>怎样提供共享内存；</li><li>公共内存中的读写互斥问题；</li></ol><h2 id="7-2-消息队列"><a href="#7-2-消息队列" class="headerlink" title="7.2 消息队列"></a>7.2 消息队列</h2><p>根据「生产者 — 消费者」原理，利用内存中公用消息缓冲区实现进程之间的信息交换。</p><p>内存中开辟了若干消息缓冲区，用于存储消息。每当一个进程（发送进程）向另一个进程（接收进程）发送消息时，便申请一个消息缓冲区，并把已准备好的消息送到缓冲区，然后把该消息缓冲区插入到接收进程的消息队列中，最后通知接收进程。接收进程收到发送进程发来的通知后，从本进程的消息队列中摘下一消息缓冲区，取出所需的信息，然后把消息缓冲区还给系统。系统负责管理公用消息缓冲区以及消息的传递。</p><p>一个进程可以给若干个进程发送消息，反之，一个进程可以接收不同进程发来的消息。显然，进程中关于消息队列的操作是临界区。当发送进程正往接收进程的消息队列中添加一条消息时，接收进程不能同时从该消息队列中取出消息；反之也一样。</p><p>消息缓冲区通信机制包含以下内容：</p><ol><li>消息缓冲区：包含：消息长度、消息正文、发送者、消息队列指针；</li><li>消息队列首指针 m_q，一般保存在 PCB 中；</li><li>互斥信号量 m_mutex，初值为 1，用于互斥访问消息队列，在 PCB 中设置；</li><li>同步信号量 m_syn，初值为 0，用于消息计数，在 PCB 中设置；</li><li>发送消息原语 send（receive，a）；</li><li>接收消息原语 receive（a）；</li></ol><h2 id="7-3-信箱机制"><a href="#7-3-信箱机制" class="headerlink" title="7.3 信箱机制"></a>7.3 信箱机制</h2><p>为了实现进程间的通信，可以设立一个通信机构 — 信箱，以发送信件以及接收回答信件为进程间通信的基本方式。</p><p>当一个进程希望与另一个进程通信时，就创建一个链接两个进程的信箱，发送进程吧信件投入信箱，而接收进程可以在任何时刻取走信件。</p><p>一个信箱的结构可以有「信箱说明」和「信箱体」两部分组成。</p><p>「信箱说明」中，一般有如下的数据结构：</p><ol><li>可存信件数：在设立信箱时预先确定的，表明信箱的容量大小；</li><li>已有信件数：指出信箱中已有信件的数量；</li></ol><h2 id="7-4-管道"><a href="#7-4-管道" class="headerlink" title="7.4 管道"></a>7.4 管道</h2><p>管道（Pipe）通信首先出现在 UNIX 操作系统中。作为 UNIX 的一大特色，管道通信立即引起了人们的兴趣。由于管道通信的有效性，一些系统继 UNIX 之后相继引入了管道技术，管道通信是一种重要的通信方式。</p><p>所谓管道，就是连接两个进程之间的一个打开的共享文件，专用于进程之间进行数据通信。发送进程可以源源不断地从管道一端写入数据流，每次写入的信息长度是可变的；接收进程在需要时可以从管道的另一端读出数据，读出单位长度也是可变的。显然，管道通信的基础是文件系统。</p><p>在对管道文件进行读写操作过程中，发送进程和接收进程要实施正确的同步和互斥，以确保通信的正确性。管道通信机制中的同步与互斥都由操作系统自动进程，对用户是透明的。</p><p>管道通信具有传送数据量大的优点，但通信速度较慢。</p>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>进程与线程</title>
      <link href="/2021/03/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B/"/>
      <url>/2021/03/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<p>一个程序要能够在计算机系统中运行，除了程序本身必须是机器可执行的目标代码之外，还要有相应的数据。程序和数据还要提前被存储在存储器中，即需要报一定的存储空间分配给这个程序和数据。另外，在执行该程序前，处理器中的指令计数器必须指向存储器中被执行程序的首地址。另外，在执行该程序前，处理器中的指令计数器必须指向存储器中被执行程序的首地址。如果在程序执行过程中还需要其他的资源，比如需要从磁盘的一个文件中接收一批数据，那么在申请使用磁盘时，还要知道车牌的设备编号、文件的名称以及文件在磁盘中的物理位置、文件长度等资源信息，所有这些信息均需要有存储空间对它们加以保存，以便在运行时使用。显然，如果有多个程序要同时进入内存并运行，那么每个要运行的程序也需要准备程序代码、数据、资源信息以及保存这些代码、数据、资源信息的存储空间。</p><p>为了能够从技术上较为准确地描述正在运行、将要运行或者刚刚推出运行的各个程序的执行代码、数据以及所需的资源信息等，人们引进了进程（Process）这个概念。</p><p><img src="https://personal-blog.oss-cn-hangzhou.aliyuncs.com/OS_chapter_3.png"></p><h1 id="1-多道程序设计"><a href="#1-多道程序设计" class="headerlink" title="1 多道程序设计"></a>1 多道程序设计</h1><p>采用多道程序设计可以提高处理器的利用率。多道程序设计技术充分发挥了处理器与外围设备以及外围设备之间的并行工作能力，从而提高处理器和其他各种资源的利用率。</p><p>我们把一个具有独立功能的程序独占处理器直到得到最终结果的过程称为程序的顺序执行。程序的顺序执行具有如下特点：</p><ol><li>顺序性；</li><li>封闭性；</li><li>程序执行结果的确定性；</li><li>程序执行结果的可再现性；</li></ol><p>并发执行是指两个或两个以上程序在计算机系统中，同时处于已开始执行且尚未结束的状态。能够参与并发执行的程序称为并发程序。程序的并发执行，可以充分利用系统的资源，提高计算机的处理能力。但是，程序的并发执行产生了一些和程序顺序执行时不同的特征。程序的并发执行有如下特征：</p><ol><li>在执行期间并发程序相互制约；</li><li>程序与计算不再一一对应；</li><li>并发程序的执行结果不可再现；</li><li>程序的并行执行与程序的并发执行；</li></ol><p>在现代计算机系统中，为了提高系统中各种资源的利用效率，缩短程序执行的周转时间，广泛采用了多道程序技术，使多种硬件资源能并行工作。</p><p>所谓多道程序设计，就是允许多个程序同时进入内存并运行。多道程序设计是操作系统所采用的最基本、最重要的技术，其根本目的是提高整个系统的效率。</p><p>衡量系统效率的尺度是系统吞吐量。所谓吞吐量是指单位时间内系统所处理进程（程序）的道数（数量）。</p><p>多道程序设计环境具有以下特点：</p><ol><li>独立性；</li><li>随机性；</li><li>资源共享性；</li></ol><p>采用多道程序设计也存在一些问题：</p><ol><li>可能延长程序的执行时间；</li><li>系统效率的提高有一定限度；</li></ol><h1 id="2-进程的概念"><a href="#2-进程的概念" class="headerlink" title="2 进程的概念"></a>2 进程的概念</h1><h2 id="2-1-进程的定义"><a href="#2-1-进程的定义" class="headerlink" title="2.1 进程的定义"></a>2.1 进程的定义</h2><p>进程是具有一定独立功能程序在某个数据集合上的一次运行活动，是系统进行资源分配和调度的一个独立单位。</p><p>从操作系统角度来看，可将进程分为系统进程和用户进程两类。系统进程执行操作系统程序，完成操作系统的某些功能。用户进程运行用户程序，直接为用户服务。系统进程的优先级通常高于一般用户进程的优先级。</p><h2 id="2-2-进程与程序的联系和区别"><a href="#2-2-进程与程序的联系和区别" class="headerlink" title="2.2 进程与程序的联系和区别"></a>2.2 进程与程序的联系和区别</h2><ol><li>进程和程序的联系：程序时构成进程的组成部分之一，一个进程的运行目标是执行它所对应的程序，如果没有程序，进程就失去了其存在的意义。从静态的角度看，进程是由程序、数据和进程控制块（PCB）三部分组成的。</li><li>进程和程序的区别：程序是静态的，而进程是动态的。进程是程序的一个执行过程。程序的存在是永久的。而进程是为了程序的一次执行而暂时存在的。进程有生命周期，有诞生，亦有消亡。一个进程可以包括若干程序的执行，而一个程序亦可以产生多个进程。进程具有创建其他进程的功能。</li></ol><h2 id="2-3-进程的组成和特征"><a href="#2-3-进程的组成和特征" class="headerlink" title="2.3 进程的组成和特征"></a>2.3 进程的组成和特征</h2><p>进程具有两个基本属性。首先，进程是一个可拥有资源的独立单位；其次，进程同时又是一个可以独立调度和分派的基本单位。正是由于进程具有这两个基本属性，才使之成为一个能独立运行的基本单位，从而也构成了进程并发执行的基础。</p><p>进程具有以下特性：</p><ol><li>并发性；</li><li>动态性；</li><li>独立性；</li><li>交往性；</li><li>异步性；</li><li>结构性；</li></ol><h1 id="3-进程的状态"><a href="#3-进程的状态" class="headerlink" title="3 进程的状态"></a>3 进程的状态</h1><h2 id="3-1-进程的三种基本状态"><a href="#3-1-进程的三种基本状态" class="headerlink" title="3.1 进程的三种基本状态"></a>3.1 进程的三种基本状态</h2><ol><li>运行状态（Running）：是指进程已获得处理器，并且在处理器上执行的状态。</li><li>就绪状态（Ready）：是指一个进程已经具备运行条件，但由于没有获得处理器而不能运行所处的状态。一旦把处理器分配给它，该进程就可运行。处于就绪状态的进程可以是多个。</li><li>等待状态（Waiting）：也称阻塞状态或封锁状态。是指进程因等待某种事件发生而暂时不能运行的状态。</li></ol><h2 id="3-2-进程状态间的转换"><a href="#3-2-进程状态间的转换" class="headerlink" title="3.2 进程状态间的转换"></a>3.2 进程状态间的转换</h2><p><img src="https://personal-blog.oss-cn-hangzhou.aliyuncs.com/OS_Process_status.png"></p><h2 id="3-3-进程的五状态模型"><a href="#3-3-进程的五状态模型" class="headerlink" title="3.3 进程的五状态模型"></a>3.3 进程的五状态模型</h2><ol><li>运行状态（Running）：进程占用处理器资源，处于此状态的进程的数目小于等于处理器的数目。在没有其它进程可以执行时，通常会自动执行系统的空闲进程；</li><li>就绪状态（Ready）：进程已获得除处理器外的所需资源，等待分配处理器资源，只要分配处理器就可执行；</li><li>阻塞状态（Blocked）：由于进程等待 I&#x2F;O 操作或进程同步等条件而暂停运行时处于阻塞状态。在条件满足之前，即使把处理器分配给该处理器，也是无法继续执行的；</li><li>创建状态（New）：进程正在创建过程中，还不能运行。操作系统在创建状态要进行的工作包括分配和建立进程控制块表项、建立资源表格（如打开文件表），并分配资源，加载程序并建立地址空间等；</li><li>结束状态（Exit）：进程已结束运行，回收除进程控制块之外的其他资源，并让其他进程从进程控制块中手机有关信息；</li></ol><p><img src="https://personal-blog.oss-cn-hangzhou.aliyuncs.com/OS_Process_status_five.png"></p><h2 id="3-4-进程的七状态模型"><a href="#3-4-进程的七状态模型" class="headerlink" title="3.4 进程的七状态模型"></a>3.4 进程的七状态模型</h2><ol><li>就绪状态（Ready）：进程在内存且可立即进入运行状态；</li><li>阻塞状态（Blocked）：进程在内存并等待某事件的出现；</li><li>阻塞挂起状态（Blocked，Suspend）：进程在外存并等待某事件的出现；</li><li>就绪挂起状态（Readu，Suspend）：进程在外存，但只要进入内存，即可运行；</li></ol><p><img src="https://personal-blog.oss-cn-hangzhou.aliyuncs.com/OS_Process_status_seven.png"></p><h1 id="4-进程控制块"><a href="#4-进程控制块" class="headerlink" title="4 进程控制块"></a>4 进程控制块</h1><h2 id="4-1-进程控制块的作用"><a href="#4-1-进程控制块的作用" class="headerlink" title="4.1 进程控制块的作用"></a>4.1 进程控制块的作用</h2><p>为了便于系统控制和描述进程的活动过程，在操作系统核心中定义了一个专门的数据结构，称为进程控制块（Process Control Block，PCB）。</p><p>操作系统利用 PCB 来描述进程的基本情况以及进程的运行变化过程。PCB 是进程存在的唯一标志，当系统创建一个进程时，为进程设置一个 PCB，再利用 PCB 对进程进行控制和管理。撤销进程时，系统收回它的 PCB，进程也随之消亡。</p><h2 id="4-2-进程控制块的基本内容"><a href="#4-2-进程控制块的基本内容" class="headerlink" title="4.2 进程控制块的基本内容"></a>4.2 进程控制块的基本内容</h2><p>进程控制块的内容可以分成调度信息和现场信息两大部分。调度信息供进程调度时使用，描述了进程当前所处的状况，它包括进程名、进程号、地址空间信息、优先级、当前状态、资源清单、「家族」关系、消息队列指针、进程队列指针和当前打开文件等。</p><p>在调度信息中，进程名和进程号的作用是标识一个进程，一个进程的进程号必须是唯一的，用以说明进程的存在并区分各个进程。</p><h2 id="4-3-进程队列"><a href="#4-3-进程队列" class="headerlink" title="4.3 进程队列"></a>4.3 进程队列</h2><ol><li>就绪队列；</li><li>等待队列；</li><li>运行队列；</li></ol><h1 id="5-进程控制"><a href="#5-进程控制" class="headerlink" title="5 进程控制"></a>5 进程控制</h1><p>进程有一个从创建到消亡的生命周期，这就需要对进程在整个生命周期中各种状态之间的转换进行有效的控制，称为进程控制。进程控制是通过进程控制原语来实现的。</p><p>所谓原语，是由若干条指令所组成的一个指令序列，用来实现某个特定的操作功能。这个指令序列的执行是连续的，具有不可分割性，在执行时也不可间断，直至该指令序列执行结束。原语又可称为原子操作。</p><h2 id="5-1-进程创建"><a href="#5-1-进程创建" class="headerlink" title="5.1 进程创建"></a>5.1 进程创建</h2><p>一个进程可以使用创建原语创建一个新的进程，前者称为父进程，后者称为子进程。子进程又可以创建新的子进程，构成新的父子关系，从而整个系统可以形成一个树形结构的进程家族。</p><p>创建一个进程的主要任务是建立进程控制块 PCB。</p><p>创建进程的具体操作过程是：先申请一空闲 PCB 区域，然后将有关信息填入 PCB，置该进程为就绪状态，最后把它插入就绪队列中。</p><h2 id="5-2-进程撤销"><a href="#5-2-进程撤销" class="headerlink" title="5.2 进程撤销"></a>5.2 进程撤销</h2><p>当一个进程完成任务后，就应当撤销它，以便及时释放它所占用的资源。撤销进程的实质是撤销 PCB。一旦 PCB 撤销，进程就消亡了。</p><p>撤销进程的具体操作过程是：找到要被撤销进程的 PCB，将它从所在队列中消去，撤销属于该进程的一切「子孙进程」，释放被撤销进程所占用的全部资源，并消去被撤销进程的 PCB。</p><h2 id="5-3-进程等待"><a href="#5-3-进程等待" class="headerlink" title="5.3 进程等待"></a>5.3 进程等待</h2><p>若某个进程的执行过程中，需要执行 I&#x2F;O 操作，则由该进程调用阻塞原语把进程从运行状态转换为阻塞状态。</p><p>具体的操作过程是：由于进程正处于运行状态，因此首先应中断处理器的执行，把处理器的当前状态保存在 PCB 的现场信息中，然后把进程的当前状态置为等待状态，并把它插入到该事件的等待队列中去。</p><h2 id="5-4-进程唤醒"><a href="#5-4-进程唤醒" class="headerlink" title="5.4 进程唤醒"></a>5.4 进程唤醒</h2><p>一个进程因为等待某事件的发生而处于等待状态，当该事件发生后，就用唤醒原语将其转换为就绪状态。</p><p>具体操作过程是：在等待队列中找到该进程，将进程的当前状态置为就绪状态，然后将它从等待队列中撤出并插入到就绪队列中排队，等待调度执行。</p><h1 id="6-线程模型"><a href="#6-线程模型" class="headerlink" title="6 线程模型"></a>6 线程模型</h1><h2 id="6-1-线程的基本概念"><a href="#6-1-线程的基本概念" class="headerlink" title="6.1 线程的基本概念"></a>6.1 线程的基本概念</h2><p>在引入线程的操作系统中，线程是进程中的一个实体，是处理器调度和分派的基本单位。线程自己基本上不拥有系统资源，只拥有少量在运行中必不可少的资源（如程序计数器、一组寄存器和栈等），但它可与同属一个进程的其他线程共享进程所拥有的全部资源。</p><p>一个线程可以创建和撤销另一个线程；同一个进程中的多个线程之间可以并发执行。由于线程之间的相互制约，致使线程在运行中也呈现出间断性。相应地，线程也同样有就绪、等待和运行三种基本状态。有的系统中线程还有终止状态等。</p><h2 id="6-2-线程的属性"><a href="#6-2-线程的属性" class="headerlink" title="6.2 线程的属性"></a>6.2 线程的属性</h2><ol><li>每个线程有一个唯一的标识符和一张线程描述表，线程描述表记录了线程执行的寄存器以及栈等现场状态；</li><li>不同的线程可以执行相同的程序，即同一个服务程序被不同用户调用时操作系统为它们创建不同的线程；</li><li>同一个进程中的各个线程共享该进程的内存地址空间；</li><li>线程时处理器的独立调度单位，多个线程时可以并发执行的。在单处理器的计算机系统中，各线程可交替地占用处理器；在多处理器的计算机系统中，各线程可同时占用不同的处理器；若各个处理器同时为一个进程内的各线程服务，则可缩短进程的处理时间；</li><li>一个线程在被创建后便开始了它的生命周期，直至终止；线程在生命周期内会经历等待状态、就绪态和运行态等各种状态变化；</li></ol><h2 id="6-3-为什么引入线程的概念"><a href="#6-3-为什么引入线程的概念" class="headerlink" title="6.3 为什么引入线程的概念"></a>6.3 为什么引入线程的概念</h2><ol><li>创建一个新线程花费时间少（结束亦如此）。创建线程不需另行分配资源，因而创建线程的速度比创建进程的速度快，且系统的开销也少；</li><li>线程之间的切换花费时间少；</li><li>由于同一个进程内的线程共享内存和文件，所以线程之间相互通信无须调用内核，故不需要额外的通信机制，使通信更简便，信息传送速度也快；</li><li>线程能独立运行，能充分利用和发挥处理器与外部设备并行工作能力；</li></ol><h1 id="7-线程机制的实现"><a href="#7-线程机制的实现" class="headerlink" title="7 线程机制的实现"></a>7 线程机制的实现</h1><h2 id="7-1-用户级线程"><a href="#7-1-用户级线程" class="headerlink" title="7.1 用户级线程"></a>7.1 用户级线程</h2><p>用户级线程只存在于用户态中，对它的创建、撤销和切换不会通过系统调用来实现，因而这种线程与内核无关。相应地，内核也并不知道有用户级线程的存在，从内核角度考虑，就是按正常的方式管理，即单线程进程。</p><h2 id="7-2-内核级线程"><a href="#7-2-内核级线程" class="headerlink" title="7.2 内核级线程"></a>7.2 内核级线程</h2><p>内核级线程依赖于内核，即无论是在用户进程中的线程，还是系统进程中的线程，它们的创建、撤销和切换都由内核实现。在内核中保留了一个线程控制块，系统根据该控制块儿感知该线程的存在并对线程进行控制。</p><h2 id="7-3-混合模型"><a href="#7-3-混合模型" class="headerlink" title="7.3 混合模型"></a>7.3 混合模型</h2><p>一种方法是使用内核级线程，然后将用户级线程与某些或者全部内核线程多路复用起来。如果采用这种方法，变成人员可以决定有多少个内核级线程和多少个用户级先彼此多路复用。这一模型带来最大的灵活度。</p><h2 id="7-4-Pthread-线程包"><a href="#7-4-Pthread-线程包" class="headerlink" title="7.4 Pthread 线程包"></a>7.4 Pthread 线程包</h2><p>所有 Pthread 线程都有某些特性。每一个都含有一个标识符、一组寄存器（包括程序计数器）和一组存储在结构中的属性。这些属性包括栈大小、调度参数以及其它线程需要的项目。</p><h1 id="8-进程调度"><a href="#8-进程调度" class="headerlink" title="8 进程调度"></a>8 进程调度</h1><p>进程调度即处理器调度。在多道程序设计环境中，进程数目往往多于处理器数，这将导致多个进程互相争夺处理器。</p><h2 id="8-1-进程调度的层次和任务"><a href="#8-1-进程调度的层次和任务" class="headerlink" title="8.1 进程调度的层次和任务"></a>8.1 进程调度的层次和任务</h2><p>记录系统中所有进程的执行状况；根据一定的调度算法，从就绪队列中选出一个进程，准备把处理器分配给它；把处理器分配给进程。即把选中进程的进程控制块内有关的线程信息，如程序状态字、通用寄存器等内容送入处理器相应的寄存器中，从而让它占用处理器运行。</p><h2 id="8-2-进程的调度时机"><a href="#8-2-进程的调度时机" class="headerlink" title="8.2 进程的调度时机"></a>8.2 进程的调度时机</h2><ol><li>正在执行的进程运行完毕；</li><li>正在执行的进程由于某种错误而终止；</li><li>时间片用完，即有一个进程从运行状态变为就绪状态；</li><li>正在执行的进程调用阻塞原语将自己阻塞起来，即一个进程从运行状态进入阻塞状态；</li><li>创建了新的进程，即有一个新的进程进入就绪队列；</li><li>正在执行的进程调用了唤醒原语操作激活了等待资源的进程，即一个等待状态的进程变为就绪状态；</li></ol><p>处理器的调度方式有两种：<strong>抢占式</strong> 和 <strong>非抢占式（又称为不可抢占式）</strong>。</p><h2 id="8-3-进程的调度过程"><a href="#8-3-进程的调度过程" class="headerlink" title="8.3 进程的调度过程"></a>8.3 进程的调度过程</h2><p>进程调度的任务是控制、协调进程对处理器的竞争，按照一定的调度算法，使某一就绪进程获得 CPU 的控制权，转换成运行状态。实际上进程调度完成一个物理 CPU 转变成多个虚拟的（或逻辑的）处理器的工作。</p><h2 id="8-4-进程调度算法的设计思想"><a href="#8-4-进程调度算法的设计思想" class="headerlink" title="8.4 进程调度算法的设计思想"></a>8.4 进程调度算法的设计思想</h2><p>设计调度算法的目标取决于环境。例如批处理、交互式或实时，但是，有一些目标是适用于所有系统的。</p><p>在所有的情形中，公平是很重要的。相似的进程应该得到相似的服务。多一个进程给予较其他等价的进程更多的处理器时间是不公平的。当然，不同类型的进程可以采用不同方式处理。</p><p>与公平有关的是系统策略的强制执行。如果局部策略是只要需要就必须运行安全控制进程，那么调度程序就必须保证能够强制执行该策略。</p><p>另一个共同的目标是保持系统的所有部分尽可能忙碌。</p><h2 id="8-5-进程调度算法的应用"><a href="#8-5-进程调度算法的应用" class="headerlink" title="8.5 进程调度算法的应用"></a>8.5 进程调度算法的应用</h2><ol><li>先来先服务算法；</li><li>最短进程优先算法；</li><li>最短剩余时间优先算法；</li><li>最高响应比优先算法；</li><li>轮转算法；</li><li>最高优先级算法；</li><li>多级反馈队列算法；</li></ol><h1 id="9-系统内核"><a href="#9-系统内核" class="headerlink" title="9 系统内核"></a>9 系统内核</h1><p>为了提高系统的运行效率、保护系统的关键部分不被破坏，一般把操作系统中提供支持系统运行的各种基本操作和基础功能的一组程序模块集中安排，形成一个操作系统的核心，称为系统核心或系统内核，简称内核（Kernel）。</p>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>操作系统运行环境</title>
      <link href="/2021/03/16/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%BF%90%E8%A1%8C%E7%8E%AF%E5%A2%83/"/>
      <url>/2021/03/16/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%BF%90%E8%A1%8C%E7%8E%AF%E5%A2%83/</url>
      
        <content type="html"><![CDATA[<p>操作系统作为一个程序要在处理器上执行。如果一个计算机系统只有一个处理器，我们称之为单机系统，如果有多个处理器则称之为多处理器系统。</p><p><img src="https://personal-blog.oss-cn-hangzhou.aliyuncs.com/OS_chapter_2.png"></p><h1 id="1-处理器状态及状态转换"><a href="#1-处理器状态及状态转换" class="headerlink" title="1 处理器状态及状态转换"></a>1 处理器状态及状态转换</h1><h2 id="1-1-特权指令和非特权指令"><a href="#1-1-特权指令和非特权指令" class="headerlink" title="1.1 特权指令和非特权指令"></a>1.1 特权指令和非特权指令</h2><p>特权指令：是指令系统中那些只能由操作系统使用的指令。这些特权指令是不允许一般的用户使用的，因为如果允许用户随便使用这些指令，就有可能是系统陷入混乱。</p><p>用户只能使用非特权指令，只有操作系统才能使用所有的指令。</p><p>如果一个用户程序需要使用特权指令，一般将引起一次处理器状态的切换，这时处理器通过特殊的机制，将处理器状态切换到操作系统运行的特权状态，然后将处理权移交给操作系统中的一段特殊代码。这一过程通常形象地称为 <strong>陷入（Trap）</strong>。</p><h2 id="1-2-控制寄存器及程序状态字"><a href="#1-2-控制寄存器及程序状态字" class="headerlink" title="1.2 控制寄存器及程序状态字"></a>1.2 控制寄存器及程序状态字</h2><p>最常见的控制和状态寄存器有程序计数器（Program Counter，PC），它记录了将要取出的指令的地址；指令寄存器（Instruction Register，IR），包含了最近取出的指令；程序状态字（Program Status Word， PSW），它记录了处理器的运行模式信息等。</p><p>为了解决处理器当前工作状态的问题，所有的处理器都有一些特殊寄存器，用以表明处理器当前的工作状态。比如用一个专门的寄存器来指示处理器状态，称为程序状态字（PSW）；</p><p>处理器的状态字（PSW）通常包含以下状态代码：</p><ol><li>CPU 的工作状态代码 — 指明当前处理器的工作状态是管态还是目态，用来说明当前在处理器上执行的是操作系统还是一般用户，从而决定其是否可以使用特权指令或拥有其他的特殊权力；</li><li>条件码 — 反映质量执行后的结果特征；</li><li>中断屏蔽码 — 指出是否允许中断；</li></ol><p>部分标志位：</p><blockquote><p>CF：进位标志位；<br/><br>ZF：结果为零标志位；<br/><br>SF：符号标志位；<br/><br>OF：溢出标志位；<br/><br>TF：陷阱标志位；<br/><br>IF：中断使能（中断屏蔽）标志位；<br/><br>VIF：虚拟中断标志位；<br/><br>VIP：虚拟中断待决标志位；<br/><br>IOPL：IO 特权级别；</p></blockquote><h2 id="1-3-处理器状态及状态转换"><a href="#1-3-处理器状态及状态转换" class="headerlink" title="1.3 处理器状态及状态转换"></a>1.3 处理器状态及状态转换</h2><p>在执行不同程序时，根据运行程序对资源和机器指令的使用权限而将此时的处理器设置为不同的状态。</p><p>多数系统将处理器工作状态划分为管态和目态。前者一般指操作系统管理程序运行的状态，具有较高的特权级别，又称为内核态、特权态（特态）、系统态；后者一般指用户程序运行时的状态，具有较低的特权级别，又称为用户态、普通胎（普态）。</p><h3 id="1-3-1-目态到管态的转换"><a href="#1-3-1-目态到管态的转换" class="headerlink" title="1.3.1 目态到管态的转换"></a>1.3.1 目态到管态的转换</h3><p>转换的唯一途径是通过中断。中断响应时交换中断向量，新的中断向量中的 PSW 的处理器状态位标志为管态。</p><h3 id="1-3-2-管态到目态的转换"><a href="#1-3-2-管态到目态的转换" class="headerlink" title="1.3.2 管态到目态的转换"></a>1.3.2 管态到目态的转换</h3><p>可通过设置 PSW 指令（修改程序状态字），实现从操作系统向用户程序的转换。</p><h1 id="2-中断-异常机制"><a href="#2-中断-异常机制" class="headerlink" title="2 中断&#x2F;异常机制"></a>2 中断&#x2F;异常机制</h1><p>中断机制是操作系统中极为重要的一个部分。操作系统在管理输入输出设备时，在处理外部的各种事件时，都要通过中断机制进行处理。所以也有人把操作系统称为是由「中断驱动」或者「（中断）事件驱动」的。</p><p>由于中断机制的实现必须依靠相关的硬件支持，所以硬件中断装置是操作系统运行环境中的一个极为重要的组成部分。中断的实现是硬件中断装置和相应的中断处理软件共同完成的。</p><h2 id="2-1-中断-异常的基本概念"><a href="#2-1-中断-异常的基本概念" class="headerlink" title="2.1 中断&#x2F;异常的基本概念"></a>2.1 中断&#x2F;异常的基本概念</h2><p>中断是指处理器对系统中或系统外发生的异步事件的响应。异步事件是指一定时序关系的随机发生的事件，如外部设备完成了数据传输任务，某一实时控制设备出现异常情况等。</p><p>最早中断和异常并没有区分，都把它们叫做中断。随着它们的发生原因和处理方式的差别愈发明显，才有了现在的中断和异常之分。</p><p>中断是由外部事件引发的，而异常则是由正在执行的指令引发的。</p><h2 id="2-2-中断-异常的类型"><a href="#2-2-中断-异常的类型" class="headerlink" title="2.2 中断&#x2F;异常的类型"></a>2.2 中断&#x2F;异常的类型</h2><p>典型的中断包括：</p><ol><li>时钟中断，由处理器内部的计时器产生，运行操作系统以一定规律执行函数，如时间片到时、硬件实时钟到时等；</li><li>输入输出（I&#x2F;O）中断，由 I&#x2F;O 控制器产生，用于通知一个 I&#x2F;O 操作的正常完成或发生的错误；</li><li>控制台中断，如系统操作员通过控制台发出命令等；</li><li>硬件故障中断，由掉电、存储器校验错等硬件故障引起等；</li></ol><p>异常发生的时间及位置具有确定性，典型的异常包括：</p><ol><li>程序性中断，在某些条件下由指令执行结果产生，例如算术溢出、被零除等；</li><li>访管指令异常，目的是要求操作系统提供系统服务；</li></ol><h2 id="2-3-中断-异常响应过程"><a href="#2-3-中断-异常响应过程" class="headerlink" title="2.3 中断&#x2F;异常响应过程"></a>2.3 中断&#x2F;异常响应过程</h2><p>中断请求的响应机制如下。处理器的控制部件中设置有中断信号扫描结构，它在每条指令执行周期内的最后时刻扫描中断寄存器，查看是否有中断信号到来。若无中断信号，处理器就继续执行下一条指令。若有中断到来，处理器接收由硬件中断装置发来的中断向量代号。</p><p>接着，处理器开始为后续的软件处理中断做必要的准备工作：保存中断点的程序执行上下文环境（又称现场保存）。</p><p>处理器根据中断向量代号查询中断向量表，获得与该中断源相联系的中断处理程序的入口地址，并将 PC 置成该地址。随后控制权转移到中断处理程序。</p><ol><li>处理器接收中断信号；</li><li>保护现场，将中断断点的程序状态字 PSW 和程序计数器 PC 值存入系统堆栈；</li><li>分析中断向量，取得中断处理程序的入口地址；</li><li>将处理器的 PC 值置为中断处理程序的入口地址；</li><li>调用中断处理程序；</li></ol><h2 id="2-4-中断-异常处理程序"><a href="#2-4-中断-异常处理程序" class="headerlink" title="2.4 中断&#x2F;异常处理程序"></a>2.4 中断&#x2F;异常处理程序</h2><ol><li>接收和响应中断；</li><li>保护中断断点现场；</li><li>分析中断向量；</li><li>调用中断处理程序；</li><li>中断处理结束恢复现场；</li><li>原有程序继续执行；</li></ol><h1 id="3-计算机系统中的相关硬件部件"><a href="#3-计算机系统中的相关硬件部件" class="headerlink" title="3 计算机系统中的相关硬件部件"></a>3 计算机系统中的相关硬件部件</h1><p>在计算机系统中，中央处理器能直接访问的唯一的存储空间是内存储器。任何程序和数据必须被装入内存储器之后，中央处理器才能对它们进行操作，因而一个作业必须把它的程序和数据存储在内存储器中才能运行，而且操作系统本身也要存储在内存储器中并运行。</p><h2 id="3-1-存储系统"><a href="#3-1-存储系统" class="headerlink" title="3.1 存储系统"></a>3.1 存储系统</h2><p>类型：读写型存储器和只读型存储器。</p><h3 id="3-1-1-存储分块"><a href="#3-1-1-存储分块" class="headerlink" title="3.1.1 存储分块"></a>3.1.1 存储分块</h3><p>存储的最小单位称为「二进位」，它包含的信息为 0 或 1。存储器的最小编址单位是字节，一个字节一般包含 8 个二进位。而 2 个字节一般称为一个字，4 个字节称为双字。</p><p>为了简化对存储器的分配和管理，在不少计算机系统中把存储器分成块。在为用户分配内存空间时，以块为最小单位，这样的块有时被称为一个物理页（Page）。而块的大小随机器而异，512B、1KB、4KB、8KB 的都有，也有其他大小的。</p><h3 id="3-1-2-存储器的层次结构"><a href="#3-1-2-存储器的层次结构" class="headerlink" title="3.1.2 存储器的层次结构"></a>3.1.2 存储器的层次结构</h3><p>从整个系统来看，在计算机系统中的层次化的存储体系是由寄存器、高速缓存、内存储器、硬盘存储器、磁带机和光盘存储器等装置构成的。较小、较贵而快速的存储设备由较大、较便宜而慢速的存储设备作后盾，在整体上通过对访问频率的控制来提高存储系统的性能。</p><h3 id="3-1-3-存储器保护"><a href="#3-1-3-存储器保护" class="headerlink" title="3.1.3 存储器保护"></a>3.1.3 存储器保护</h3><p>存储在内存中的用户程序和操作系统，以及它们的数据，有可能受到正在 CPU 上运行的某用户程序的有意或无意的破坏，这会造成十分严重的后果。一旦有程序向操作系统区写入了数据，将有可能造成系统崩溃。对内存中的信息加以严格的保护，使操作系统及其他程序不被破坏，是其正确运行的基本条件之一。</p><h2 id="3-2-I-O-部件"><a href="#3-2-I-O-部件" class="headerlink" title="3.2 I&#x2F;O 部件"></a>3.2 I&#x2F;O 部件</h2><h3 id="3-2-1-I-O-结构"><a href="#3-2-1-I-O-结构" class="headerlink" title="3.2.1 I&#x2F;O 结构"></a>3.2.1 I&#x2F;O 结构</h3><p>在每台外部设备中都配有各自的 I&#x2F;O 设备控制器，由 I&#x2F;O 设备控制器分别控制各台外部设备的运行。在 I&#x2F;O 设备控制器与处理器之间的 I&#x2F;O 硬件结构，则有不同的方案。</p><h3 id="3-2-2-通道"><a href="#3-2-2-通道" class="headerlink" title="3.2.2 通道"></a>3.2.2 通道</h3><p>通道是独立于中央处理器的，专门负责数据 I&#x2F;O 传输工作的处理单元。从现代计算机系统的结构上看，各种外部设备均配有响应的设备控制器，这些设备控制器再通过通道连接在计算机系统的公共系统总线上。</p><p>通道对外部设备实行统一的管理，它代理处理器对 I&#x2F;O 操作进行控制，从而使处理器和外部设备可以并行工作。所以通道又称为 I&#x2F;O 处理器。</p><h3 id="3-2-3-DMA-技术"><a href="#3-2-3-DMA-技术" class="headerlink" title="3.2.3 DMA 技术"></a>3.2.3 DMA 技术</h3><p>直接存储器访问（Direct Memory Access，DMA）技术通过系统总线中的一个独立控制单元 — DMA 控制器，自动地控制成块数据在内存和 I&#x2F;O 单元之间的传送。当处理器需要读写一整块数据的时候，它给 DMA 控制单元发送一条命令，在命令中通常包含了 I&#x2F;O 设备的标志、开始读或写的内存编址、需要传送的数据长度、是否请求一次读或写等信息。处理器在给 DMA 控制单元发送完一条命令之后，就可以处理其他的事情了。而 DMA 控制器将自动管理整块数据的传送。当这个传送过程完成后，它会给处理器发一个中断。这样处理器只需要在整块数据开始传送和传送结束时关注以下就可以了。</p><h3 id="3-2-4-缓冲技术"><a href="#3-2-4-缓冲技术" class="headerlink" title="3.2.4 缓冲技术"></a>3.2.4 缓冲技术</h3><p>缓存技术是用在外部设备与其他硬件部件之间的一种数据暂存技术，它利用存储器件在外部设备中设置了数据的一个存储区域，称为缓冲区。缓冲技术一般有两种用途，一种是用在外部设备与外部设备之间的通信上的，还有一种是用在外部设备和处理器之间的。</p><p>采用缓存技术最根本的原因是，处理器处理数据速度与设备传输数据速度不相匹配，需要用缓冲区环节其间的速度矛盾。</p><h2 id="3-3-时钟"><a href="#3-3-时钟" class="headerlink" title="3.3 时钟"></a>3.3 时钟</h2><p>时钟一般分为硬件时钟和软件时钟。</p><p>硬件时钟的工作原理是，在电路中的晶体振荡器，每隔一定间隔产生固定的脉冲频率，时钟电路中的时钟寄存器依据时钟电路所产生的脉冲数，对时钟寄存器进行加 1 的工作。</p><p>软件时钟，常用作相对时钟，它的工作原理主要是利用内存单元模拟时钟寄存器，并采用一段程序来计算相应的脉冲数，对内存时钟寄存器进行加 1 或减 1 的工作，从而模拟了时钟的功能。</p><p>时钟的用途可以分为绝对时钟和相对时钟。</p><p>绝对时钟是在计算机系统中不受外界干扰、独立运行的一种时钟。一般来说，绝对时钟很准确，它通常不会被停止，当计算机系统关机时，绝对时钟值仍然始终不停地保持运行，作为整个计算机系统中的时间参考基准。</p><p>相对时钟又称间隔时钟。它只计算从某一个时间初值开始的一段时间间隔。由操作人员置上时间间隔的初值，以后每经过一个单位的时间，时钟值自动减 1，知道该值为负时，则触发一个时钟中断，并进行相应的处理。</p><h1 id="4-系统调用"><a href="#4-系统调用" class="headerlink" title="4 系统调用"></a>4 系统调用</h1><p>系统调用，就是用户在程序中调用操作系统所提供的一些子功能。这是一种特殊的过程调用，这种调用通常是由特殊的机器指令实现的。除了提供对操作系统字程序的调用外，这条指令还将系统转入特权方式（管态）。</p>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>操作系统概论</title>
      <link href="/2021/03/14/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA/"/>
      <url>/2021/03/14/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA/</url>
      
        <content type="html"><![CDATA[<p>计算机系统是一种可以按用户要求接收和存储信息、自动进行数据处理并输出结果信息的系统。广义的计算机系统包含 <strong>机械式系统</strong> 和 <strong>电子式系统</strong> 两类。在电子式系统中，还可以划分为 <strong>模拟式</strong> 和 <strong>数字式</strong> 两种计算机系统。</p><p>计算机系统包括硬件（子）系统和软件（子）系统。硬件系统是计算机系统赖以工作的实体。软件系统保证计算机系统按用户指定的要求协调工作。这两个部分构成了计算机系统的资源。因此，计算机系统的资源包括两大类：硬件资源和软件资源。</p><p><img src="https://personal-blog.oss-cn-hangzhou.aliyuncs.com/OS_chapter_1.png"></p><h1 id="1-操作系统的地位和作用"><a href="#1-操作系统的地位和作用" class="headerlink" title="1 操作系统的地位和作用"></a>1 操作系统的地位和作用</h1><p>操作系统是计算机系统中的一个系统软件，它是这样一些程序模块的集合：它们能有效地组织和管理计算机系统中的硬件及软件资源，合理地组织计算机工作流程，控制程序的执行，并想用户提供各种服务功能，是的用户能够灵活、方便、有效地使用计算机，并使整个计算机系统能高效地运行。</p><h2 id="1-1-操作系统是计算机资源的管理者"><a href="#1-1-操作系统是计算机资源的管理者" class="headerlink" title="1.1 操作系统是计算机资源的管理者"></a>1.1 操作系统是计算机资源的管理者</h2><p>在操作系统内部，为了掌握整个计算机系统的硬件和软件资源，设计了各种不同类型的表格或数据结构，将所有的硬件和软件资源一一加以等级，资源的名称、类型、数量、用途、完好状态以及目前使用状态等所有信息，均在有关数据结构中保存，并动态地、实时地不断更新着这些数据。记录数据的目的是：让操作系统根据用户对各种资源的需求情况，资源的当前分配和使用情况以及有关的资源调度策略，对资源进行有效的组织和管理。</p><p>「有效」是指操作系统在管理计算机资源时要考虑到系统运行的效率和资源的利用率。要尽可能提高中央处理器的利用率，让它尽可能少的空转，应该在保证访问效能的前提下尽可能有效利用其它资源，例如减少对内存、磁盘空间的浪费等。</p><h2 id="1-2-操作系统通过接口为用户提供各种服务"><a href="#1-2-操作系统通过接口为用户提供各种服务" class="headerlink" title="1.2 操作系统通过接口为用户提供各种服务"></a>1.2 操作系统通过接口为用户提供各种服务</h2><p>从用户的观点来看，操作系统是用户与计算机系统之间的接口。因此，接口管理的任务是为用户提供一个使用系统的良好环境，使用户能有效地组织自己的工作流程，并使整个系统能高效地运行。</p><h1 id="2-操作系统的特征"><a href="#2-操作系统的特征" class="headerlink" title="2 操作系统的特征"></a>2 操作系统的特征</h1><h2 id="2-1-并发性"><a href="#2-1-并发性" class="headerlink" title="2.1 并发性"></a>2.1 并发性</h2><p>并发性是指在计算机系统中同时存在若干个运行着的程序，从宏观上看，这些程序在同时向前推进。</p><p>进一步分析，计算机程序的并发性体现在以下两个方面：</p><ol><li>用户程序与用户程序之间；</li><li>用户程序与操作系统之间并发执行；</li></ol><p><strong>并行性</strong> 是指两个或多个事件在同一时刻发生，这是一个具有微观意义的概念，即在物理上这些事件是同时发生的。</p><p><strong>并发性</strong> 是指两个或多个事件在同一时间间隔内发生，它是一个较为宏观的概念，与所使用的时间间隔相对应的、有某种程序的统计意义。</p><h2 id="2-2-共享性"><a href="#2-2-共享性" class="headerlink" title="2.2 共享性"></a>2.2 共享性</h2><p>共享性是指操作系统程序与多个用户程序共用系统中的各种资源。这种共享性是在操作系统控制下实现的。资源的共享性主要针对计算机系统中的以下几项重要资源：</p><ol><li>中央处理器；</li><li>内存储器；</li><li>外存储器；</li><li>外部设备；</li></ol><p>在计算机系统中，对资源的共享一般有两种形式：<strong>互斥共享</strong> 和 <strong>同时共享</strong>。</p><h2 id="2-3-虚拟性"><a href="#2-3-虚拟性" class="headerlink" title="2.3 虚拟性"></a>2.3 虚拟性</h2><p>在操作系统的支持下，用户不需要直接使用硬件机器（称为裸机），而是通过操作系统提供的各种手段来控制和使用计算机。操作系统把原来的计算机（裸机）扩充称为功能强、使用方便的计算机系统，我们把这种计算机系统称为虚拟计算机，而把操作系统的全部功能，包括系统调用、命令、作业控制语言等，统称为操作系统虚拟机。</p><h2 id="2-4-随机性"><a href="#2-4-随机性" class="headerlink" title="2.4 随机性"></a>2.4 随机性</h2><p>操作系统的运行是在一种随机的环境下进行的。这种随机环境的含义是，操作系统不能对所运行的程序的行为以及硬件设备的情况作出任何事先的假定。显然，一个设备可能在任何时候想处理器发出中断请求，而用户提交的、运行着的程序要做什么事情也无法事先知道。因而一般来说操作系统正处于什么样的状态之中是无法确切知道的，这就是随机性的含义。</p><p>但是，随机性并不意味这操作系统不能很好地控制资源的使用和程序的运行，随机性突出强调了在进行操作系统的设计与实现时要充分考虑各种各样的可能性。操作系统本身应该稳定、可靠、安全、高效，实现程序并发和资源共享的目的。</p><h1 id="3-操作系统的体系结构"><a href="#3-操作系统的体系结构" class="headerlink" title="3 操作系统的体系结构"></a>3 操作系统的体系结构</h1><h2 id="3-1-Windows-操作系统的体系结构"><a href="#3-1-Windows-操作系统的体系结构" class="headerlink" title="3.1 Windows 操作系统的体系结构"></a>3.1 Windows 操作系统的体系结构</h2><p>Windows 体系结构是分层的模块系统，主要层次有硬件抽象层 HAL、内核、执行体和大量的子系统集合。前面三个都运行在保护模式下，而各子系统都在用户模式下运行。子系统又可分为环境子系统和保护子系统两类，其中环境子系统仿真不同的操作系统，保护子系统提供安全功能。</p><p>内核：内核执行 Windows 操作系统中最基本的操作，主要提供下列功能：线程调度、陷入处理和异常调度、中断处理和调度、多处理器同步、供执行体使用的基本内核对象。</p><p>硬件抽象层（HAL）：Windows 操作系统设计的一个至关重要的方面就是在多种硬件平台上的可移植性，HAL 就是使这种可移植性成为可能的关键部分。</p><p>执行体：Windows 的执行体是 NTOSKRNL.EXE 的上层（内核是其下层）。执行体从用户态导出并且可以调用函数，这些函数的接口在 NTDLL.DLL 中，通过 Win32API 可以对它们进行访问。</p><p>系统进程和系统线程：系统进程是一种特殊类型的、只运行在核心态的「系统线程」的宿主。系统线程具有一般用户态线程的所有属性和描述表，不同点在于它们仅运行在内核态，执行加载于系统空间中的代码。另外，系统线程没有用户进程地址空间，因此必须从系统内存堆中分配动态存储区。</p><h2 id="3-2-UNIX-操作系统的体系结构"><a href="#3-2-UNIX-操作系统的体系结构" class="headerlink" title="3.2 UNIX 操作系统的体系结构"></a>3.2 UNIX 操作系统的体系结构</h2><p>最里层是硬件，作为整个系统的基础；紧邻最里层的是操作系统内核，包括进程管理、存储器管理、设备管理和文件管理四个资源管理功能；往外一层是系统调用接口，即操作系统与用户的接口 Shell 以及编译程序等；最外层是应用程序。</p><p>内核层：内核层是操作系统管理和控制中心，常驻内存。其具有两方面的接口，一方面是内核与原件的接口，它通常是由一组驱动程序和一些基本的例程所组成；另一方面是内核与 Shell 的接口，它由两组系统调用及命令解释程序等所组成。内核本身又可分为两大部分，一部分是进程控制子系统；另一部分是文件子系统。两组系统调用分别于这两大子系统交互。</p><ol><li>进程控制子系统，复杂对四个资源中的两个资源-处理器和存储器进行管理。其功能可分为进程控制、进程通信、存储器管理和进程调度。</li><li>文件子系统，负责有效的管理系统中所有的设备和文件。其功能可分成以下三个方面，即文件管理、高速缓存机制和设备驱动程序。</li></ol><p>系统调用层：系统调用层界于内核层和应用层之间，是供程序员设计、开发应用程序时调用的。</p><p>应用层：应用层包括各种开发工具、高级语言编译器、网络通信处理程序等。</p><h2 id="3-3-Linux-操作系统的体系结构"><a href="#3-3-Linux-操作系统的体系结构" class="headerlink" title="3.3 Linux 操作系统的体系结构"></a>3.3 Linux 操作系统的体系结构</h2><p>Linux 系统有四个主要部分，即内核、Shell、文件系统和用户应用程序。</p><p>Linux 内核：内核是操作系统的核心，它负责管理系统的进程、内存、设备驱动程序、文件和网络系统，决定着系统的性能和稳定性。Linux 内核由如下几部分组成：系统调用、内存管理、进程管理、设备驱动程序、文件系统和网络管理等。</p><p>Linux Shell：Shell 是系统的用户界面，提供了用户与内核进行交互操作的一种接口。</p><p>Linux 文件系统：文件系统是文件存储在磁盘等存储设备上的组织方法。</p><p>Linux 应用程序：标准的 Linux 系统一般都有一套都有称为应用程序的程序集，它包括文本编辑器、编程语言、X Window、办公套件、Internet 工具和数据库等。</p><h2 id="3-4-Android-操作系统的体系结构"><a href="#3-4-Android-操作系统的体系结构" class="headerlink" title="3.4 Android 操作系统的体系结构"></a>3.4 Android 操作系统的体系结构</h2><p>Android 操作系统分为四层，从高层到低层分别是应用程序层、应用框架层、系统运行库层和 Linux 内核层。</p><p>Android 应用程序：Android 会同一系列核心应用程序包一起发布，该应用程序包包括客户端、SMS 短消息程序、日历、地图、浏览器、联系人管理程序等。</p><p>Android 应用框架：应用框架层为应用开发者提供了用以访问核心功能的 API 框架。</p><p>C、C++ 本地库和 Android 运行时环境：Android 包含一些 C&#x2F;C++ 库，这些库能被 Android 系统中不同的组件使用。</p><p>Linux 内核：Android 是基于不同版本的 Linux 内核开发出来的，Linux 内核层包括系统层安全机制、内存管理、进程管理、网络堆栈及一系列的驱动模块，位于硬件与其他的软件层之间，提供与硬件的交互。</p><h1 id="4-操作系统的发展历史及分类"><a href="#4-操作系统的发展历史及分类" class="headerlink" title="4 操作系统的发展历史及分类"></a>4 操作系统的发展历史及分类</h1><h2 id="4-1-批处理操作系统"><a href="#4-1-批处理操作系统" class="headerlink" title="4.1 批处理操作系统"></a>4.1 批处理操作系统</h2><p>批处理操作系统的基本工作方式是：用户将作业交给系统操作员，系统操作员在收到作业后，并不立即将作业输入计算机，而是在收到一定数量的用户作业之后，组成一批作业，再把这批作业输入到计算机中。这批作业可在系统中形成一个连续的、自动转接的作业流。</p><h2 id="4-2-分时系统"><a href="#4-2-分时系统" class="headerlink" title="4.2 分时系统"></a>4.2 分时系统</h2><p>在分时系统中，一台计算机主机连接了若干个终端，每个终端可由一个用户使用。用户通过终端交互式地向系统提出命令请求，系统接受用户的命令之后，采用时间片轮转方式处理服务请求，并通过交互方式在终端上向用户显示结果。</p><h2 id="4-3-实时操作系统"><a href="#4-3-实时操作系统" class="headerlink" title="4.3 实时操作系统"></a>4.3 实时操作系统</h2><p>实时操作系统（Real Time Operating System，RTOS）是指，使计算机能在规定的时间内，及时响应外部事件的请求，同时完成对该事件的处理，并能够控制所有实时设备和实时任务协调一致地工作的操作系统。实时操作系统的主要目标是：在严格时间范围内，对外部请求作出反应，系统应具有高度可靠性。</p><p>实时操作系统主要有两类：硬实时系统和软实时系统。</p><h2 id="4-4-嵌入式操作系统"><a href="#4-4-嵌入式操作系统" class="headerlink" title="4.4 嵌入式操作系统"></a>4.4 嵌入式操作系统</h2><p>嵌入式操作系统（Embedded Operating System）就是运行在嵌入式芯片环境中，对真个芯片以及它所操作、控制的各种部件装置等资源进行统一协调、调度、指挥和控制的系统软件。</p><h2 id="4-5-个人计算机操作系统"><a href="#4-5-个人计算机操作系统" class="headerlink" title="4.5 个人计算机操作系统"></a>4.5 个人计算机操作系统</h2><p>个人计算机操作系统（Personal Computer Operating System）是一种单用户多任务的操作系统。</p><h2 id="4-6-网络操作系统"><a href="#4-6-网络操作系统" class="headerlink" title="4.6 网络操作系统"></a>4.6 网络操作系统</h2><p>网络操作系统（Network Operating System）是基于计算机网络的、在各种计算机操作系统之上按网络体系结构协议标准设计开发的软件、它包括网络管理、通信、安全、资源共享和各种网络应用。</p><h2 id="4-7-分布式操作系统"><a href="#4-7-分布式操作系统" class="headerlink" title="4.7 分布式操作系统"></a>4.7 分布式操作系统</h2><p>将大量的计算机通过网络连结在一起，可以过得极高的运算能力及广泛的数据共享。这样一种系统称作为分布式系统（Distributed System）。为分布式系统配置的操作系统称为分布式操作系统（Distributed Operating System）。</p><h1 id="5-操作系统的结构设计"><a href="#5-操作系统的结构设计" class="headerlink" title="5 操作系统的结构设计"></a>5 操作系统的结构设计</h1><h2 id="5-1-整体式结构"><a href="#5-1-整体式结构" class="headerlink" title="5.1 整体式结构"></a>5.1 整体式结构</h2><p>首先确定操作系统的总体功能，然后将总功能分解为若干个子功能，实现每个子功能的程序称为模块。再按照功能将上述每个大模块分解为若干个较小的模块，如此下去，直至每个模块仅包含单一功能或紧密联系的小功能为止，即分解为最基本的模块为止。最后通过接口将所有模块连接起来形成一个整体。我们把这种操作系统的结构称之为模块组合结构。</p><h2 id="5-2-层次式结构"><a href="#5-2-层次式结构" class="headerlink" title="5.2 层次式结构"></a>5.2 层次式结构</h2><p>层次式结构就是把操作系统的所有功能模块，按功能流图的调用次序，分别将这些模块排列成若干层，各层之间的模块只能是单向依赖或单向调用（如只允许上层或外层模块调用下层或内层模块）关系。</p><h2 id="5-3-微内核结构"><a href="#5-3-微内核结构" class="headerlink" title="5.3 微内核结构"></a>5.3 微内核结构</h2><p>采用客户&#x2F;服务器结构的操作系统就适宜于应用在网络环境下分布式处理的计算环境中。由于这种体系结构所具有的一些特征，它又被称为内核体系结构。</p>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据流计算机和规约机</title>
      <link href="/2021/03/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E6%B5%81%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%92%8C%E8%A7%84%E7%BA%A6%E6%9C%BA/"/>
      <url>/2021/03/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E6%B5%81%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%92%8C%E8%A7%84%E7%BA%A6%E6%9C%BA/</url>
      
        <content type="html"><![CDATA[<p>传统的 Von Neumann 型计算机采用控制驱动方式，顺序地执行指令，这很难最大限度地开发出计算机的并行性。为此，提出若干非 Neumann 型计算机。这类计算机结构包括：使用数据流语言，基于数据驱动的数据流计算机；使用函数式语言，基于需求驱动的归约机。</p><p><img src="https://personal-blog.oss-cn-hangzhou.aliyuncs.com/CA_chapter_8.png"></p><h1 id="1-数据流计算机的工作原理、构形、特点、近年来的发展"><a href="#1-数据流计算机的工作原理、构形、特点、近年来的发展" class="headerlink" title="1 数据流计算机的工作原理、构形、特点、近年来的发展"></a>1 数据流计算机的工作原理、构形、特点、近年来的发展</h1><p>Von Neumann 型计算机的基本特点是在程序计数器集中控制下，顺次地执行指令，因此，它是以控制流（Control Flow）方式工作的。虽然可以在系统结构、程序语言、编译技术等方面进行改进，发展流水线机、阵列机或多处理机，但本质上仍是指令在程序计数器控制下顺序执行，这就很难最大限度地发掘出计算的并行性。</p><p>数据驱动的数据流方式指的是，只要一条或一组指令所要求的操作数全部准备就绪，就可以立即激发相应的指令或指令组执行。执行结果的输出将送往等待这一数据的下一条或下一组指令。如果其中一些指令因此而使所需用到的数据全部准备就绪，就可以被激发执行。因此，在这种计算机上不需要程序计数器。指令的执行基本上是无序的，完全受数据流的驱动，与指令在程序中出现的先后顺序无关。也就是说，部分有序的操作也不是由程序员指定的，而是受数据相关所制约。程序设计者完全摆脱了检查和定义程序中所有可能存在的并行性这一繁重工作。只要数据不相关和资源可以利用，就可以并行，因而最有利于计算并行性的开发。</p><p>控制驱动的控制流方式的特点是：</p><ol><li>通过访问共享存储单元让数据在指令之间传递；</li><li>指令执行的顺序性隐含于控制流中，但却可以显示地使用专门的控制操作符来实现并行处理；</li><li>指令执行的顺序受程序计数器控制，换句话说，是受控制令牌所支配的；</li></ol><p>数据驱动的数据流方式没有通常的共享变量的概念，即没有共享存储数据的概念；指令执行顺序只受指令中数据相关性的制约；数据是以数据令牌方式直接在指令之间传递的。</p><p>数据令牌是一种表示某一操作数或参数已准备就绪的标志。一旦执行某一操作的所有操作数令牌都到齐，则标志着这一操作是什么操作，以及操作结果所得出的数据令牌应发送到哪些等待此数据令牌的操作的第几个操作数部件等有关信息，都将作为一个消息包（Message Packet），传送到处理单元或操作部件并予以执行。</p><p>数据流计算机的结构：</p><ol><li>静态数据流计算机：静态数据流计算机的数据令牌没加标号。为正确工作，任意给定时刻，当结点操作时，其任何一条输入弧上只能有一个数据令牌。只有当结点的所有输入弧上都有数据令牌时，该结点才被激活来执行相应的操作。由于数据令牌没有加标号，如果给定时间里允许一条弧上同时出现两个以上的数据令牌的话，结点对于送达各输入端的一批数据就无法区分出它们中哪些是属于同一批的操作数。因此，在静态数据流计算中，为了满足迭代要求，除要多次重复激活同一操作到结点外，还必须另设控制令牌（Control Token），以识别数据令牌由一个结点传送到另一个结点的时间关系，从而区分属于不同迭代层次的各批数据。所以，静态数据流计算机不支持递归的并发激活，只支持一般的循环。</li><li>动态数据流计算机：动态数据流计算机最主要的特点是让令牌带上标记，使得在任意给定时刻，数据流程序图任何一条弧上允许出现多个带不同标记的令牌。令牌的标记是令牌附带的一个能识别该令牌时间先后相对关系的标号，有的计算机上也称其为颜色。所以，不需要像静态数据流计算机那样用控制令牌来对指令间数据令牌的传送加以认可。对于需要多组（次）数据令牌的指令，则是通过对令牌标记的配对来识别。为此，需要相应硬件将标记附加到数据令牌上，并完成对标记的匹配工作。</li></ol><p>数据流计算机存在的问题：</p><ol><li>数据流计算机的主要目的是为了提高操作级并行的开发水平，但如果题目本身数据相关性很强，内涵并行性成分不多时，就会使效率反而比传统的 Von Neumann 型机的还要低；</li><li>在数据流计算机中为给数据建立、识别、处理标记，需要花费较多的辅助开销和较大的存储空间（可能比 Von Neumann 型的要大出 2~3 倍）。但如果不用标记，则无法递归并会降低并行能力；</li><li>数据流计算机不保存数组。在处理大型数组时，会因复制数组而造成存储空间的大量浪费，增加额外数据传输开销。数据流计算机对标量运算有利，而对数组、递归及其他高级操作较难管理；</li><li>数据流语言的变量代表数值，而不是存储单元位置，使程序员无法控制存储分配。为有效回收不用的存储单元，增大了编译程序的困难；</li><li>数据流计算机互联网络设计困难，输入&#x2F;输出系统仍不够完善；</li><li>数据流计算机没有程序计数器，给诊断和维护带来了困难；</li></ol><p>数据流计算机的进展：</p><ol><li>采用提高并行度等级的数据流计算机；</li><li>采用同、异步结合的数据流计算机；</li><li>采用控制流与数据流相结合的数据流计算机；</li></ol><h1 id="2-规约机的结构、特点"><a href="#2-规约机的结构、特点" class="headerlink" title="2 规约机的结构、特点"></a>2 规约机的结构、特点</h1><p>规约机和数据流计算机一样，都是基于数据流的计算模型，只是其采用的驱动方式不同。数据流计算机采用数据驱动，执行的操作序列取决于输入数据的可用性；规约机则是需求驱动，执行的操作序列取决于对数据的需求，对数据的需求又来源于函数式程序设计语言对表达式的归约（Reduction）。</p><p>函数式语言是由所有函数表达式的集合、所有目标（也是表达式）的集合及所有由函数表达式到目标的函数集合三部分组成的。函数式其基本成分，是从一批目标到另一批目标的映射。从函数程序设计的角度来看，一个程序就是一个函数的表达式。通过定义一组「程序形成算符」（Program-Forming Operators），可以用简单函数（即简单程序）构成任意复杂的程序，也就是构成任意复杂函数的表达式。反过来，如果给出了一个属函数表达式集合中的复杂函数表达式，利用提供的函数集合中的子函数经过优先次规约代换之后，总可以得到所希望的结果，即由常量构成的目标。函数表达式的每一次规约，就是一次函数的应用，或是一个子表达式（子函数式）的代换（还原）。</p><p>函数式程序本质上属于解释执行方式，从函数式程序的归约来看，计算机内部通常采用链表的存储结构，且依赖于动态存储分配，存储空间的代销无法预测，需要频繁地进行空白单元的回收，使空间、时间开销都较大，频繁的函数应用和参数传递，加上自变量动态取值，同样的往往要重复多次。所以，必须针对函数程序设计语言的特点和问题来设计支持函数式程序运行的新计算机，这就是规约机。</p><p>规约机的特点如下：</p><ol><li>规约机应当是面向函数式语言，或以函数式语言为机器语言的非 Neumann 型机器，其内部结构应不同于 Neumann 型机器；</li><li>具有大容量物理存储器并采用大虚存容量的虚拟存储器，具备搞笑的动态存储分配和管理的软、硬件支持，满足规约机对动态存储分配及所需存储空间大的要求；</li><li>处理部分应当是一种有多个处理器或多个处理机并行的结构形式，以发挥函数式程序并行处理的特长；</li><li>采用适合于函数式程序运行的多处理器（机）互连的结构，最好采用树形方式的互连结构或多层次符合的互联结构形式；</li><li>为减少进程调度及进程间的通信开销，尽量把运行进程的节点机紧靠该进程所需用的数据安排，并使运行时需相互通信的进程所占用的处理机也靠近，让各处理机的负荷平衡；</li></ol><p>总之，规约方式体现了按需求驱动的思想，根据对函数求职的需求来激活相应的指令。而且，无论是采用先内后外，或先外后内，或先右后左，还是先左后右的顺序规约，也无论是采用串行规约，还是并行规约，都不影响最终结果值。</p><p>根据计算机所用规约方式的不同，相应就有串规约机和图规约机两类。</p>]]></content>
      
      
      <categories>
          
          <category> 计算机系统结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机系统结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>多处理机</title>
      <link href="/2021/03/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84/%E5%A4%9A%E5%A4%84%E7%90%86%E6%9C%BA/"/>
      <url>/2021/03/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84/%E5%A4%9A%E5%A4%84%E7%90%86%E6%9C%BA/</url>
      
        <content type="html"><![CDATA[<p><img src="https://personal-blog.oss-cn-hangzhou.aliyuncs.com/CA_chapter_7.png"></p><h1 id="1-多处理机的特点和主要技术问题"><a href="#1-多处理机的特点和主要技术问题" class="headerlink" title="1 多处理机的特点和主要技术问题"></a>1 多处理机的特点和主要技术问题</h1><h2 id="1-1-多处理机的定义和并行性等级"><a href="#1-1-多处理机的定义和并行性等级" class="headerlink" title="1.1 多处理机的定义和并行性等级"></a>1.1 多处理机的定义和并行性等级</h2><p>多处理机是指有两台以上的处理机，共享 I&#x2F;O 子系统，机间经共享主存或高速通信网络通信，在统一操作系统控制下，协同求解大而复杂问题的计算机系统。</p><p>使用多处理机的目的如下：</p><ol><li>通过多台处理机对多个作业、任务进行并行执行来提高解题速度，从而提高系统的整体性能；</li><li>使用冗余的多个处理机通过重新组织来提高系统的可靠性、适应性和可用性；</li></ol><p>由于应用的目的和结构不同，因此，多处理机可以有同构型、异构型和分布型 3 种。</p><p>并行性等级有：</p><ol><li>同时性；</li><li>并发性；</li></ol><h2 id="1-2-多处理机与阵列处理机的对比"><a href="#1-2-多处理机与阵列处理机的对比" class="headerlink" title="1.2 多处理机与阵列处理机的对比"></a>1.2 多处理机与阵列处理机的对比</h2><p>差别主要来源于并行性的等级不同，阵列处理机主要是针对向量、数组处理，实现向量指令操作机的并行，是开发并行性中的同时性。多处理机实现的则是更高一级的作业或任务间并行，是开发并行性中的并发性。</p><h2 id="1-3-多处理机的主要技术问题"><a href="#1-3-多处理机的主要技术问题" class="headerlink" title="1.3 多处理机的主要技术问题"></a>1.3 多处理机的主要技术问题</h2><p>多处理机的结构、机间互联、并行算法、并行语言、编译、操作系统等都将会直接影响到系统的性能和效率。</p><h1 id="2-多处理机的硬件结构"><a href="#2-多处理机的硬件结构" class="headerlink" title="2 多处理机的硬件结构"></a>2 多处理机的硬件结构</h1><h2 id="2-1-紧耦合和松耦合两种构形、特点"><a href="#2-1-紧耦合和松耦合两种构形、特点" class="headerlink" title="2.1 紧耦合和松耦合两种构形、特点"></a>2.1 紧耦合和松耦合两种构形、特点</h2><p>紧耦合多处理机是通过共享主存实现处理机间通信的，其通信速率受限于主存频宽。各处理机与主存经互联网络连接，处理机数受限于互联网络带宽及各处理机访主存冲突的概率。</p><p>为减少访主存冲突，主存采用模 m 多体交叉存取。模数 m 越大，发生冲突的概率越低，但要解决好数据在各存储器模块中的分配和定位。</p><p>紧耦合多处理机有两种构形。这两种构形差别只在于是否只带专用的 Cache。</p><p>在紧耦合多处理机中就各处理机而言，又有同构对称型和异构非对称型两种。</p><p>松耦合多处理机中，每台处理机都有一个容量较大的局部存储器，用于存储经常用的指令和数据，以减少紧耦合系统中存在的访主存冲突。不同处理机间或者如果通道互连实现通信，以共享某些外围设备；或者通过消息传送系统（Message Transfer System，MTS）来交换信息，这时各台处理机可带有自己的外围设备。消息传送系统常采用分时总线或环形、星形、树形等拓扑结构。松耦合多处理机较适合做粗粒度的并行计算。处理的作业分割成若干相对独立的任务，在各个处理机上并行，而任务间的信息流量较小。当各处理机任务间交互作用很少时，这种耦合度很松的系统是很有效的，可看成是一个分布系统。</p><p>松耦合多处理机可分为非层次型和层次型两种构形。</p><h2 id="2-2-多处理机机间互连、特点、问题和适用场合"><a href="#2-2-多处理机机间互连、特点、问题和适用场合" class="headerlink" title="2.2 多处理机机间互连、特点、问题和适用场合"></a>2.2 多处理机机间互连、特点、问题和适用场合</h2><p>多处理机机间互连的形式是决定多处理机性能的一个重要因素。在满足高通信速率、低成本的条件下，互连还应灵活多样，以实现各种复杂的乃至不规则的互连而不发生冲突。因此，多处理机的互连一般采用总线、环形互连、交叉开关、多端口存储器或蠕虫穿洞寻径网络等几种形式。对采用分布结构的多处理机则采用开关枢纽结构形式。</p><h3 id="2-2-1-总线形式"><a href="#2-2-1-总线形式" class="headerlink" title="2.2.1 总线形式"></a>2.2.1 总线形式</h3><p>多个处理机、存储器模块和外围设备通过接口与公用总线相连，采用分时或多路转接技术传送。其中，单总线方式结构简单、成本低，系统增减模块方便，但对总线的失效敏感，处理机机数增加会增大总线冲突概率，使系统效率急剧下降。虽然可再处理机中设置局部存储器和专用外设，减少总线使用冲突，但这种单总线形式也只适用于处理机机数较少的场合。</p><p>有两种办法可提高总线形式的系统效率：</p><ol><li>用优质高频同轴电缆来提高总线的传输速率，进一步使用光纤通信，其信息速率可达 10<sup>9</sup> ~ 10<sup>10</sup> bit&#x2F;s；</li><li>用多总线方式来减少访总线的冲突概率；</li></ol><h3 id="2-2-2-环形互连形式"><a href="#2-2-2-环形互连形式" class="headerlink" title="2.2.2 环形互连形式"></a>2.2.2 环形互连形式</h3><p>总线式互连对处理机机数少的多处理机来说，有结构简单、造价低、可扩充性好等优点，但总线的性能和可靠性严重受物理因素制约。为保持总线是互连的优点，同时又能克服其不足，可以考虑构造一种逻辑总线，让各台处理机之间点点相连成环状，称环形互连。在这种多处理机上，信息的传递过程是由发送进程将信息送到环上，经环形网络不断向下一台处理机传递，直到此信息又回到发送者处为止。</p><p>由于环形互连是点点连接，不是总线式连接，其物理参数容易得到控制，非常适合于有高通信带宽的光纤通信。光纤通信时很难用在总线式互联系统上的。环形互连的缺点是信息在每个接口处都会有一个单位的传输延迟，当互连的处理机机数增加时，环中的信息传输延迟将增大。</p><h3 id="2-2-3-交叉开关形式"><a href="#2-2-3-交叉开关形式" class="headerlink" title="2.2.3 交叉开关形式"></a>2.2.3 交叉开关形式</h3><p>单总线互连结构最简单，单争用总线现象最严重。交叉开关形式则不同于单总线。它用纵横开关阵列将横向的处理机 P 及 I&#x2F;O 通道与纵向的存储器模块 M 连接起来。</p><p>交叉开关形式是多总线朝总线数增加方向发展的极端情况，总线数等于全部相连的模块数（n + i + m），且 m ≥ i + n，n 个处理机和 i 个 I&#x2F;O 设备都能分到总线与 m 个存储器模块之一连通并行地通信。互联网络不争用开关，可以大大展宽互连传输频带，提高系统效率。交叉开关不是公用总线的按时间分割机制，而是按空间分配机制。</p><p>采用交叉开关的多处理机一般 n ≤ 16，少数可有 n &#x3D; 32 的。规模很大的交叉开关互联网络只有在交叉开关的成本非常低时才有可能。</p><h3 id="2-2-4-多端口存储器形式"><a href="#2-2-4-多端口存储器形式" class="headerlink" title="2.2.4 多端口存储器形式"></a>2.2.4 多端口存储器形式</h3><p>如果每个存储器模块有多个访问端口，将分布在交叉开关矩阵中的控制、转移和优先级仲裁逻辑分别移到相应存储器模块的接口中，就构成了多端口存储器形式的结构。</p><p>多端口存储器形式的中心事多端口存储器模块。多个存储器模块的相应端口连接在一起，每一个端口负责处理一个处理机 P 或 I&#x2F;O 通道的访存请求。每个存储器模块按照对它的各个端口指定的优先级来分解对它的访问冲突。</p><h3 id="2-2-5-蠕虫穿洞寻径网络"><a href="#2-2-5-蠕虫穿洞寻径网络" class="headerlink" title="2.2.5 蠕虫穿洞寻径网络"></a>2.2.5 蠕虫穿洞寻径网络</h3><p>机间采用小容量缓冲存储器，用于消息分组寻径存储转发。在蠕虫网络中，将消息分组又分割成一系列更小的小组，同一分组中所有小组以异步流水方式按序不间断地传送，并且同一分组中的所有小组，只有头部的小组知道其所在整个分组传送的目的地，用硬件方式进行传送的应答。各个分组允许交叉传送，但不同分组中的各个小组不能互相混在一起传送，利用虚拟通道思想，使存在于发送和接收结点之间的一条物理通道能被多个虚拟通道分时共享。</p><h3 id="2-2-6-开关枢纽结构形式"><a href="#2-2-6-开关枢纽结构形式" class="headerlink" title="2.2.6 开关枢纽结构形式"></a>2.2.6 开关枢纽结构形式</h3><p>参照多端口存储器的思想，把互联结构的开关设置在各处理机或接口内部，组成分布式结构，称为开关枢纽结构形式。每一台处理机通过它的开关枢纽与其他多台处理机连接组成各种分布结构的多处理机。开关枢纽的选择应使所组成的多处理机有较佳的拓扑结构和良好的互连特性，特别是要适应处理机机数很多的情况。</p><p>理想的拓扑结构应该是：所用开关枢纽数量少，每个开关枢纽的端口数不多，能以较短的路径把数量很多的处理机连接起来，实现快速而灵活的通信；不改变模块本身的结构，就可以使系统规模得到任意扩充。</p><h1 id="3-紧耦合多处理机多-Cache-的一致性"><a href="#3-紧耦合多处理机多-Cache-的一致性" class="headerlink" title="3 紧耦合多处理机多 Cache 的一致性"></a>3 紧耦合多处理机多 Cache 的一致性</h1><h2 id="3-1-多-Cache-的一致性问题"><a href="#3-1-多-Cache-的一致性问题" class="headerlink" title="3.1 多 Cache 的一致性问题"></a>3.1 多 Cache 的一致性问题</h2><p>为了解决价格合理的大容量主存的访问速度低于处理机速度一个数量级的现实问题，系统在各处理机和主存之间，通常配置有一个高速缓冲存储器 Cache。</p><p>在多处理机中，情况比较复杂。由于每个处理机都有自己的专用 Cache，当主存中同一个信息块在多个 Cache 中都有时，会出现多个 Cache 之间的相应信息块的内容不一致的问题。</p><h2 id="3-2-解决多-Cache-一致性的办法"><a href="#3-2-解决多-Cache-一致性的办法" class="headerlink" title="3.2 解决多 Cache 一致性的办法"></a>3.2 解决多 Cache 一致性的办法</h2><h3 id="3-2-1-解决进程迁移引起的多-Cache-不一致性"><a href="#3-2-1-解决进程迁移引起的多-Cache-不一致性" class="headerlink" title="3.2.1 解决进程迁移引起的多 Cache 不一致性"></a>3.2.1 解决进程迁移引起的多 Cache 不一致性</h3><p>对于进程迁移引起的多 Cache 之间的不一致性问题，可以通过禁止进程迁移的办法予以解决，也可以在进程挂起时，靠硬件方法将 Cache 中该进程改写过的信息块强制写回主存相应位置的办法来解决。</p><h3 id="3-2-2-以硬件为基础实现多-Cache-的一致性"><a href="#3-2-2-以硬件为基础实现多-Cache-的一致性" class="headerlink" title="3.2.2 以硬件为基础实现多 Cache 的一致性"></a>3.2.2 以硬件为基础实现多 Cache 的一致性</h3><p>以硬件为基础实现多 Cache 的一致性的办法有多种。最普遍采用的办法叫做监视 Cache 协议（Snoopy Protocol）法，即各个处理机汇总的 Cache 控制器随时都在监视着其他 Cache 的行动。对于采用总线互连共享主存的多处理机，可利用总线的播送来实现。当某台处理机首次将数据写入自身 Cache 中某一信息块同时，也将其写入主存，并且利用这个写主存操作信号通知总线上所有其他处理机的 Cache 控制器，将总线上给出的地址与各自的 Cache 目录表中的信息块地址作比较。如果存在这个信息块的副本，都应把此副本作废，以便那些处理机要访问该信息块时，按缺块处理，到主存中去调，以此来实现 Cache 的一致性。这种把数据块作废的方法称为写作废法。另一种做法则是通知总线上所有其他处理机的 Cache 控制器，如有此副本的，都进行更行。这种把所有副本信息块更新的做法称为写更新法，或者称为播写法。</p><h3 id="3-2-3-以软件为基础实现多-Cache-的一致性"><a href="#3-2-3-以软件为基础实现多-Cache-的一致性" class="headerlink" title="3.2.3 以软件为基础实现多 Cache 的一致性"></a>3.2.3 以软件为基础实现多 Cache 的一致性</h3><p>以硬件为基础的做法将增大对互联网络的通信量，处理机数很多时硬件也非常复杂。因此，提出了一些以软件为基础的做法。它们都是靠软件来限制的，不把一些公用的可写数据存入 Cache 中。例如，在编译时，通过编译程序分析，把信息分为能存入 Cache 的和不能存入 Cache 的两部分。让属于本处理机进程私用的指令和操作数以及各处理机公用的只读型指令或数据存入 Cache，而对于共享的可写数据则不让其存入 Cache，只驻留在主存中。为了尽量控制工作效率，也可以改为不把所有可写的信息块都归入不能存入 Cache 并不会引起不一致，则在这一段时间里实际不会写入，也允许其存入 Cache。只有在写入后会影响一致性的这段时间里限定其不得存入 Cache，或让前面已装入 Cache 的这些可写信息块作废。</p><p>以软件为基础解决 Cache 一致性的做法，主要优点是可以降低硬件的复杂性，降低对互联网络通信量的要求，因而性能价格比可以提高，比较适用于处理机数多的多处理机。但应当指出的是，现在以软件为基础的办法虽已提出了好几种方案，但由于可靠性及编译程序的编写困难，都还没有真正在商品化多处理机上使用，只在某些试验性系统上使用。</p><h1 id="4-程序并行性"><a href="#4-程序并行性" class="headerlink" title="4 程序并行性"></a>4 程序并行性</h1><p>多处理机并行性既存在于指令内部，也存在于指令外部，因此，必须利用算法、程序设计语言、编译、操作系统及指令、硬件等多种途径来开拓。多处理机低层次的并行可通过向量化实现，如利用面向 SIMD 的并行算法解决向量数组的并行运算。系统高层次的任务和作业的并行主要靠算法、编译、语言及操作系统来开发。</p><h2 id="4-1-并行算法的研究思路"><a href="#4-1-并行算法的研究思路" class="headerlink" title="4.1 并行算法的研究思路"></a>4.1 并行算法的研究思路</h2><p>算法规定了求解某一特定问题时的有穷的运算处理步骤。</p><p>并行算法时指可同时执行的多个进程的集合，各进程可相互作用、协调和并发操作。</p><p>按运算基本对象，并行算法可分为数值型和非数值型两类。基于代数运算，如矩阵运算、多项式求值、线性方程求解等并行算法称为数值型并行算法；基于关系运算，如选择、排序、查找、字符处理的并行主要是对符号操作的，称为非数值型并行算法。</p><p>按并行进程间的操作顺序不同，并行算法又分为同步型、异步型和独立型 3 种。</p><p>同步型并行算法时指并行的各进程间由于相关，必须顺序等待。异步型并行算法是指并行的各进程间执行相互独立，不会因相关而等待，只是根据执行情况决定中止或继续。独立型并行算法时指并行的各进程间完全独立，进程之间不需要相互通信。</p><p>并行算法取决于计算机的结构和提莫，它是提高多处理机并行性能的关键。处理机数目很多时，要把问题分解成由足够多的处理机处理的并行过程是极其困难的。</p><p>研究并行算法的一种思路是将大的程序分解成可由足够多的并行处理的过程（进程、任务、程序段）。每个过程被看成是一个结点，将过程之间的关联关系用结点组成的树来描述。</p><h2 id="4-2-给出程序中的语句或指令，分析并行情况"><a href="#4-2-给出程序中的语句或指令，分析并行情况" class="headerlink" title="4.2 给出程序中的语句或指令，分析并行情况"></a>4.2 给出程序中的语句或指令，分析并行情况</h2><p>任务间能否并行，除了算法外，很大程度上还取决于程序的结构。程序中各类数据相关是限制程序并行的重要因素。数据相关既可存在于指令之间，也可存在于程序段之间。</p><ol><li>数据相关；</li><li>数据反相关；</li><li>数据输出相关；</li></ol><p>两个程序段之间若有先写后读的数据相关，不能并行，只在特殊情况下可以交换串行；若有先读后写的数据反相关，可以并行执行，但必须保证其写入共享主存时的先读后写次序，不能交换串行；若有写-写的数据输出相关，可以并行执行，但同样需保证其写入的先后次序，不能交换串行；若同时有先写后读和先读后写两种相关，以交换数据为目的时，必须并行执行，且读、写要完全同步，不许顺序串行和交换串行；若没有任何相关或仅有源数据相同时，可以并行、顺序串行和交换串行。</p><h2 id="4-3-给出计算式或高级语言源程序，加-FORK、JOIN、GOTO-语句，改成在多处理机并行的程序，画出其多处理机上运行的时空图"><a href="#4-3-给出计算式或高级语言源程序，加-FORK、JOIN、GOTO-语句，改成在多处理机并行的程序，画出其多处理机上运行的时空图" class="headerlink" title="4.3 给出计算式或高级语言源程序，加 FORK、JOIN、GOTO 语句，改成在多处理机并行的程序，画出其多处理机上运行的时空图"></a>4.3 给出计算式或高级语言源程序，加 FORK、JOIN、GOTO 语句，改成在多处理机并行的程序，画出其多处理机上运行的时空图</h2><p>并行算法需要用并行程序来实现。为了加强程序并行性的识别能力，有必要在程序语言中增加能明确表示并发进程的成分，这就要使用并行程序设计语言。并行程序设计语言可以是在普通顺序型语言上加以扩充，增加能明确表示并行进程的成分，但每一种经扩充的语言仅能支持一种类型的并行性；也可以通过设计全新的并行程序设计语言来支持并行处理。</p><p>并行程序设计语言的基本要求是：能使程序员在其程序中灵活、方便地表示出各类并行性，能在各种并行&#x2F;向量计算机系统中高效地实现。</p><p>并行进程的特点是这些进程在时间上重叠地执行，一个进程未结束，另一个进程就已开始。</p><p>包含并行性的程序在多处理机上运行时，需要有相应的控制机构来管理，其中包括并行任务的派生和汇合。</p><p>FORM 语句的形式为 FORK m，其中 m 为新进程开始的标号。执行 FORK m 语句时，派生出标号为 m 开始的新进程，具体为：准备好这个新进程启动和执行所必须的信息；如果是共享主存，则产生存储器指针、映像函数和访问权数据；将空闲的处理机分配给派生的新进程，如果没有空闲处理机，则让它们排队等待；继续在原处理机上执行 FORK 语句的原进程。</p><p>与 FORK 语句相配合，作为每个并发进程的终端语句 JOIN 的形式为 JOIN n，其中 n 为并发进程的个数。JOIN 语句附有一个计数器，其初始值为 0。每当执行 JOIN n 语句时，计数器的值加 1，并与 n 比较。若比较相等，表明这是执行中第 n 个并发进程经过 JOIN 语句，于是允许该进程通过 JOIN 语句，将计数器清 0，并在其处理机上继续执行后续语句；若比较不等，计数器的值仍小于 n，表明此进程不是并发进程的最后一个，可让现在执行 JOIN 语句的这个进程先结束，把它所占用的处理机释放出来，分配给正在排队等待的其他任务。如果没有排队等待的任务，就让该处理机空闲。</p><h1 id="5-多处理机的性能"><a href="#5-多处理机的性能" class="headerlink" title="5 多处理机的性能"></a>5 多处理机的性能</h1><p>使用多处理机的主要目的是用多个处理机并发执行多个任务来提高解题速度。如果多台处理机始终都在执行有用的操作，系统解题的速度性能是会随处理机数目的增加而提高的。但实际解题算法总有不可并行的部分，解题过程需花费辅助开销，用于并行性检测，并行任务的派生和汇合，处理机间的通信传输、同步、系统控制和调度，使得多处理机的系统性能比期望的要低得多。</p><h2 id="5-1-任务粒度概念"><a href="#5-1-任务粒度概念" class="headerlink" title="5.1 任务粒度概念"></a>5.1 任务粒度概念</h2><p>任务粒度（Task Granularity）的大小会显著影响多处理机的性能和效率。任务粒度过小，辅助开销大，系统效率低；任务粒度过大，并行度低，性能不会很高。因此，要合理选择任务粒度大小，并使其尽可能均匀，还有采取措施减少辅助开销，以保证系统性能随处理机数目的增大能有较大的提高。当然，处理机机数增多时，还应考虑如何提供良好的编程环境，以减轻程序设计的难度。</p><h2 id="5-2-多处理机机数增加因辅助开销增加降低性能"><a href="#5-2-多处理机机数增加因辅助开销增加降低性能" class="headerlink" title="5.2 多处理机机数增加因辅助开销增加降低性能"></a>5.2 多处理机机数增加因辅助开销增加降低性能</h2><p>衡量任务粒度大小的一个依据是程序用于有效计算的执行时间 E 与处理机间的通信等辅助开销时间 C 的比值。只有 E&#x2F;C 值较大时，开发并发性才有好处。如果最大并行度会带来最大的通信等辅助开销，倒不如增大任务粒度，降低并行度来减少辅助开销。因此，为获得最佳的性能，必须对并行性和额外开销进行权衡。</p><h2 id="5-3-任务粒度与系统性能的关系"><a href="#5-3-任务粒度与系统性能的关系" class="headerlink" title="5.3 任务粒度与系统性能的关系"></a>5.3 任务粒度与系统性能的关系</h2><p>任务粒度还与系统的应用有关。图像及多目标跟踪因为机间通信开销少，宜于细腻度处理。要求冗长计算才能得到结果的题目，宜于粗粒度处理，因为粒度过细会过分增大额外开销和机器造价，且解题效率过低。因此，系统设计应使其性能与应用问题的粒度取得较佳适配。题目的并行性如果不能有效地发掘出来，机数很大的多处理机只会增大系统的复杂性和成本。这时，只有降低并行度知道能获得效益为止。</p><h1 id="6-多处理机的操作系统"><a href="#6-多处理机的操作系统" class="headerlink" title="6 多处理机的操作系统"></a>6 多处理机的操作系统</h1><p>包含并行性的程序在多处理机上运行时，需要有相应的控制机构来实现处理机的分配和进程调度、同步、通信，存储系统的管理，文件系统的管理及某处理机或设备故障时系统的重组，这主要是经多处理机操作系统用软件手段来实现的。</p><p>多处理机操作系统应具有程序执行的并行性，操作系统功能的分布性，机间通信与同步性及系统的容错这样一些基本特点。</p><p>多处理机操作系统有 3 类。它们是主从型（Master-Slave Configuration）、各自独立型（Separate Supervisor）及浮动型（Floating Supervisor）。</p><h2 id="6-1-主从型操作系统的定义、特点和适用场合"><a href="#6-1-主从型操作系统的定义、特点和适用场合" class="headerlink" title="6.1 主从型操作系统的定义、特点和适用场合"></a>6.1 主从型操作系统的定义、特点和适用场合</h2><p>管理程序只在一个指定的处理机（主处理机）上运行。该主处理机可以是专门的执行管理功能的控制处理机，也可以是与其他从处理机相同的通用机，除执行管理功能外，也能做其他方面的应用。由于住处理机是负责管理系统中所有其他处理机（从处理机）的状态及其工作的分配，只把从处理机看成是一个可调度的资源，实现对整个系统的几种控制，因此，也称为几种控制或专门控制方式。从处理机是通过访管指令或自陷（Trap）软中断来请求主处理机服务的。</p><p>优点：</p><ol><li>结构比较简单；</li><li>整个管理程序只在一个处理机上运行，除非某些需递归调用或多重调用的公用程序，一般都不必是可再入的；</li><li>只有一个处理机访问执行表，不存在系统管理控制表格的访问冲突和阻塞，简化了管理控制的实现；</li></ol><p>缺点：</p><ol><li>对主处理机的可靠性要求很高。一旦发生故障，很容易使整个系统瘫痪，这时必须由操作员干预才行；</li></ol><p>适用场合</p><p>主从型操作系统适用于工作符合固定，从处理机能力明显低于主处理机，或由功能相差很大的处理机组成的异构型多处理机。</p><h2 id="6-2-各自独立型操作系统的定义、特点和应用场合"><a href="#6-2-各自独立型操作系统的定义、特点和应用场合" class="headerlink" title="6.2 各自独立型操作系统的定义、特点和应用场合"></a>6.2 各自独立型操作系统的定义、特点和应用场合</h2><p>各自独立型操作系统是将控制功能分散给多台处理机，共同完成对整个系统的控制工作。每台处理机都有一个独立的管理程序（操作系统的内核）在运行，即每台处理机都有一个内核的副本，按自身的需要及分配给它的程序需要来执行各种管理功能。由于多台处理机执行管理程序，要求管理程序必须是可再入的，或对每台处理机提供专用的管理程序副本。</p><p>优点：</p><ol><li>很适应分布处理的模块化结构特点，减少对大型控制专用处理机的需求；</li><li>某个处理机发生故障，不会引起整个系统瘫痪，有较高的可靠性；</li><li>每台处理机都有其专用控制表格，使访问系统表格的冲突较少，也不会有许多公用的执行表；</li><li>控制进程和用户进程一起进行调度，能取得较高的系统效率；</li></ol><p>缺点：</p><ol><li>实现复杂；</li><li>某台处理机一旦发生故障，要想恢复和重新执行未完成的工作较困难；</li><li>每台处理机都有自己专用的输入&#x2F;输出设备和文件，使整个系统的输入&#x2F;输出结构变换需要操作员干预；</li><li>各处理机负荷的平衡比较困难；</li><li>各台处理机需有局部存储器存放管理程序副本，降低了存储器的利用率；</li></ol><p>适用场合：</p><p>各自独立型操作系统适用于松耦合多处理机。</p><h1 id="7-多处理机的发展"><a href="#7-多处理机的发展" class="headerlink" title="7 多处理机的发展"></a>7 多处理机的发展</h1><h2 id="7-1-多处理机发展的几种形式"><a href="#7-1-多处理机发展的几种形式" class="headerlink" title="7.1 多处理机发展的几种形式"></a>7.1 多处理机发展的几种形式</h2><ol><li>分布式共享存储器多处理机（Distributed Shared Memory Multiprocessor）；</li><li>对称多处理机；</li><li>多向量多处理机；</li><li>并行向量处理机（Parallel Vector Processor，PVP）；</li><li>大规模并行处理机（MPP）；</li><li>机群系统；</li></ol>]]></content>
      
      
      <categories>
          
          <category> 计算机系统结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机系统结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>向量处理机</title>
      <link href="/2021/03/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84/%E5%90%91%E9%87%8F%E5%A4%84%E7%90%86%E6%9C%BA/"/>
      <url>/2021/03/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84/%E5%90%91%E9%87%8F%E5%A4%84%E7%90%86%E6%9C%BA/</url>
      
        <content type="html"><![CDATA[<p>向量处理机是有向量数据表示的处理机，分向量流水处理机和阵列处理机两类。向量流水处理机是以时间重叠途径开发的，而阵列处理机是以资源重复途径开发的。</p><p><img src="https://personal-blog.oss-cn-hangzhou.aliyuncs.com/CA_chapter_6.png"></p><h1 id="1-向量的流水处理与向量流水处理机"><a href="#1-向量的流水处理与向量流水处理机" class="headerlink" title="1 向量的流水处理与向量流水处理机"></a>1 向量的流水处理与向量流水处理机</h1><h2 id="1-1-向量处理机的-3-种方式，向量的流水处理方式"><a href="#1-1-向量处理机的-3-种方式，向量的流水处理方式" class="headerlink" title="1.1 向量处理机的 3 种方式，向量的流水处理方式"></a>1.1 向量处理机的 3 种方式，向量的流水处理方式</h2><ol><li>横向处理方式；</li><li>纵向处理方式；</li><li>纵横处理方式；</li></ol><p>向量横向处理是向量的处理方式，但不是向量的流水处理方式；而向量纵向处理和分组纵横处理既是向量的处理方式，也是向量的流水处理方式。</p><h1 id="2-阵列处理机原理"><a href="#2-阵列处理机原理" class="headerlink" title="2 阵列处理机原理"></a>2 阵列处理机原理</h1><h2 id="2-1-阵列处理机的工作方式和构型"><a href="#2-1-阵列处理机的工作方式和构型" class="headerlink" title="2.1 阵列处理机的工作方式和构型"></a>2.1 阵列处理机的工作方式和构型</h2><p>阵列处理机有两种构形，差别主要在于存储器的组成方式和互联网络的不同。</p><p>构形如下：</p><ol><li>分布式存储器阵列处理机的构形。各处理单元有局部存储器（Processing Element Memory，PEM）存放被分布的数据，只能被本处理单元直接访问。而控制部件内还有一个存放程序和数据的主存储器，整个系统是在控制部件的控制下运行用户程序和部分系统程序的。在执行主存储器中的用户程序时，所有指令都在控制部件中进行译码，把只适合串行处理的标量或控制类指令留给控制部件自己执行，而把适合于并行处理的向量类指令「播送」个体各个 PE，控制处于「活跃」的那些 PE 并行执行。</li><li>集中式共享存储器的阵列处理机构形；系统存储器是由 K 个存储分体集中组成，经 ICN 为全部 N 个处理单元锁共享。</li></ol><h2 id="2-2-阵列处理机与流水处理机的比较"><a href="#2-2-阵列处理机与流水处理机的比较" class="headerlink" title="2.2 阵列处理机与流水处理机的比较"></a>2.2 阵列处理机与流水处理机的比较</h2><ol><li>阵列处理机利用的是资源重复，而不是时间重叠；</li><li>阵列处理机利用的是并行性中的同时性，而不是并发性；</li><li>阵列处理机提高速度主要是靠增大处理单元数，而不是靠缩短时钟周期；</li><li>阵列处理机使用简单、规整的互联网络来确定处理单元间的连接；</li></ol><h1 id="3-阵列处理机的并行算法"><a href="#3-阵列处理机的并行算法" class="headerlink" title="3 阵列处理机的并行算法"></a>3 阵列处理机的并行算法</h1><h2 id="3-1-ILLIAC-IV-的互连结构模式，最大传送步数"><a href="#3-1-ILLIAC-IV-的互连结构模式，最大传送步数" class="headerlink" title="3.1 ILLIAC IV 的互连结构模式，最大传送步数"></a>3.1 ILLIAC IV 的互连结构模式，最大传送步数</h2><p>ILLIAC IV 采用分布存储器构形。同一列两端的 PU 连成环，每一行右端的 PU 与下一行左端的 PU 相连，最下面一行右端的 PU 与最上面一行左端的 PU 相连，从而形成一个闭合的螺线形状，称其为闭合螺线阵列。</p><p>普遍来讲，N &#x3D; √N x √N 个处理单元组成的阵列中，任意两个处理单元之间的最短距离不超过 √ N - 1 步。</p><h2 id="3-2-分布式存储器的阵列处理机并行算法对信息在存储器分布的要求，累计和算法"><a href="#3-2-分布式存储器的阵列处理机并行算法对信息在存储器分布的要求，累计和算法" class="headerlink" title="3.2 分布式存储器的阵列处理机并行算法对信息在存储器分布的要求，累计和算法"></a>3.2 分布式存储器的阵列处理机并行算法对信息在存储器分布的要求，累计和算法</h2><p>ILLIAC IV 的处理单元是累加器型运算器，把累加寄存器 RGA 中的数据和存储器中来的数据进行运算，结果保留在累加寄存器 RGA 中。每个处理单元内有一个数据传送寄存器 RGR 收发数据，实现数据在处理单元之间的传送，并有一个屏蔽触发器来控制让该 PU<sub>i</sub> 是否被屏蔽掉，使之不参与向量指令的操作。</p><h1 id="4-SIMD-计算机的互联网络"><a href="#4-SIMD-计算机的互联网络" class="headerlink" title="4 SIMD 计算机的互联网络"></a>4 SIMD 计算机的互联网络</h1><p>在 SIMD 计算机中，无论是处理单元之间，还是处理单元与存储分体之间，都要通过互联网络进行信息交换。</p><h2 id="4-1-互联网络设计目标"><a href="#4-1-互联网络设计目标" class="headerlink" title="4.1 互联网络设计目标"></a>4.1 互联网络设计目标</h2><ol><li>结构不要过分复杂，以降低成本；</li><li>互连要灵活，以满足算法和应用的需要；</li><li>处理单元间信息交换所需的传送步数要尽可能少，以提高速度性能；</li><li>能用规整单一的基本构建组合而成，或者经多次通过或经多级连接来实现复杂的互连，使模块性好，以便于用 VLSI 实现并满足系统的可扩充性；</li></ol><h2 id="4-2-互联函数表示"><a href="#4-2-互联函数表示" class="headerlink" title="4.2 互联函数表示"></a>4.2 互联函数表示</h2><p>为反映互连特性，每种互联网络可用一组互连函数定义。如果把互联网络的 N 个入端和 N 个出端（N &#x3D; 2<sup>n</sup>）各自用 0，1，···，N - 1 的整数编号代表，则互连函数就是表示互联网络的出端号和入端号的一一对应关系。</p><h2 id="4-3-立方体、PM2I、混洗交换、蝶形等单级网络的互连函数个数、表示、最大距离"><a href="#4-3-立方体、PM2I、混洗交换、蝶形等单级网络的互连函数个数、表示、最大距离" class="headerlink" title="4.3 立方体、PM2I、混洗交换、蝶形等单级网络的互连函数个数、表示、最大距离"></a>4.3 立方体、PM2I、混洗交换、蝶形等单级网络的互连函数个数、表示、最大距离</h2><p>立方体（Cube）单级网络的名称来源于三位立方体结构。立方体的每个顶点（网络的结点）代表一个处理单元，共有 8 个处理单元，用 zyx 三位二进制码编号。最大距离为 n。</p><p>PM2I 单级网络是「加减 2」（Plus-Minus 2<sup>i</sup>）单级网络的简称。能实现与 j 号处理单元直接相连的是号为 j ± 2<sup>i</sup> 的处理单元，即</p><center>PM2<sub>+i</sub>(j) = j + 2<sup>i</sup> mod N</center><br/><center>PM2<sub>-i</sub>(j) = j - 2<sup>i</sup> mod N</center><p>式中，0 ≤ j ≤ N - 1，0 ≤ i ≤ n - 1，n &#x3D; log<sub>2</sub>N。它共有 2n 个互连函数。最大距离为 「N&#x2F;2」。</p><p>混洗交换单级（Shuffle-Exchange）网络包含两个互连函数，一个是全混（Perfect Shuffle），另一个是交换（Exchange）。最大距离为 2n - 1。</p><p>蝶形单级网络（Butterfly）的互连函数为</p><center>Butterfly(P<sub>n-1</sub>P<sub>n-2</sub>···P<sub>1</sub>P<sub>0</sub>) = P<sub>n-1</sub>P<sub>n-2</sub>···P<sub>1</sub>P<sub>0</sub></center><p>即将二进制地址的最高位和最低位相互交换位置。</p><h1 id="5-SIMD-计算机的循环和多级网络的思想和-3-个参数"><a href="#5-SIMD-计算机的循环和多级网络的思想和-3-个参数" class="headerlink" title="5 SIMD 计算机的循环和多级网络的思想和 3 个参数"></a>5 SIMD 计算机的循环和多级网络的思想和 3 个参数</h1><p>最基本的多级互联网络就是与上述前 3 种单级互连网络相对应组成的多级立方体互联网络、多级混洗交换网络和多级 PM2I 网络。此外，还有基准网络。</p><p>不同的多级互联网络，在所用的交换开关、拓扑结构和控制方式上各有不同。</p><p>交换开关是具有两个入端和两个出端的交换单元，用作各种多级互联网络的基本构件。无论入端或出端，如果令居于上方的都用 i 表示，居于下方的都用 j 表示，则可以定义下列 4 种开关状态或连接方式：</p><ol><li>直连，即 i<sub>入</sub> 连 i<sub>出</sub>，j<sub>入</sub> 连 j<sub>出</sub>；</li><li>交换，即 i<sub>入</sub> 连 j<sub>出</sub>，j<sub>入</sub> 连 i<sub>出</sub>；</li><li>上播，即 i<sub>入</sub> 连 i<sub>出</sub> 和 j<sub>出</sub>，j<sub>入</sub> 悬空；</li><li>下播，即 j<sub>入</sub> 连 i<sub>出</sub> 和 j<sub>出</sub>，i<sub>入</sub> 悬空；</li></ol><p>只有前两种功能的称二功能交换单元，有全部四种功能的称四功能交换单元。两个入端同时连到一个出端会发生信息传送的冲突，是不允许的。此外，还可以有第五种开关状态，即 i<sub>入</sub> 连 j<sub>入</sub>，i<sub>出</sub> 连 j<sub>出</sub>，称此为返回。它可用来实现入端与入端相连，出端与出端相连，从而将 N 个入端和 N 个出端的网络变为 2N 个处理单元的互联网络。</p><p>拓扑结构是各级间出端与入端互连的模式。上述前 3 种单级互连网络的连接模式均可用来组合构成不同的多级互联网络。</p><p>控制方式是对各个交换开关进行控制的方式，以多级立方体网络为例，它可以有 3 种：</p><ol><li>级控制 – 同一级的所有开关只用一个控制信号控制，可各自处于不同的状态；</li><li>单元控制 – 每一个开关都由自己独立的控制信号控制，可各自处于不同的状态；</li><li>部分级控制 – 第 i 级的所有开关分别用 i + 1 个信号控制，0 ≤ i ≤ n - 1，n 为级数；</li></ol><p>利用上述交换开关、拓扑结构和控制方式 3 个参量，可以描述各种多级互联网络的结构。</p><h1 id="6-阻塞式网络和全排列网络"><a href="#6-阻塞式网络和全排列网络" class="headerlink" title="6 阻塞式网络和全排列网络"></a>6 阻塞式网络和全排列网络</h1><h2 id="6-1-立方体、omega、PM2I-多级网络都是阻塞式网络的原因"><a href="#6-1-立方体、omega、PM2I-多级网络都是阻塞式网络的原因" class="headerlink" title="6.1 立方体、omega、PM2I 多级网络都是阻塞式网络的原因"></a>6.1 立方体、omega、PM2I 多级网络都是阻塞式网络的原因</h2><p>如果互联网络是从 N 个入端到 N 个出端的一对一的映射，就可以把它看成是对此 N 个端的重新排列，因此互联网络的功能实际上就是用新排列来置换 N 个入端原有的排列。前面所介绍的各种基本多级网络都能实现任意一个入端与任意一个出端间的连接，但要同时实现两对或多对入、出端间的连接时，就有可能发生争用数据传送路径的冲突。称有这类性质的互联网络为阻塞式网络（Blocking Network），称没有这类性质的互联网络为非阻塞式网络或全排列网络。非阻塞式网络连接灵活，但连线多、控制复杂、成本高。</p><p>阻塞式网络在一次传送中不可能实现 N 个端的任意排列。</p><h2 id="6-2-全排列网络定义及两种实现方式"><a href="#6-2-全排列网络定义及两种实现方式" class="headerlink" title="6.2 全排列网络定义及两种实现方式"></a>6.2 全排列网络定义及两种实现方式</h2><ol><li>可重排列网络；</li><li>用多级网络；</li></ol><h1 id="7-共享主存构形的阵列处理机中并行存储器的无冲突访问"><a href="#7-共享主存构形的阵列处理机中并行存储器的无冲突访问" class="headerlink" title="7 共享主存构形的阵列处理机中并行存储器的无冲突访问"></a>7 共享主存构形的阵列处理机中并行存储器的无冲突访问</h1><h2 id="7-1-实现一维数组步距为-2i-的无冲突传送，对存储器模数-m-的要求"><a href="#7-1-实现一维数组步距为-2i-的无冲突传送，对存储器模数-m-的要求" class="headerlink" title="7.1 实现一维数组步距为 2i 的无冲突传送，对存储器模数 m 的要求"></a>7.1 实现一维数组步距为 2<sup>i</sup> 的无冲突传送，对存储器模数 m 的要求</h2><p>m 应取成质数，才能较好地毕淼存储器访问的冲突。只要变址跳距与 m 互质，存储器访问就总能无冲突地进行。</p><h2 id="7-2-实现方阵或长方阵数组的无冲突访问的要求"><a href="#7-2-实现方阵或长方阵数组的无冲突访问的要求" class="headerlink" title="7.2 实现方阵或长方阵数组的无冲突访问的要求"></a>7.2 实现方阵或长方阵数组的无冲突访问的要求</h2><p>有 n 个处理单元的处理机，为了能并行访问 n 个元素，且适应任意规模的数组，可以先将多维数组或者非 n x n 方阵的二维数组按行或列的顺序变换为一维数组，形成一个一维线性地址空间，地址用 a 表示。然后，将地址 a 所对应的元素存放在体号地址 j &#x3D; a mod m，体内地址为 i &#x3D; a &#x2F; n 的单元中，就可以满足无冲突访问的要求。</p><h1 id="8-脉动阵列流水处理机"><a href="#8-脉动阵列流水处理机" class="headerlink" title="8 脉动阵列流水处理机"></a>8 脉动阵列流水处理机</h1><h2 id="8-1-脉动阵列流水处理机的工作原理"><a href="#8-1-脉动阵列流水处理机的工作原理" class="headerlink" title="8.1 脉动阵列流水处理机的工作原理"></a>8.1 脉动阵列流水处理机的工作原理</h2><p>脉动阵列结构是由一组处理单元（PE）构成的阵列。每个 PE 的内部结构相同，一般由一个加法&#x2F;逻辑运算部件或加法&#x2F;乘法运算部件再加上若干锁存器构成，可完成少数基本的算术逻辑运算操作。阵列内所有处理单元的数据锁存器都受同一个时钟控制。运算时数据在阵列结构的各个处理单元间沿各自的方向同步向前推进，就像血液受心脏有节奏地波动在各条血管中间同步向前流动一样。因此，形象地称其为脉动阵列结构。实际上，为了执行多种计算，脉动型系统内的输入数据流和结果数据流可以在多个不同方向上以不同速度向前搏动。阵列内部的各个单元只接收前一组处理单元传来的数据，并向后一组处理单元发送数据。只有位于阵列边缘的处理单元才与存储器 I&#x2F;O 端口进行数据通信。</p><h2 id="8-2-通用脉动阵列结构的实现方法"><a href="#8-2-通用脉动阵列结构的实现方法" class="headerlink" title="8.2 通用脉动阵列结构的实现方法"></a>8.2 通用脉动阵列结构的实现方法</h2><ol><li>通过增设附加的硬件，对阵列的拓扑结构和互连方式用可编程开关进行重构，即经程序重新配置阵列的结构。</li><li>用软件把不同的算法映像固定的阵列结构上。这一方法依赖于面向并行运算所采用的程序语言、操作系统、编译程序和软件开发工具的设计。</li><li>探寻与问题大小无关的脉动处理方法，以及 VLSI 运算系统的分割矩阵算法，使它们可以克服阵列只能求解固定大小题目的缺陷，同时探寻发展适合一类计算问题的通用算法和相应的设置方案。</li></ol>]]></content>
      
      
      <categories>
          
          <category> 计算机系统结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机系统结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>标量处理机</title>
      <link href="/2021/03/08/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84/%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E6%9C%BA/"/>
      <url>/2021/03/08/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84/%E6%A0%87%E9%87%8F%E5%A4%84%E7%90%86%E6%9C%BA/</url>
      
        <content type="html"><![CDATA[<p><img src="https://personal-blog.oss-cn-hangzhou.aliyuncs.com/CA_chapter_5.png"></p><h1 id="1-重叠方式"><a href="#1-重叠方式" class="headerlink" title="1 重叠方式"></a>1 重叠方式</h1><h2 id="1-1-顺序方式与重叠方式的定义和特点"><a href="#1-1-顺序方式与重叠方式的定义和特点" class="headerlink" title="1.1 顺序方式与重叠方式的定义和特点"></a>1.1 顺序方式与重叠方式的定义和特点</h2><p>顺序解释值得是各条指令之间顺序串行（执行完一条指令后才取下条指令）地进行，每条指令内部的各个微操作也顺序串行地进行。</p><p>解释一条机器指令的未操作可归并成 <strong>取指令</strong>、<strong>分析</strong> 和 <strong>执行</strong> 三部分。</p><p><strong>取指</strong> 是按指令计数器的内容访主存，取出该指令送到指令寄存器。</p><p><strong>分析</strong> 是对指令的操作码进行译码，按寻址方式和地址字段形成操作数真地址，并用此真地址去取操作数（可能访主存，也可能访寄存器），为取下一条指令还要形成下一条指令的地址。</p><p><strong>执行</strong> 是对操作数进行运算、处理，或存储运算结果（可能要访主存）。</p><p>指令的重叠解释是在解释第 k 条指令的操作完成之前，就可以开始解释第 k + 1 条指令。</p><p>实现指令的重叠解释必须在计算机组成上满足以下几点要求：</p><ol><li>要解决访主存的冲突；</li><li>要解决「分析」与「执行」操作的并行；</li><li>要解决「分析」与「执行」操作控制上的同步；</li><li>要解决指令间各种相关的处理；</li></ol><h2 id="1-2-「一次重叠」的定义和好处"><a href="#1-2-「一次重叠」的定义和好处" class="headerlink" title="1.2 「一次重叠」的定义和好处"></a>1.2 「一次重叠」的定义和好处</h2><p>称这种指令分析部件和指令执行部件任何时候都只有相邻两条指令在重叠解释的方式为「一次重叠」。</p><p>好处是节省硬件，计算机内指令分析部件和指令执行部件均只需一套，也简化了控制；</p><h2 id="1-3-条件转移指令与后续指令之间的相关及处理办法"><a href="#1-3-条件转移指令与后续指令之间的相关及处理办法" class="headerlink" title="1.3 条件转移指令与后续指令之间的相关及处理办法"></a>1.3 条件转移指令与后续指令之间的相关及处理办法</h2><p>如果要用条件转移指令时，可采用延迟转移技术，由编译程序生成目标程序时，将转移指令与条件转移无关的第 k - 1 条指令交换一下位置，这样，即使条件转移成功也不会使重叠效率下降。</p><h2 id="1-4-指令相关、主存数相关、通用寄存器组的数相关和变（基）址值相关的定义及处理办法，设置相关专用通路的作用"><a href="#1-4-指令相关、主存数相关、通用寄存器组的数相关和变（基）址值相关的定义及处理办法，设置相关专用通路的作用" class="headerlink" title="1.4 指令相关、主存数相关、通用寄存器组的数相关和变（基）址值相关的定义及处理办法，设置相关专用通路的作用"></a>1.4 指令相关、主存数相关、通用寄存器组的数相关和变（基）址值相关的定义及处理办法，设置相关专用通路的作用</h2><p>指令相关是因为机器指令允许修改而引出的。如果规定在程序运行过程中不准修改指令，指令相关就不可能发生。不准修改指令还可以实现程序的可再入和程序的递归调用。</p><p>主存空间数相关是相邻两条指令之间出现对主存同一单元要求先写而后读的关联，如果让「执行<sub>k</sub>」与「分析<sub>k+1</sub>」在时间上重叠，就会使 「分析<sub>k+1</sub>」读出的数不是第 k 条指令执行完应写入的结果而出错。要想不出错，只有推后「分析<sub>k+1</sub>」的读。</p><p>通用寄存器组的相关又有操作数的相关和变址值或基址值的相关两种。使用通用寄存器作不同用途所需微操作的时间是不同的。存放于通用寄存器中的基址值或变址值一般是在「分析」周期的前半段取用；操作数是在「废墟」周期的后半段取出，到「执行」周期的前半段采用；运算结果是在「执行」周期末尾形成并存入通用寄存器中。</p><p>设置相关通路是以增加设备为代价，是重叠效率不下降。</p><h1 id="2-流水方式的原理"><a href="#2-流水方式的原理" class="headerlink" title="2 流水方式的原理"></a>2 流水方式的原理</h1><h2 id="2-1-流水是重叠的引申，流水的向上扩展、向下扩展，指令级、处理机级、系统级流水的定义"><a href="#2-1-流水是重叠的引申，流水的向上扩展、向下扩展，指令级、处理机级、系统级流水的定义" class="headerlink" title="2.1 流水是重叠的引申，流水的向上扩展、向下扩展，指令级、处理机级、系统级流水的定义"></a>2.1 流水是重叠的引申，流水的向上扩展、向下扩展，指令级、处理机级、系统级流水的定义</h2><p>流水与重叠在概念上没有什么差别，流水可以看成是重叠的引申。二者的差别只在于「一次重叠」是把一条指令的解释分为两个子过程，而流水是分为更多个子过程。</p><p>在计算机实际的流水线中，各子部件经过的时间会有所不同。为平滑这些子部件的速度差，一般在它们之间设有锁存器。所以锁存器都受同一时钟信号控制，以实现各子部件信息流的同步推进。时钟信号周期不得低于速度最慢的子部件的经过时间与锁存器的存取时间之和，还要考虑时钟信号到各锁存器可能存在延时。所以，子过程的戏份会因锁存器数的增多而增大任务或指令流过流水线的时间，这在一定程度上会抵消子过程细分使吞吐率提高的好处。</p><p>所谓向下扩展值得是把子过程进一步地细分，让每个子过程经过的时间都同等程度地减少，吞吐率就会进一步提高。</p><p>流水的向上扩展可理解为在多个处理机之间流水。多个处理机串行地对数据集处理，各处理机专门完成其中的一个任务。因为各处理机都在同时工作，所以能流水地对多个不同的数据集进行处理，可较大地提高计算机系统的处理能力。</p><p>部件级流水是指构成部件内的各个子部件间的流水，如运算器内浮点加的流水、Cache 内和多体并行主存内的流水。</p><p>处理机级流水是构成处理机的各部件之间的流水，如「取指」、「分析」、「执行」间的流水。</p><p>系统级流水是指构成计算机系统的多个处理机之间的流水，也称宏流水。</p><h2 id="2-2-单功能和多功能、静态和动态、线性和非线性流水线，标量和向量流水机的定义"><a href="#2-2-单功能和多功能、静态和动态、线性和非线性流水线，标量和向量流水机的定义" class="headerlink" title="2.2 单功能和多功能、静态和动态、线性和非线性流水线，标量和向量流水机的定义"></a>2.2 单功能和多功能、静态和动态、线性和非线性流水线，标量和向量流水机的定义</h2><p>单功能流水线只能实现单一功能的流水，如只能实现浮点加减的流水线。</p><p>多功能流水线指的是同一流水线的各个段之间可以有多种不同的连接方式，以实现多种不同的运算或功能。</p><p>静态流水线在某一时间内各段只能按一种功能连接流水，只有等流水线全部留空后，才能切换成按另一种功能连接流水。</p><p>动态流水线的各功能段在同一时间内可按不同运算或功能连接。</p><p>标量流水机没有向量数据表示，只能用标量循环方式来处理向量和数组。</p><p>向量流水机指的是计算机有向量数据表示，设置有向量指令和向量运算硬件，能流水地处理向量和数组中的各个元素。向量流水机是向量数据表示和流水技术的结合。</p><p>流水线各段串行连接各段只经过一次，没有反馈回路的，称为线性流水线。</p><p>流水线除有串行连接的通路，还有反馈回路，使任务流经流水线需多次经过某个段或越过某些段，则称为非线性流水线。</p><h1 id="3-流水线相关处理和性能瓶颈消除"><a href="#3-流水线相关处理和性能瓶颈消除" class="headerlink" title="3 流水线相关处理和性能瓶颈消除"></a>3 流水线相关处理和性能瓶颈消除</h1><h2 id="3-1-消除流水线速度性能瓶颈的办法，时空图画法，吞吐率、效率、加速比的计算"><a href="#3-1-消除流水线速度性能瓶颈的办法，时空图画法，吞吐率、效率、加速比的计算" class="headerlink" title="3.1 消除流水线速度性能瓶颈的办法，时空图画法，吞吐率、效率、加速比的计算"></a>3.1 消除流水线速度性能瓶颈的办法，时空图画法，吞吐率、效率、加速比的计算</h2><p>受限于流水线中最慢子过程经过的时间。流水线中经过时间最长的子过程称为瓶颈子过程。</p><p>消除瓶颈的办法：</p><ol><li>将瓶颈子过程再细分；</li><li>重复设置多套瓶颈段并联；</li></ol><p>流水线的效率是指流水线中设备的实际使用时间占整个运行时间之比，也称流水线设备的时间利用率。由于流水线存在有建立时间和排空时间（最后一个任务流入到流出的时间），因此，在连续完成 n 个任务的时间里，各段并不总是满负荷工作的。</p><h2 id="3-2-同步流动和异步流动，异步流动会出现的-3-种相关的定义。结合-IBM-360-91-计算机综述局部性相关的处理办法"><a href="#3-2-同步流动和异步流动，异步流动会出现的-3-种相关的定义。结合-IBM-360-91-计算机综述局部性相关的处理办法" class="headerlink" title="3.2 同步流动和异步流动，异步流动会出现的 3 种相关的定义。结合 IBM 360&#x2F;91 计算机综述局部性相关的处理办法"></a>3.2 同步流动和异步流动，异步流动会出现的 3 种相关的定义。结合 IBM 360&#x2F;91 计算机综述局部性相关的处理办法</h2><p><strong>同步流动</strong> 是让任务（指令）流出流水线的顺序爆出与流水流入流水线的顺序一致。</p><p><strong>异步流动</strong> 是让流出流水线的任务（指令）顺序可以和流入流水线的顺序不同。</p><ol><li>「先写后读」相关；</li><li>「写-写」相关；</li><li>「先读后写」相关；</li></ol><p>标量流水机对局部性相关的处理一般采用总线式分布方式控制管理，包括：</p><ol><li>相关的判断主要是靠分布于各寄存器的「忙位」标志来管理；</li><li>在分散于各流水线的入、出端处设置若干保存站来缓存信息；</li><li>用站号控制公共数据总线的连接作相关专用通路，使之可为多个子过程的相关所共用；</li><li>一旦发生相关，用更换站号来推后和控制相关专用通路的连接；</li><li>采用多条流水线，每条流水线入端有多组保存站，以便发生相关后，可以采用异步的流动方式；</li></ol><h2 id="3-3-全局性相关的处理办法"><a href="#3-3-全局性相关的处理办法" class="headerlink" title="3.3 全局性相关的处理办法"></a>3.3 全局性相关的处理办法</h2><ol><li>使用猜测法；</li><li>加快和提前形成条件码；</li><li>采取延迟转移；</li><li>加快短循环程序的处理；</li></ol><h2 id="3-4-中断的处理办法"><a href="#3-4-中断的处理办法" class="headerlink" title="3.4 中断的处理办法"></a>3.4 中断的处理办法</h2><p>流水机器中断主要是如何处理好断点现场的保存和恢复，而不是如何缩短流水线的断流时间。</p><p>早期的流水机器，为简化中断处理，采用「不精确断点」法。</p><p>「不精确断点」法不利于编程和程序的排错。后来的流水及其多数采用「精确断点」法。</p><h1 id="4-流水线性能、非线性流水线任务调度"><a href="#4-流水线性能、非线性流水线任务调度" class="headerlink" title="4 流水线性能、非线性流水线任务调度"></a>4 流水线性能、非线性流水线任务调度</h1><h2 id="4-1-给出计算式，在两功能静态流水线上，调整指令流入顺序，画出流水时空图，计算吞吐率、效率和加速比"><a href="#4-1-给出计算式，在两功能静态流水线上，调整指令流入顺序，画出流水时空图，计算吞吐率、效率和加速比" class="headerlink" title="4.1 给出计算式，在两功能静态流水线上，调整指令流入顺序，画出流水时空图，计算吞吐率、效率和加速比"></a>4.1 给出计算式，在两功能静态流水线上，调整指令流入顺序，画出流水时空图，计算吞吐率、效率和加速比</h2><p>标量流水处理机的性能主要是吞吐率 T<sub>p</sub>、加速比 S<sub>p</sub> 和 效率 η。</p><p><strong>吞吐率</strong> 是流水线单位时间里能流出的任务数或结果数。</p><p><strong>效率</strong> 是指流水线中设备的实际使用时间占整个运行时间之比，也称流水线设备的时间利用率。</p><h1 id="5-指令级高度并行的超级处理机"><a href="#5-指令级高度并行的超级处理机" class="headerlink" title="5 指令级高度并行的超级处理机"></a>5 指令级高度并行的超级处理机</h1><h2 id="5-1-超标量处理机、超长指令字处理机、超流水线处理机、超标量超流水线处理机的工作原理和结构"><a href="#5-1-超标量处理机、超长指令字处理机、超流水线处理机、超标量超流水线处理机的工作原理和结构" class="headerlink" title="5.1 超标量处理机、超长指令字处理机、超流水线处理机、超标量超流水线处理机的工作原理和结构"></a>5.1 超标量处理机、超长指令字处理机、超流水线处理机、超标量超流水线处理机的工作原理和结构</h2><p>超标量处理机采用多指令流水线，每个 △t 同时流出 m 条指令（称为度 m）。</p><p>在超标量流水线处理机中配置多套功能部件、指令译码电路和多组总线，寄存器也备有多个端口和多组总线。程序运行是由指令译码部件检测顺序取出的指令之间是否存在数据相关和功能部件争用，将可并行的相邻指令送往流水线。若并行度为 1，就逐条执行。超标量流水机主要靠编译程序来优化编排指令的执行顺序，将可并行的指令搭配成组，硬件不调整指令顺序，这样实现起来比较容易些。</p><p>超标量流水处理机非常适合于求解像稀疏向量或稀疏矩阵这类标量计算问题，因为它们用向量流水线处理机求解很不方便。</p><p>超长指令字（VLIW）结构是将水平型微码和超标量处理两者结合。指令字长可达数百位，多个功能部件并发工作，共享大容量寄存器堆。与超标量处理机不同的是在编译时，编译程序找出指令间潜在的并行性，将多个功能并行执行的不相关或无关的操作先行压缩组合在一起，形成一条有多个操作段的超长指令。运行时不再用软件或硬件来检测其并行性，直接由这条超长字指令控制计算机中多个相互独立的功能部件并行操作。每个操作段控制其中的一个功能部件，相当于同时在执行多条指令。因此，硬件结构和指令系统简单，是一种单指令多操作码多数据的系统结构（SIMOMD），不同于 SIMD 计算机。</p><p>超长指令字处理机的优点是每条指令所需拍数比超标量处理机的少，指令译码容易，开发标量操作间的随机并行性更方便，从而可使指令级并行性较高。问题是 VLIW 处理机能否成功，很大程度取决于代码压缩的效率，其结构的目标码与一般的计算机不兼容，而且指令字很长而操作段格式固定，经常使指令字中的许多字段没有操作，白白浪费了存储空间，结构也不如超标量处理机的紧凑。</p><p>超流水线处理机不同于超标量处理机和 VLIW 处理机，每个 △t’ 仍只流出一条指令，但它的 △t’ 值小，一台度为 m 的超流水线处理机的 △t’ 只是基本机器周期 △t 的 1&#x2F;m。因此，一条指令需花 km△t’ 的时间，k 为一条指令所含的基本机器周期数。只要流水线性能得以充分发挥，其并行度就可达 m。</p><p>超标量超流水线处理机是超标量流水线与超流水线处理机的结合。在一个 △t’（等于 △t&#x2F;n）发射了 k 条指令（超标量），而每次发射时间错开 △t’（超流水），相当于每拍 △t 流出了 nk 条指令，即并行度 m &#x3D; kn。</p>]]></content>
      
      
      <categories>
          
          <category> 计算机系统结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机系统结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>存储体系</title>
      <link href="/2021/03/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84/%E5%AD%98%E5%82%A8%E4%BD%93%E7%B3%BB/"/>
      <url>/2021/03/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84/%E5%AD%98%E5%82%A8%E4%BD%93%E7%B3%BB/</url>
      
        <content type="html"><![CDATA[<p><img src="https://personal-blog.oss-cn-hangzhou.aliyuncs.com/CA_chapter_4.png"></p><h1 id="1-存储体系概念"><a href="#1-存储体系概念" class="headerlink" title="1 存储体系概念"></a>1 存储体系概念</h1><h2 id="1-1-存储体系的定义、分支及依据"><a href="#1-1-存储体系的定义、分支及依据" class="headerlink" title="1.1 存储体系的定义、分支及依据"></a>1.1 存储体系的定义、分支及依据</h2><p>存储体系（即存储层次）是让构成存储系统的几种不同的存储器（M<sub>1</sub> ~ M<sub>n</sub>）之间，配上辅助软、硬件或辅助硬件，使之从应用程序员角度来看，它们在逻辑上是一个整体。让存储层次的等效访问速度是接近于 M<sub>1</sub> 的，容量是 M<sub>n</sub> 的，每位价格是接近于 M<sub>n</sub> 的。基本的二级存储体系是 <strong>虚拟存储器</strong> 和 <strong>Cache 存储器</strong>，这是存储体系的两个不同的分支。</p><p><strong>虚拟存储器</strong> 是因主存容量满足不了要求而提出来的。在主存和辅存之间，增设辅助的软、硬件设备，让它们构成一个整体，所以也称为主存-辅存存储层次。</p><p>因主存速度满足不了要求而引出了 Cache 存储器。在 CPU 和主存之间增设高速、小容量、每位价格较高的 Cache，用辅助硬件将 Cache 和主存构成整体，称为 Cache 存储器（或称为 Cache-主存存储器层次）。</p><p>应用程序员可用机器指令的地址对整个程序统一编址，称该地址为虚地址（程序地址），而把实际主存地址称为实地址（实存地址）。</p><p><strong>虚拟存储器</strong> 只能适用于多道程序（多用户）环境，而 Cache 存储器既可以是单用户环境，也可以是多用户环境。</p><h2 id="1-2-存储体系主要指标参数的计算"><a href="#1-2-存储体系主要指标参数的计算" class="headerlink" title="1.2 存储体系主要指标参数的计算"></a>1.2 存储体系主要指标参数的计算</h2><p>设有存储器 ，变量如下：</p><blockquote><p>c<sub>i</sub>：每位价格；<br/><br>S<sub>M<sub>i</sub></sub>：以位计算的存储容量；<br/><br>T<sub>A<sub>i</sub></sub>：CPU 访问到 M<sub>i</sub> 中信息所需的时间；<br/><br>H：命中率；</p></blockquote><p>存储层次的每位价格：</p><p>c &#x3D; (c<sub>1</sub>S<sub>M<sub>1</sub></sub> + c<sub>2</sub>S<sub>M<sub>2</sub></sub> + … + c<sub>i</sub>S<sub>M<sub>i</sub></sub>)&#x2F;(S<sub>M<sub>1</sub></sub> + S<sub>M<sub>2</sub></sub> + … + S<sub>M<sub>i</sub></sub>)</p><p>命中率 H 定义为 CPU 产生的逻辑地址在 M<sub>1</sub> 中访问到（命中到）的概率。</p><p>存储层次的等效访问时间 T<sub>A</sub> &#x3D; H<sub>1</sub>T<sub>A<sub>1</sub></sub> + H<sub>2</sub>T<sub>A<sub>2</sub></sub> + … + H<sub>i</sub>T<sub>A<sub>i</sub></sub>，希望 T<sub>A<sub>i</sub></sub> 越接近于 T<sub>A<sub>1</sub></sub>。</p><h1 id="2-虚拟存储器"><a href="#2-虚拟存储器" class="headerlink" title="2 虚拟存储器"></a>2 虚拟存储器</h1><h2 id="2-1-3-种虚拟管理方式的原理、地址映像规则、映像表机构、地址变换过程、各自的优点和问题"><a href="#2-1-3-种虚拟管理方式的原理、地址映像规则、映像表机构、地址变换过程、各自的优点和问题" class="headerlink" title="2.1 3 种虚拟管理方式的原理、地址映像规则、映像表机构、地址变换过程、各自的优点和问题"></a>2.1 3 种虚拟管理方式的原理、地址映像规则、映像表机构、地址变换过程、各自的优点和问题</h2><p>虚拟存储器通过增设地址映像表机构来实现程序在主存中的定位。将程序分割成若干段或页，用相应的映像表指明该程序的某段或某页是否已装入主存。若已装入，同时指明其在主存中的起始地址；若未装入，就去辅存中调段或调页，装入主存后在映像表中建立好程序空间和实存空间的地址映像关系。这样，程序执行时通过查映像表将程序（虚）地址变换成实（主）存地址再仿主存。</p><p>根据存储映像算法的不同，可有多种不同的存储管理方式的虚拟存储器，其中主要有段氏、页式和段页式 3 种。</p><h2 id="2-2-段页式虚拟存储器由虚地址计算实主存地址的方法，给出映像表内容计算出主存实地址，判断是否发生段失效、页失效或保护失效"><a href="#2-2-段页式虚拟存储器由虚地址计算实主存地址的方法，给出映像表内容计算出主存实地址，判断是否发生段失效、页失效或保护失效" class="headerlink" title="2.2 段页式虚拟存储器由虚地址计算实主存地址的方法，给出映像表内容计算出主存实地址，判断是否发生段失效、页失效或保护失效"></a>2.2 段页式虚拟存储器由虚地址计算实主存地址的方法，给出映像表内容计算出主存实地址，判断是否发生段失效、页失效或保护失效</h2><p>程序都有模块性，一个复杂的大程序可以分解成多个在逻辑上相对独立的模块。这些模块可以是主程序、子程序或过程，也可以是数据块。模块的大小各不相同，有的甚至事先无法确定。每个模块都是一个单独的段，都以该段的起点为 0 相对编址。当某个段由辅存调入主存时，只要系统赋予该段一个基址（即该段存放在主存中的起始地址），就可以由此基址和单元子啊段内的相对位移形成单元在主存中的实际地址。将主存按段分配的存储管理方式称为段氏管理。</p><p>为了进行段氏管理，每道程序在系统中都有一个段（映像）表来存放该道程序各段装入主存的状况信息。</p><p>对于每道程序，由基号（程序号）指明使用哪个段表基址寄存器。段表基址寄存器中的段表基地址字段指向该道程序的段表在主存中的起始地址。段表长度字段指明该道程序所用段表的行数，即程序的段数。</p><p>分段方法能使大程序分模块编制，从而可使多个程序员并行编程，缩短编程实践，在执行或编译过程中对不断变化的可变长段也便于处理。各个段的修改、增添并不影响其他各段的编制，各用户以段的连接形成的程序空间可以与主存的实际容量无关。</p><p>分段还便于几道程序共用已在主存内的程序和数据，如编译程序、各种子程序、各种数据和装入程序等。不必在主存中重复存储，只需把它们按段存储，并在几道程序的段表中有公用段的名称及同样的基址值即可。</p><h2 id="2-3-页式虚拟存储器的虚、实地址字段对应关系、地址映像规则，由虚地址差映像表计算出主存地址，或判断是否页失效"><a href="#2-3-页式虚拟存储器的虚、实地址字段对应关系、地址映像规则，由虚地址差映像表计算出主存地址，或判断是否页失效" class="headerlink" title="2.3 页式虚拟存储器的虚、实地址字段对应关系、地址映像规则，由虚地址差映像表计算出主存地址，或判断是否页失效"></a>2.3 页式虚拟存储器的虚、实地址字段对应关系、地址映像规则，由虚地址差映像表计算出主存地址，或判断是否页失效</h2><p>段氏存储中各段装入主存的起点是随意的，段表中的地址字段很长，必须能表示出主存中任意一个绝对地址，加上各段长度也是随意的，段长字段也很长。这既增加了辅助硬件的开销，降低了查表速度，也使主存管理麻烦。段氏管理和存储还会带来大的段间零头浪费。</p><p>页式存储是把主存空间和程序空间都机械地等分成固定大小的页（页面大小随计算机而异，一般子啊 512B 到几百 KB 之间），按页顺序编号。这样，任一主存单元的地址 n<sub>p</sub> 就由实页号 n<sub>v</sub> 和页内位移 n<sub>r</sub> 两个字段组成。每个独立的程序也有自己的虚页号顺序。</p><p>页式对应用程序员完全透明，所需映像表硬件较少，地址变换的速度快，调入操作简单等方面都由于段氏。页式不能完全消除主存可用区的零头浪费，因为程序的大小不可能恰好就是页面大小的整数倍。产生的页内零头虽然无法利用，但其浪费比段氏的要小得多，所以在主存空间的利用率上，页式也由于段氏。因此，单纯用段氏管理的虚拟寄存器已经很少见到。</p><p>相比而言，段氏也具有页式所没有的若干优点。例如，段氏中的每个段独立，有利于程序员灵活实现段的链接，段的扩大、缩小和修改，而不影响到其他的段；每段只包含一种类型的对象，如过程或是数组、堆栈、标量等集合，易于针对其特定类型实现保护；把共享的程序或数据单独构成一个段，从而易于实现多个用户、进程对共用段的管理，等等。</p><p>段页式存储是把实（主）存机械地等分成固定大小的页，程序按模块分段，每个段又分成与主存页面大小相同的页。每道程序通过一个段表和相应的一组页表进行定位。段中的每一行对应一个段。</p><p>段页式的主要问题是地址变换过程至少需要查表两次，即查段表和页表。因此，要想使虚拟存储器的速度接近于主存，必须在结构上采取措施，以加快地址转换中查表的速度。</p><h2 id="2-4-用-FIFO、LRU、OPT-算法页替换的过程模拟，计算命中率"><a href="#2-4-用-FIFO、LRU、OPT-算法页替换的过程模拟，计算命中率" class="headerlink" title="2.4 用 FIFO、LRU、OPT 算法页替换的过程模拟，计算命中率"></a>2.4 用 FIFO、LRU、OPT 算法页替换的过程模拟，计算命中率</h2><p>FIFO 是选中最早装入主存的页作为被替换的页。这种算法实现方便，只要操作系统为主存管理所设的主存页面表中给每个实页配一个计数器字段。每当一页装入主存时，让该页的计数器清零，其他已装入主存的那些页的计数器都加「1」。需要替换时，计数器值最大的页和页号就是最先进入主存而现在准备替换掉的页号。</p><p>LRU 是选择近期最少访问的页作为被替换页。这种算法能比较正确地反映程序的局部性。一般来说，当前最少使用的页，未来也将很少被访问。但完全按此算法实现比较困难，需要为每个实页都配一个字长很长的计数器。所以一般用其变形，把近期最久未访问过的页作为被替换页，将「多」和「少」变成「有」和「无」，实现就方便多了。</p><p>如果能根据未来实际使用情况将未来的近期里不用的页替换出去，一定会有最高的命中率，这种算法称为优化替代算法（Optimal，OPT）。它是在时刻 t 找出主存中每个页将要用到的时刻 t<sub>i</sub>，然后选择其中 t<sub>i</sub> + t 最大的那一页作为替换页。显然，这只有让程序运行过一遍，才能得到各页未来的使用情况信息，所以实现起来是不显示的。优化替换算法时一种理想算法，可以被用来作为评价其他替换算法好坏的标准，看哪种替换算法的主存命中率最接近于优化替换算法的主存命中率。</p><ol><li>命中率与所选用替换算法有关。LRU 算法要优于 FIFO 算法。命中率也与页地址流有关。</li><li>命中率与分配给程序的主存页数有关。</li></ol><h2 id="2-5-堆栈型替换算法定义、种类，给出程序运行时的虚页地址流用-LRU-替换算法进行堆栈模拟处理，求得不同实页数时的命中率"><a href="#2-5-堆栈型替换算法定义、种类，给出程序运行时的虚页地址流用-LRU-替换算法进行堆栈模拟处理，求得不同实页数时的命中率" class="headerlink" title="2.5 堆栈型替换算法定义、种类，给出程序运行时的虚页地址流用 LRU 替换算法进行堆栈模拟处理，求得不同实页数时的命中率"></a>2.5 堆栈型替换算法定义、种类，给出程序运行时的虚页地址流用 LRU 替换算法进行堆栈模拟处理，求得不同实页数时的命中率</h2><p>设 A 是长度为 L 的任意一个页地址流，t 为已处理过 t-1 个页面的时间点，n 为分配给该地址流的主存页数，B<sub>t</sub>（n）表示在 t 时间点、在 n 页的主存中的页面集合，L<sub>t</sub> 表示到 t 时间点已遇到过的地址流中相异页的页数。如果替换算法满足：</p><blockquote><center>n < L<sub>t</sub> 时，B<sub>t</sub>（n） ∈ B<sub>t</sub>（n + 1）</center><br/><center>n ≥ L<sub>t</sub> 时，B<sub>t</sub>（n） = B<sub>t</sub>（n + 1）</center><br/></blockquote><p>则属堆栈型的替换算法。</p><h2 id="2-6-PFF-替换算法的原理，二道程序给出各自程序运行中的虚页地址流，合理分配给它们的实主存页数，使系统效率最高"><a href="#2-6-PFF-替换算法的原理，二道程序给出各自程序运行中的虚页地址流，合理分配给它们的实主存页数，使系统效率最高" class="headerlink" title="2.6 PFF 替换算法的原理，二道程序给出各自程序运行中的虚页地址流，合理分配给它们的实主存页数，使系统效率最高"></a>2.6 PFF 替换算法的原理，二道程序给出各自程序运行中的虚页地址流，合理分配给它们的实主存页数，使系统效率最高</h2><p>由于堆栈型替换算法有随分配非该道程序的实页数 n 增加，命中率 H 会单调上升这一特点，因此可对 LRU 算法加以改进，提出使系统性能更优的动态算法。即根据各道程序运行中的主存页面失效率，由操作系统动态调节分配给各道程序的实页数。当主存页面失效率超过某个值时，就自动减少分配给该道程序的主存页数，以便释放出这部分主存页面位置供其他程序用，从而使整个系统总的主存命中率和主存利用率得到提高。我们称此算法为页面失效频率（PFF）算法。显然它是立足于主存页数增加一定会使命中率单调上升，至少不下降这一基本点上的。</p><h2 id="2-7-分析虚拟存储器的页面大小-Sp、分配给主存容量-S1-与主存命中率-H-的变化趋势，给出综合评估和改进页式虚拟存储器性能的办法"><a href="#2-7-分析虚拟存储器的页面大小-Sp、分配给主存容量-S1-与主存命中率-H-的变化趋势，给出综合评估和改进页式虚拟存储器性能的办法" class="headerlink" title="2.7 分析虚拟存储器的页面大小 Sp、分配给主存容量 S1 与主存命中率 H 的变化趋势，给出综合评估和改进页式虚拟存储器性能的办法"></a>2.7 分析虚拟存储器的页面大小 S<sub>p</sub>、分配给主存容量 S<sub>1</sub> 与主存命中率 H 的变化趋势，给出综合评估和改进页式虚拟存储器性能的办法</h2><p>命中率是评价存储体系性能的重要指标。程序地址流、替换算法以及分配给程序的实页数不同都会影响命中率。</p><ol><li>页面大小 S<sub>p</sub>、分配给某道程序的主存容量 S<sub>1</sub> 与命中率 H 的关系：当分配给某道程序的主存容量 S<sub>1</sub> 一定时，随着页面大小 S<sub>p</sub> 由很小开始增大，命中率 H 先逐渐增大，到达某个最大值后又减小。同时，分配给该道程序的容量 S<sub>1</sub> 增大可普遍提高命中率，达到最高命中率时的页面大小 S<sub>p</sub> 也可以大一些。</li><li>分配给某道程序的容量 S<sub>1</sub> 的增大也只是在开始时对 H 提高有明显作用。</li></ol><h1 id="3-Cache-存储器"><a href="#3-Cache-存储器" class="headerlink" title="3 Cache 存储器"></a>3 Cache 存储器</h1><h2 id="3-1-Cache-存储器的组成与工作原理，与虚拟存储器对比"><a href="#3-1-Cache-存储器的组成与工作原理，与虚拟存储器对比" class="headerlink" title="3.1 Cache 存储器的组成与工作原理，与虚拟存储器对比"></a>3.1 Cache 存储器的组成与工作原理，与虚拟存储器对比</h2><p>高速缓冲（Cache）存储器是为弥补主存速度不足，在处理机和主存之间设置一个高速、小容量的 Cache，构成 Cache — 主存存储层次，使之从 CPU 角度来看，速度接近于 Cache，容量却是主存的。</p><p>将 Cache 和主存机械地分成相同大小的块（或行）。每一块有若干字（或字节）自称。从存储层次原理上讲，Cache 存储器中的块和细腻存储器中的页具有相同的地位，但块的大小要比页的大小小得多，一般只是页的几十分之一或几百分之一。每当给出一个主存字地址进行访存时，都必须通过主存-Cache 地址映像变换机构判定该访问字所在的块是否已在 Cache 中。如果在 Cache 中（Cache 命中），主存地址经地址映像变换机构变换成 Cache 地址去访 Cache，Cache 与处理机之间进行单字信息传送；如果不在 Cache 中（Cache 不命中），产生 Cache 块失效，这时就需要从访存的通路中把包含该字的一块信息通过多字宽通路调入 Cache，同时将被访问字直接从单字通路送往处理机。如果 Cache 已经装不进了，发生块冲突，就要将该块替换成被选上的待替换块，并修改地址映像表中有关的地址映像关系及 Cache 各块的使用状态标志等信息。</p><p>Cache 存储器和虚拟存储器在原理上是类似的，所以虚拟存储器中使用的地址映像变换及替换算法基本上也适用于 Cache 存储器。只是由于对 Cache 存储器的速度要求更高，因此，在构成、实现及透明性等问题上有其自己的特点。</p><h2 id="3-2-全相联、直接、组相联地址映像规则，地址变换过程，相应所用映像表的组织"><a href="#3-2-全相联、直接、组相联地址映像规则，地址变换过程，相应所用映像表的组织" class="headerlink" title="3.2 全相联、直接、组相联地址映像规则，地址变换过程，相应所用映像表的组织"></a>3.2 全相联、直接、组相联地址映像规则，地址变换过程，相应所用映像表的组织</h2><p>给出主存地址 n<sub>m</sub> 访存时，将其主存块号 n<sub>mb</sub> 与目录表中所有各项的 n<sub>mb</sub> 字段同时相联比较。若有相同的，就将对应行的 Cache 块号 n<sub>cb</sub> 取出，拼接上块内地址 n<sub>mr</sub> 形成 Cache 地址 n<sub>c</sub>，访 Cache；若没有相同的，表示该主存块未装入 Cache，发生 Cache 块失效，由硬件调块。</p><p>全相联映像法的优点是块冲突概率最低，只有当 Cache 全部装满才可能出现块冲突，所以，Cache 的空间利用率最高。</p><p>把主存空间按 Cache 大小等分区，每区内的各块只能按位置一一对应到 Cache 相应块的位置上，即主存第 i 块只能唯一映像到第 i mod 2<sup>n<sub>cb</sub></sup> 块位置上。</p><p>组相联映像指的是各组之间是直接映像，而组内各块之间是全相联映像。</p><h2 id="3-3-比较对法实现-Cache-块替换的原理，比较对触发器数的计算"><a href="#3-3-比较对法实现-Cache-块替换的原理，比较对触发器数的计算" class="headerlink" title="3.3 比较对法实现 Cache 块替换的原理，比较对触发器数的计算"></a>3.3 比较对法实现 Cache 块替换的原理，比较对触发器数的计算</h2><p>比较对法的基本思想是让组内个块成对组合，用一个触发器的状态表示该比较对内两块方位的远近次序，再经门电路就可找到 LRU 块。</p>]]></content>
      
      
      <categories>
          
          <category> 计算机系统结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机系统结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据表示、寻址方式与指令系统</title>
      <link href="/2021/02/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E8%A1%A8%E7%A4%BA%E3%80%81%E5%AF%BB%E5%9D%80%E6%96%B9%E5%BC%8F%E4%B8%8E%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F/"/>
      <url>/2021/02/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E8%A1%A8%E7%A4%BA%E3%80%81%E5%AF%BB%E5%9D%80%E6%96%B9%E5%BC%8F%E4%B8%8E%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F/</url>
      
        <content type="html"><![CDATA[<p>从数据表示、寻址方式与指令系统来分析，为程序设计者提供什么样的机器级界面，以合理进行软、硬件功能分配。在保持高级语言与机器语言、操作系统与计算机系统结构、程序设计环境与计算机系统结构之间适当的语义差距前提下，分析怎样来改进计算机系统结构，同时讨论缩小语义差距的途径。</p><p><img src="https://personal-blog.oss-cn-hangzhou.aliyuncs.com/CA_chapter_2.png"></p><h1 id="1-数据表示"><a href="#1-数据表示" class="headerlink" title="1 数据表示"></a>1 数据表示</h1><h2 id="1-1-数据表示的定义，数据表示与数据结构的关系"><a href="#1-1-数据表示的定义，数据表示与数据结构的关系" class="headerlink" title="1.1 数据表示的定义，数据表示与数据结构的关系"></a>1.1 数据表示的定义，数据表示与数据结构的关系</h2><p>数据表示指的是能由计算机硬件识别和引用的数据类型，表现在它有对这种类型的数据进行操作的指令和运算部件。</p><p>数据结构是要通过软件映像，变换成计算机中所具有的数据表示来实现的。数据结构和数据表示是软、硬件的交界面。</p><h2 id="1-2-引入数据表示的原则"><a href="#1-2-引入数据表示的原则" class="headerlink" title="1.2 引入数据表示的原则"></a>1.2 引入数据表示的原则</h2><ol><li>看系统的效率是否有显著提高，包括实现时间和存储空间是否有显著减少；</li><li>看引入这种数据表示后，其通用性和利用率是否提高；</li></ol><h2 id="1-3-标志符数据表示的优点，与数据描述符的差别"><a href="#1-3-标志符数据表示的优点，与数据描述符的差别" class="headerlink" title="1.3 标志符数据表示的优点，与数据描述符的差别"></a>1.3 标志符数据表示的优点，与数据描述符的差别</h2><p>标志符数据表示的优点有：</p><ol><li>简化了指令系统和程序设计；</li><li>简化了编译程序；</li><li>便于实现一致性校验；</li><li>能由硬件自动变换数据类型；</li><li>支持数据库系统的实现与数据类型无关的要求，使程序不用修改即可处理多种不同类型的数据；</li><li>为软件调试和应用软件开发提供了支持；</li></ol><p>数据描述符合标志符的差别在于标志符是和每个数据相连的，合存在一个存储单元中，描述单个数据的类型特征；数据描述符则是与数据分开存放，用于描述所要访问的数据是整块的还是单个的，访问该数据块或数据元素所要的地址以及其他信息等。</p><h2 id="1-4-堆栈机器（堆栈数据表示）和向量数据表示的基本特征"><a href="#1-4-堆栈机器（堆栈数据表示）和向量数据表示的基本特征" class="headerlink" title="1.4 堆栈机器（堆栈数据表示）和向量数据表示的基本特征"></a>1.4 堆栈机器（堆栈数据表示）和向量数据表示的基本特征</h2><p>在有向量、数组数据表示的向量处理机上，硬件上设置有丰富的向量或阵列运算指令。</p><p>堆栈表现于：</p><ol><li>由高速寄存器组成的硬件堆栈，并附加控制电路，让它们与主存中的堆栈区在逻辑上构成整体，使堆栈的访问速度是寄存器的，容量是主存的；</li><li>有丰富堆栈操作指令且功能很强，可直接对堆栈中的数据进行各种运算和处理；</li><li>有力地支持了高级语言程序的编译；</li><li>有力地支持了子程序的嵌套和递归调用；</li></ol><h2 id="1-5-浮点尾数基值大小的利和弊，能熟练计算尾数基值不同时浮点数可表示值的范围、可表示数的个数等参数"><a href="#1-5-浮点尾数基值大小的利和弊，能熟练计算尾数基值不同时浮点数可表示值的范围、可表示数的个数等参数" class="headerlink" title="1.5 浮点尾数基值大小的利和弊，能熟练计算尾数基值不同时浮点数可表示值的范围、可表示数的个数等参数"></a>1.5 浮点尾数基值大小的利和弊，能熟练计算尾数基值不同时浮点数可表示值的范围、可表示数的个数等参数</h2><p>浮点基值取大，会扩大浮点数的表示范围，增加可表示数的个数，减少移位次数，降低右移造成的精度损失和提高运算速度；但其也会降低数据的表示精度，数值的分布变稀。</p><h2 id="1-6-综述和比较尾数下溢处理表的原则，能具体填表"><a href="#1-6-综述和比较尾数下溢处理表的原则，能具体填表" class="headerlink" title="1.6 综述和比较尾数下溢处理表的原则，能具体填表"></a>1.6 综述和比较尾数下溢处理表的原则，能具体填表</h2><table><thead><tr><th align="center">方法</th><th align="center">描述</th><th align="center">优点</th><th align="center">缺点</th></tr></thead><tbody><tr><td align="center">截断法</td><td align="center">将尾数超出计算机字长的部分截去</td><td align="center">1. 实现简单；<br/>2. 不增加硬件；<br/>3. 不需要处理时间；</td><td align="center">1. 最大误差较大；<br/>2. 平均误差大且无法调节；</td></tr><tr><td align="center">舍入法</td><td align="center">在计算机运算的规定字长之外增设一位附加位，存放溢出部分的最高位，每当进行尾数下溢处理时，将附加位加 1（二进制整数相当于加 0.5，二进制小数相当于加 2 <sup>-(m+1)</sup>）</td><td align="center">1. 实现简单；<br/>2. 增加的硬件很少；<br/>3. 最大误差小；<br/>4. 平均误差接近于零；</td><td align="center">1. 处理速度慢；</td></tr><tr><td align="center">恒置「1」法</td><td align="center">将计算机运算的规定字长的最低位恒置为「1」</td><td align="center">1. 实现简单；<br/>2. 不需要增加硬件和处理时间；<br/>3. 平均误差趋于 0；</td><td align="center">1. 最大误差最大；</td></tr><tr><td align="center">查表舍入法</td><td align="center">用 ROM 或 PLA 存放下溢处理表</td><td align="center">1. 速度较快；<br/>2. 平均误差可调节到 0；</td><td align="center">1. 硬件量最大；</td></tr></tbody></table><h1 id="2-寻址方式"><a href="#2-寻址方式" class="headerlink" title="2 寻址方式"></a>2 寻址方式</h1><p>寻址方式指的是按指令按什么方式寻找（或访问）到所需的操作数或信息的。</p><p>寻址方式在多样性、灵活性、寻址范围、地址映像算法和地址变换速度等方面都有了很大的进展。</p><h2 id="2-1-寻址方式的-3-种面向，逻辑地址和物理地址的定义"><a href="#2-1-寻址方式的-3-种面向，逻辑地址和物理地址的定义" class="headerlink" title="2.1 寻址方式的 3 种面向，逻辑地址和物理地址的定义"></a>2.1 寻址方式的 3 种面向，逻辑地址和物理地址的定义</h2><p>多数计算机都将主存、寄存器、堆栈分类编址，分别有 <strong>面向主存</strong>、<strong>面向寄存器</strong> 和 <strong>面向堆栈</strong> 的寻址方式。</p><p><strong>面向主存</strong> 的寻址方式主要访问主存，少量访问寄存器。</p><p><strong>面向寄存器</strong> 的寻址主要访问寄存器，少量访问主存和堆栈。</p><p><strong>面向堆栈</strong> 的寻址主要访问堆栈，少量访问主存或寄存器。</p><p><strong>面向堆栈</strong> 的寻址利于减轻对高级语言编译的负担，不用考虑寄存器的优化分配和使用，利于支持子程序嵌套、递归调用时的参数、返回地址及现场等的保存和恢复。堆栈寻址可省去许多地址字段，节省程序空间，存储效率高，免去了复杂的地址计算。但 <strong>面向寄存器</strong> 的寻址不用访问主存，速度比 <strong>面向堆栈</strong> 的快得多，因此，对向量、矩阵运算用面向寄存器的寻址要好。如果赋值语句的右部表达式只有一个数据项，面向堆栈的寻址因每次要把操作数由主存亚入堆栈，结果又要由堆栈弹回主存，速度反而慢。</p><p><strong>逻辑地址</strong> 是程序员编程用的地址。</p><p><strong>物理地址</strong> 是程序在主存中的实际地址。</p><h2 id="2-2-寻址方式在指令中的两种指明方式及其优缺点"><a href="#2-2-寻址方式在指令中的两种指明方式及其优缺点" class="headerlink" title="2.2 寻址方式在指令中的两种指明方式及其优缺点"></a>2.2 寻址方式在指令中的两种指明方式及其优缺点</h2><table><thead><tr><th align="center">方式</th><th align="center">优点</th><th align="center">缺点</th></tr></thead><tbody><tr><td align="center">占用操作码中的某些位来指明</td><td align="center">1. 操作码和寻址方式位总位数短；</td><td align="center">1. 操作码长；<br/>2. 不太灵活；</td></tr><tr><td align="center">不占用操作码，在地址码部分专门设置寻址方式位字段指明</td><td align="center">1. 寻址灵活；<br/>2. 操作码短；</td><td align="center">1. 需专门的寻址方式位字段；</td></tr></tbody></table><h2 id="2-3-程序的静态再定位和动态再定位的含义和实现"><a href="#2-3-程序的静态再定位和动态再定位的含义和实现" class="headerlink" title="2.3 程序的静态再定位和动态再定位的含义和实现"></a>2.3 程序的静态再定位和动态再定位的含义和实现</h2><p><code>静态再定位</code>：在目的程序装入主存时，由装入程序用软件方法把目的程序的逻辑地址变换成物理地址，程序执行时，物理地址不再改变。</p><p><code>动态再定位</code>：在执行每条指令时才形成访存物理地址。</p><p><strong>变址寻址</strong> 是对诸如向量、数组等数据块运算的支持，以便于实现程序的循环。</p><p><strong>基址寻址</strong> 是对逻辑地址空间到物理地址空间变换的支持，以利于实现程序的动态再定位。</p><h2 id="2-4-信息在内存中按整数边界存储的含义、编址要求、存在问题和适用场合"><a href="#2-4-信息在内存中按整数边界存储的含义、编址要求、存在问题和适用场合" class="headerlink" title="2.4 信息在内存中按整数边界存储的含义、编址要求、存在问题和适用场合"></a>2.4 信息在内存中按整数边界存储的含义、编址要求、存在问题和适用场合</h2><p>为了使任何时候所需的信息都只用一个存储周期访问到，要求信息在主存中存放的地址必须是该信息宽度（字节数）的整数倍。否则，可能发送信息跨主存边界存放，此时认为地址有错，不予访问。</p><p>信息在存储器中存放的地址必须是：</p><ol><li>字节信息地址为：X···XXXX</li><li>半字信息地址为：X···XXX0</li><li>单字信息地址为：X···XX00</li><li>双字信息地址为：X···X000</li></ol><p>信息在存储器中按整数边界存储对于保证访问速度是必要的，但是它会造成存储空间的某些浪费。</p><h1 id="3-指令格式的优化设计"><a href="#3-指令格式的优化设计" class="headerlink" title="3 指令格式的优化设计"></a>3 指令格式的优化设计</h1><p>指令设计时程序设计者看计算机的主要属性，是软、硬件的主要界面，它在很大程度上决定了计算机具有的基本功能。</p><p>设计和确定指令系统主要应考虑如何有利于满足系统的基本功能，有利于优化计算机的性能价格比，有利于指令系统今后的发展和改进。</p><p>指令系统的设计包括 <strong>指令的功能（操作类型、寻址方式和具体操作内容）</strong>和 <strong>指令格式</strong> 的设计。</p><h2 id="3-1-指令格式优化的含义"><a href="#3-1-指令格式优化的含义" class="headerlink" title="3.1 指令格式优化的含义"></a>3.1 指令格式优化的含义</h2><p>指令是有 <strong>操作码</strong> 和 <strong>地址码</strong> 两部分组成的。就指令格式的优化来说，是指如何用最短的位数来表示指令的操作信息和地址信息，是程序中指令的平均字长最短。</p><h2 id="3-2-哈夫曼编码、优化的扩展操作码编码，能求出操作码的平均码长"><a href="#3-2-哈夫曼编码、优化的扩展操作码编码，能求出操作码的平均码长" class="headerlink" title="3.2 哈夫曼编码、优化的扩展操作码编码，能求出操作码的平均码长"></a>3.2 哈夫曼编码、优化的扩展操作码编码，能求出操作码的平均码长</h2><p>哈夫曼压缩概念的基本思想是，当各种事件发生的概率不均等时，采用优化技术，对发生概率高最高的事件用最短的位数（时间）来表示（处理），而对出现概率较低的事件允许用较长的位数（时间）来表示（处理），就会使表示（处理）的平均位数（时间）缩短。</p><p>研究操作码的优化表示主要是为了缩短指令字长，减少程序总位数及增加指令字能表示的操作信息和地址信息。</p><p>扩展操作码编码是界于定长二进制编码和完全的哈夫曼编码之间的一种编码方式，操作码不是定长的，但只有有限的几种码长。仍利用高概率的用短码、低概率的用长码表示的哈夫曼压缩思想，使操作码平均长度缩短，以降低信息冗余。</p><h2 id="3-3-扩展操作码的短码不能是长码的前缀"><a href="#3-3-扩展操作码的短码不能是长码的前缀" class="headerlink" title="3.3 扩展操作码的短码不能是长码的前缀"></a>3.3 扩展操作码的短码不能是长码的前缀</h2><p>扩展操作码也必须遵守短码不能是长码的前缀的原则。扩展操作码的编码不唯一，平均码长也不唯一，问题是如何找出一种平均码长尽可能短，码长种类数不能过多而又便于优化实现的方案。</p><p>指令中处理操作码外，后面所跟的或者是操作数，或者是操作数所在的寄存器编号，或者是存储单元的地址码，它们又都是以二进制编码的形式出现，所以如果短操作码成了长操作码的前缀，就会使指令操作码译码时，无法做到唯一译码和立即解码。</p><h2 id="3-4-综述指令格式优化设计措施"><a href="#3-4-综述指令格式优化设计措施" class="headerlink" title="3.4 综述指令格式优化设计措施"></a>3.4 综述指令格式优化设计措施</h2><ol><li>采用扩展操作码，并根据指令的频度 p<sub>i</sub> 的分布状况选择合适的编码方式，以缩短操作码的平均码长；</li><li>采用诸如基址、变址、相对、寄存器、寄存器间接、段氏存放、隐式指明等多种寻址方式，以缩短地址码的长度，并在有限的地址长度内提供更多的地址信息；</li><li>采用 0、1、2、3 等多种地址制，以增强指令的功能，这样从宏观上就越能缩短程序的长度，并加快程序的执行速度；</li><li>在同种地址制内再采用多种地址形式，如寄存器-寄存器、寄存器-主存、主存-主存等，让每种地址字段可以有多种长度，且让长操作码与短地址码进行组配；</li><li>在维持指令字在存储器汇总按整数边界存储的前提下，使用多种不同的指令字长度；</li></ol><h2 id="3-5-根据指令设计的全部要求，优化设计指令格式"><a href="#3-5-根据指令设计的全部要求，优化设计指令格式" class="headerlink" title="3.5 根据指令设计的全部要求，优化设计指令格式"></a>3.5 根据指令设计的全部要求，优化设计指令格式</h2><p>为使计算机系统有更强的功能、更高的性能和更好的性能价格比，满足应用的需要，在机器指令系统的设计、发展和改进上有两种不同的途径和方向。</p><p>一种是如何进一步增强原有指令的功能以及设置更为复杂的新指令以取代原先由软件子程序完成的功能，实现软件功能的硬化。按此方向发展，机器指令系统日益庞大和复杂。因此，称用这种途径设计 CPU 的计算机为复杂指令系统计算机（Complex Instruction Set Computer, CISC）。</p><p>另一种是如何通过减少指令种数和简化指令功能来降低硬件设计的复杂度，提高指令的执行速度。按此方向发展，使机器指令系统精简，因此，称通过这种途径设计的 CPU 的计算机为精简指令系统计算机（Reduced Instruction Set Computer, RISC）。</p><h1 id="4-按-CISC-方向发展、改进指令系统"><a href="#4-按-CISC-方向发展、改进指令系统" class="headerlink" title="4 按 CISC 方向发展、改进指令系统"></a>4 按 CISC 方向发展、改进指令系统</h1><h2 id="4-1-面向目标程序优化实现改进指令系统的目标和思路"><a href="#4-1-面向目标程序优化实现改进指令系统的目标和思路" class="headerlink" title="4.1 面向目标程序优化实现改进指令系统的目标和思路"></a>4.1 面向目标程序优化实现改进指令系统的目标和思路</h2><p>面向目标程序的优化实现改进，就是对已有机器的指令系统进行分析，看哪些功能仍用基本指令串实现，哪些功能改用新指令实现，可以提高包括系统软件和应用软件在内的各种机器语言目标程序的实现效率。该方法既能减少目标程序占用的存储空间，减少程序执行中的访问次数，缩短指令的执行时间，提高程序的运行速度，又使实现更为容易。</p><ol><li>通过对大量已有机器的机器语言程序及其执行情况，统计各种指令和指令串的使用频度来加以分析和改进。程序中统计出的指令及指令串使用频度称为静态使用频度。按静态使用频度改进指令系统着眼于减少目标程序所占用的存储空间。在目标程序执行过程中，对指令和指令串统计出的频度称为动态使用频度。按动态使用频度改进指令系统着眼于减少目标程序的执行时间；</li><li>增设强功能复合指令来取代原先由常用宏指令或子程序（如双倍长运算、三角函数、开方、指数、二-十进制数转换、编辑、翻译等子程序）实现的功能，由微程序解释实现，不仅大大提高了运算速度，减少了程序调用的额外开销，也减少了子程序所占的主存空间。</li></ol><h2 id="4-2-面向高级语言优化实现改进指令系统的目标和思路"><a href="#4-2-面向高级语言优化实现改进指令系统的目标和思路" class="headerlink" title="4.2 面向高级语言优化实现改进指令系统的目标和思路"></a>4.2 面向高级语言优化实现改进指令系统的目标和思路</h2><p>面向高级语言的优化实现改进就是尽可能缩短高级语言和机器语言的语义差距，支持高级语言编译，缩短编译程序长度和编译时间。</p><ol><li>如果对源程序中各种高级语言语句的使用频度进行统计来分析改进。对高频语句增设与之语义差距小的新指令。但不同用途的高级语言，其语句使用频度有较大差异，计算机指令系统很难做到对各种语言都是优化的。所以，这种优化只能是面向用户所用的语言，而且这种改进是零碎的、局部的；</li><li>如何面向编译，优化代码生成来改进。由于目前计算机上运行的绝大多数目标程序都是经过编译系统生成的，从优化代码生成上考虑，应当增强系统结构的规整性，尽量减少例外或特殊的情况和用法，让所有运算都对称、均匀地在存储（寄存器）单元间进行。对所有存储（寄存器）单元同等对待，无论是操作数或运算结果都无可约束地存放在任意单元中。这样，为优化管理通用寄存器的使用可以大大减少很多的辅助开销；</li><li>改进指令系统，使它与各种语言间的语言差距都有同等的缩小；</li><li>既然各种高级语言所要求的优化指令系统并不相同，提出采用让计算机具有分别面向各种高级语言的多种指令系统、多种系统结构的面向问题动态自寻优的计算机系统；</li><li>发展高级语言计算机（或称高级语言机器）；</li></ol><h2 id="4-3-高级语言机器的定义和两种形式，高级语言机器难以发展的原因"><a href="#4-3-高级语言机器的定义和两种形式，高级语言机器难以发展的原因" class="headerlink" title="4.3 高级语言机器的定义和两种形式，高级语言机器难以发展的原因"></a>4.3 高级语言机器的定义和两种形式，高级语言机器难以发展的原因</h2><ol><li>让高级语言直接成为机器的汇编语言，通过汇编（用软件或硬件实现）把高级语言源程序翻译成机器语言目标程序，这种高级语言机器称为间接执行的高级语言机器；</li><li>让高级语言本身就作为机器语言，由硬件或固件逐条进行解释执行，既不用编译，也不用汇编，这种高级语言机器称为直接执行的高级语言机器。由于是逐条解释，因此，当发现有程序设计错误时，错误现场易于保存，也易于排除错误，且对实现交互式的语言比较有利；</li></ol><p>主要是因为目前高级语言种类繁多，实际运用中经常要用到多种高级语言，如果只是适于面向某种高级语言或语言结构相近的少数几种高级语言，高级语言机器就难以获得实用。虽然可以考虑在机器中装有面向多种高级语言的 VLSI 芯片，或发展动态自适应系统，但还有许多难题有待解决，而且这样做性能价格比将会明显降低，难以受到用户的欢迎。此外，各种高级语言不是只用解释就都能高效实现的。</p><h2 id="4-4-面向操作系统优化实现改进指令系统的目标和思路"><a href="#4-4-面向操作系统优化实现改进指令系统的目标和思路" class="headerlink" title="4.4 面向操作系统优化实现改进指令系统的目标和思路"></a>4.4 面向操作系统优化实现改进指令系统的目标和思路</h2><p>面向操作系统的优化实现改进的主要目标就是如何通过缩短操作系统与计算机系统结构之间的语义差距，进一步减少运行操作系统的时间和节省操作系统软件所占用的存储空间。</p><ol><li>通过对操作系统中常用指令和指令串的使用频度进行统计分析来改进；</li><li>考虑如何增设专用于操作系统的新指令；</li><li>把操作系统中频繁使用的，对速度影响大的机构型软件子程序硬化或固化，改为直接用硬件或微程序解释实现；</li><li>发展让操作系统由专门的处理机来执行的功能分布处理系统结构；</li></ol><h1 id="5-按-RISC-方向发展改进指令系统"><a href="#5-按-RISC-方向发展改进指令系统" class="headerlink" title="5 按 RISC 方向发展改进指令系统"></a>5 按 RISC 方向发展改进指令系统</h1><h2 id="5-1-CISC-的问题和-RISC-的优点"><a href="#5-1-CISC-的问题和-RISC-的优点" class="headerlink" title="5.1 CISC 的问题和 RISC 的优点"></a>5.1 CISC 的问题和 RISC 的优点</h2><p>CISC 的问题如下：</p><ol><li>指令系统庞大，一般指令在 200 条以上。许多指令的功能异常复杂，需要有多种寻址方式、指令格式和指令长度。完成指令的译码、分析和执行的控制器复杂，不仅 VLSI 设计困难，不利于自动化设计，延长了设计周期，增大了设计成本，也容易增大设计出错的机会，降低了系统的可靠性，而且为发现和纠正这些错误花费的时间和代价也会增大；</li><li>许多指令的操作复杂，执行速度很低，甚至不如用几条简单、基本的指令组合实现；</li><li>由于指令系统庞大，各种指令的使用频度都不会太高，且差别很大，其中相当一部分指令的利用率很低；</li></ol><p>RISC 的优点有：</p><ol><li>简化指令系统设计，适合 VLSI 实现；</li><li>提高计算机的执行速度和效率；</li><li>降低设计成本，提高系统的可靠性；</li><li>可直接支持高级语言的实现，简化编译程序设计；</li></ol><p>但是，RISC 也存在着一些问题和不足，主要有：</p><ol><li>由于指令少，使原来在 CISC 上由单一指令完成的某些复杂功能现在要用多条 RISC 指令才能完成，加重了汇编语言程序设计的负担，增加了机器语言程序的长度，占用存储空间多，加大了之类的信息流量；</li><li>对浮点运算的执行和虚拟存储器的支持虽有很大加强，但仍显得不足；</li><li>RISC 计算机的编译程序比 CISC 的难写；</li></ol><h2 id="5-2-设计-RISC-机器的一般原则"><a href="#5-2-设计-RISC-机器的一般原则" class="headerlink" title="5.2 设计 RISC 机器的一般原则"></a>5.2 设计 RISC 机器的一般原则</h2><ol><li>确定指令系统时，只选择使用频度很高的那些指令，在增加少量有效支持操作系统、高级语言实现及其他功能的指令，大大减少指令条数，一般使之不超过 100 条；</li><li>减少指令系统所用寻址方式种类，一般不超过两种。简化指令的格式限制在两种之内，并让全部指令都是相同长度；</li><li>让所有指令都在一个机器周期内完成；</li><li>扩大通用寄存器数，一般不少于 32 个，尽量减少访存，所有指令只有存（STORE）、取（LOAD）指令访存，其他指令一律只对寄存器操作；</li><li>为提高指令执行速度，大多数指令都用硬联控制实现，少数指令才用微程序实现；</li><li>通过精简指令和优化设计编译程序，简单、有效地支持高级语言的实现；</li></ol><h2 id="5-3-设计-RISC-机器的基本技术"><a href="#5-3-设计-RISC-机器的基本技术" class="headerlink" title="5.3 设计 RISC 机器的基本技术"></a>5.3 设计 RISC 机器的基本技术</h2><ol><li>按设计 RISC 的一般原则来设计。确定指令系统时，通过指令使用频度的统计，选取其中常用的基本指令，并增设一些对操作系统、高级语言、应用环境等支持最有用的指令，使指令数精简。在指令的功能、格式和编码设计上尽可能简化、规整。所有指令尽可能等长，寻址方式尽量统一成 1~2 种，指令的执行尽量安排在一个机器周期内完成；</li><li>逻辑实现采用硬联和微程序相结合。用微程序解释机器指令有较强的灵活性和适应性，只要改写控制存储器中的微程序就可以增加或修改机器指令，也便于实现一些功能较复杂的指令。问题主要是多次访控制存储器取微指令要花费一定的时间，不利于 RISC 计算机要求指令在一个机器周期里执行完成。因此，让大多数简单指令采用硬联方式实现，功能较复杂的指令允许用微程序解释实现，是比较适宜的，而且较多地采用高度水平型微指令（微指令长度可达 64 位）或毫微程序方式实现，可以免去或减少微指令的译码时间，直接控制通路操作，加快解释和便于微指令流水；</li><li>在 CPU 中设置大量工作寄存器并采用重叠寄存器窗口。为减少访存，尽量让指令的操作在寄存器之间进行，以提高执行速度，缩短指令周期，简化寻址方式和指令格式；为更简单、有效地支持高级语言中大量出现的过程调用，减少过程调用中为保存主调过程现场，建立被调过程新现场，以及返回时恢复主调过程现场等所需的辅助操作；也为了能更简单、更直接地实现过程间的参数传递，大多数 RISC 计算机的 CPU 中都设有大量寄存器，让每个过程使用一个有限量的寄存器窗口，并让各过程的寄存器窗口部分重叠；</li><li>指令用流水和延迟转移。RISC 计算机的每条指令都在一个机器周期内完成，为加快速度，一般让本条指令的执行与下条指令的预取在时间上重叠。而大多数 RISC 指令的操作都在寄存器中进行，因此执行时又可将从源寄存器读取、运算及运算结果打入目的寄存器，三者之间用流水实现。所以，RISC 结构中指令的取出和执行都采用流水来提高速度，流水线的级数因计算机而异；</li><li>采用高速缓冲器存储 Cache，设置指令 Cache 和数据 Cache 分别存放指令和数据。这样可以保证向指令流水线不间断地输送指令和存取数据，以提高流水的效率；</li><li>优化设计编译系统。RISC 计算机由于使用了大量寄存器，因此，编译程序必须尽量优化寄存器的分配，提高其使用效率，减少访存次数。要充分利用常规的优化技术和手段来设计编译程序，如将公用的子表达式消去，将常数移到循环体外，简化局部变量和工作变量的中间传递。另外，还应优化调整指令的执行顺序，以尽量减少计算机的空闲等；</li></ol>]]></content>
      
      
      <categories>
          
          <category> 计算机系统结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机系统结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机系统结构-概论</title>
      <link href="/2021/02/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84-%E6%A6%82%E8%AE%BA/"/>
      <url>/2021/02/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84-%E6%A6%82%E8%AE%BA/</url>
      
        <content type="html"><![CDATA[<p>计算机系统结构是一门从组织和结构的角度学习、领会计算机系统的课程。计算机系统是一个软、硬件综合体。本文学习的目的是了解计算机系统结构的基本概念和知识，为后面进一步学习后续知识打好基础。</p><p><img src="https://personal-blog.oss-cn-hangzhou.aliyuncs.com/CA_chapter_1.png"></p><h1 id="学习目的"><a href="#学习目的" class="headerlink" title="学习目的"></a>学习目的</h1><ol><li>理解一个完整的计算机系统可被看成是由多个机器级构成的多级层次结构，知道层次的划分；</li><li>掌握结构、组成、实现三者的定义和内涵，对透明性能做出正确的判断；</li><li>理解软、硬件取舍的基本原则和计算机系统的定量设计原理；</li><li>掌握计算机系统设计的 3 种思路及各自的优缺点，理解「从中间向两边」设计是好的思路；</li><li>掌握实现软件移植的途径、方法、适用场合、存在问题和对策；</li><li>了解应用和器件的发展对系统结构的影响；</li><li>掌握并行性概念，以及计算机系统结构中并行性开发的途径和结构分类；</li><li>了解计算机系统的分类；</li></ol><h1 id="1-计算机系统的多级层次结构"><a href="#1-计算机系统的多级层次结构" class="headerlink" title="1. 计算机系统的多级层次结构"></a>1. 计算机系统的多级层次结构</h1><h2 id="1-1-现代通用计算机系统可分成哪几级，它们的相对位置"><a href="#1-1-现代通用计算机系统可分成哪几级，它们的相对位置" class="headerlink" title="1.1 现代通用计算机系统可分成哪几级，它们的相对位置"></a>1.1 现代通用计算机系统可分成哪几级，它们的相对位置</h2><p>从使用语言的角度，一台由软、硬件组成的通用计算机系统可以被看成是按功能划分的多层机器级组成的层次结构，可参考下图：</p><p><img src="https://personal-blog.oss-cn-hangzhou.aliyuncs.com/CA_layer_struct.png" alt="计算机系统的多级层次结构"></p><p>具体的计算机系统，其层次的多少可以有所不同。</p><h2 id="1-2-各机器级的实现所用的是翻译技术还是解释技术"><a href="#1-2-各机器级的实现所用的是翻译技术还是解释技术" class="headerlink" title="1.2 各机器级的实现所用的是翻译技术还是解释技术"></a>1.2 各机器级的实现所用的是翻译技术还是解释技术</h2><blockquote><p>翻译（Translation）技术是先用转换程序将高一级机器上的程序整个地变换成低一级机器级上等效的程序，然后在低一级机器级上实现的技术。</p><p>解释（Interpretation）技术是在低级机器级上用它的一串语句或指令来仿真高级机器级上的一条语句或指令的功能，是通过对高级机器级语言程序中的每条语句或指令系统逐条解析来实现的技术。</p></blockquote><p>传统机器语言机器级 M1 采用组合逻辑电路控制，其指令可直接用硬件来实现，也可以采用微程序控制，用微指令（L0）程序来解释实现。微指令直接控制硬件电路的动作。</p><table><thead><tr><th align="center">机器级</th><th align="center">实现方式</th></tr></thead><tbody><tr><td align="center">M0</td><td align="center">硬件</td></tr><tr><td align="center">M1</td><td align="center">微程序（固件）</td></tr><tr><td align="center">M2~M5</td><td align="center">软件</td></tr></tbody></table><p><img src="https://personal-blog.oss-cn-hangzhou.aliyuncs.com/CA_layer_language.png" alt="各机器级采用的技术"></p><p><code>固件</code>：是一种具有软件功能的硬件。</p><p><code>虚拟机</code>：以软件为主实现的机器。</p><h1 id="2-计算机系统结构、组成和实现"><a href="#2-计算机系统结构、组成和实现" class="headerlink" title="2. 计算机系统结构、组成和实现"></a>2. 计算机系统结构、组成和实现</h1><h2 id="2-1-计算机系统结构、组成和实现的定义和研究方向"><a href="#2-1-计算机系统结构、组成和实现的定义和研究方向" class="headerlink" title="2.1 计算机系统结构、组成和实现的定义和研究方向"></a>2.1 计算机系统结构、组成和实现的定义和研究方向</h2><blockquote><p>从计算机的层次结构角度来看，系统结构（System Architecture）是对计算机系统中各级界面的定义及其上下的功能分配。</p></blockquote><p>计算机系统结构研究的是软、硬件之间的功能分配以及对传统机器级界面的确定。为机器语言、汇编语言程序设计者或编译程序生成系统设计或生成的程序能在机器上正确运行提供应看到和遵循的计算机属性。</p><p>就目前通用机来说，计算机系统结构的属性包括：</p><ol><li>硬件能直接识别和处理的数据类型及格式等的数据表示；</li><li>最小可寻址单位、寻址种类、地址计算等寻址方式；</li><li>通用&#x2F;专用寄存器的设置、数量、字长、使用约定等的寄存器组织；</li><li>二进制或汇编指令的操作类型、格式、排序方式、控制机构等的指令系统；</li><li>主存的最小编址单位、编址方式、容量、最大可编址空间等的存储系统组织；</li><li>中断的分类与分级、中断处理程序功能及入口地址等的中断机构；</li><li>系统机器级的管态和用户态的定义与切换；</li><li>输入&#x2F;输出设备的连接、使用方式、流量、操作结束、出错指示等的机器级 I&#x2F;O 结构；</li><li>系统各部分的信息保护方式和保护机构属性；</li></ol><p>从计算机系统结构的内涵可以看出，机器级内部的数据流和控制流的组成、逻辑设计和器件设计等都不属于计算机系统结构，就是说，它们对计算机系统结构设计时透明的。</p><blockquote><p>计算机组成（Computer Organization）指的是计算机系统结构的逻辑实现，包括机器级内部的数据流和控制流的组成以及逻辑设计等。</p></blockquote><p>计算机组成着眼于机器级内部各事件的排序方式与控制结构、各部件的功能及各部件间的联系。它要解决的问题是在希望达到的吸能和价格的情况下，如何更好、更合理地把各种设备和部件组织成计算机，实现所确定的系统结构。</p><p>计算机组成设计要确定的方面一般包括：</p><ol><li>数据通路宽度（数据总线一次并行传送的信息位数）；</li><li>专用部件的设置（是否设置乘除法、浮点运算、字符处理、地址运算等专用部件，设置的数量与机器要达到的速度、价格及专用部件的使用频率等有关）；</li><li>各种操作对部件的共享程度（分时共享使用程度高，虽然限制的速度，但价格便宜；设置部件多降低共享程度，因操作并行度提高，可提高速度，但价格也会更高）；</li><li>功能部件的并行度（是用顺序串行，还是用叠、流水或分布式控制和管理）；</li><li>控制机构的组成方式（用硬件还是微程序控制，是单击处理还是多机或功能分布处理）；</li><li>缓冲和排队技术（部件间如何设置及设置多大容量的缓冲器来协调它们的速度差。是用随机、先进先出、先进后出、优先级，还是用循环方式来安排事件处理的顺序）；</li><li>预估、预判技术（用什么原则为优化性能预测未来行为）；</li><li>可靠性技术（用何种冗余和容错技术来提高可靠性）；</li></ol><blockquote><p>计算机实现（Computer Implementation）指的是计算机组成的物理实现，包括处理机、主存等部件的物理结构，器件的集成度和速度，器件、模块、插件、底板的划分与连接，专用器件的设计，微组装技术，信号传输，电源、冷却及整机装配技术等。</p></blockquote><p>计算机实现的设计着眼于器件技术和微组装技术，其中，器件技术起着主导作用。</p><p>以主存与编址方式举个🌰：</p><p>主存容量与编址方式（按位、字节、字访问等）的确定属于 <strong>计算机系统结构</strong>。</p><p>为达到性能价格要求，主存速度应该为多少，以及逻辑结构是否采用多体交叉属于 <strong>计算机组成</strong>。</p><p>主存器件的选定、逻辑设计、微组装技术的使用属于 <strong>计算机实现</strong>。</p><h2 id="2-2-计算机系统结构是软、硬件的主要界面"><a href="#2-2-计算机系统结构是软、硬件的主要界面" class="headerlink" title="2.2 计算机系统结构是软、硬件的主要界面"></a>2.2 计算机系统结构是软、硬件的主要界面</h2><p>计算机系统结构也称计算机系统的体系结构（Computer Architecture），它只是系统结构中的一部分，指的是传统机器语言机器级的系统结构。其界面之上包括操作系统级、汇编语言级、高级语言级和应用语言级中所有软件的功能，该界面之下包括所有硬件和固件的功能。因此，它是软件和硬件&#x2F;固件的交界面，是机器语言、汇编语言程序设计者或编译程序设计者看到的机器物理系统的抽象。</p><h2 id="2-3-系统结构、组成和实现的关系和影响"><a href="#2-3-系统结构、组成和实现的关系和影响" class="headerlink" title="2.3 系统结构、组成和实现的关系和影响"></a>2.3 系统结构、组成和实现的关系和影响</h2><p>计算机系统结构、组成和实现三者互不相同，但又相互影响。相同结构的计算机可以采用不同的组成；同样，一种组成可有多种不同的实现方法。</p><p>结构不同会使可能采用的组成技术不同。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">示例：A = B + C</span><br><span class="line"></span><br><span class="line"><span class="comment">// 采用面向寄存器的系统结构</span></span><br><span class="line">LOAD R1, B</span><br><span class="line">ADD R1, C</span><br><span class="line">STORE A, R1</span><br><span class="line"></span><br><span class="line"><span class="comment">// 采用面向主存的三地址寻址方式的结构</span></span><br><span class="line">ADD B, C, A</span><br></pre></td></tr></table></figure><p>组成也会影响结构。组成设计向上决定于结构，向下受限于实现技术。然而，它们是可以与实现折中权衡的。例如，为达到所要求的速度，可用较简单的组成，但却是复杂的实现技术；也可用复杂的组成，但却是一般速度的实现技术。</p><p>计算机系统结构设计的任务是进行软、硬件的功能分配，确定传统机器级的软、硬件界面，但作为「计算机系统结构」这门学科来讲，实际上包括了系统结构和组成两个方面的内容。因此，它研究的是软、硬件的功能分配以及如何更好、更合理地实现分配给硬件的功能。可把着眼于软、硬件功能分配和确定程序设计者所看到的机器级界面的计算机系统结构，称为程序设计者看到的计算机系统结构；而把着眼于如何更好、更合理地实现分配给硬件的功能的计算机组成，称为计算机设计者看到的计算机系统结构。</p><h2 id="2-4-透明性概念，对具体问题能正确给出是否应透明的选择"><a href="#2-4-透明性概念，对具体问题能正确给出是否应透明的选择" class="headerlink" title="2.4 透明性概念，对具体问题能正确给出是否应透明的选择"></a>2.4 透明性概念，对具体问题能正确给出是否应透明的选择</h2><blockquote><p><code>透明</code>：如果客观存在的事务或属性从某个角度看不到，则称它为透明（Transparent）的。</p></blockquote><h1 id="3-软、硬件取舍及定量设计原理"><a href="#3-软、硬件取舍及定量设计原理" class="headerlink" title="3. 软、硬件取舍及定量设计原理"></a>3. 软、硬件取舍及定量设计原理</h1><h2 id="3-1-软、硬件实现的优缺点"><a href="#3-1-软、硬件实现的优缺点" class="headerlink" title="3.1 软、硬件实现的优缺点"></a>3.1 软、硬件实现的优缺点</h2><p>软件的功能可以用硬件或固件完成，硬件的功能也可以用软件模拟完成，只是它们在性能、价格、实现的难易程度上是不同的。</p><p>一般来说，提高硬件功能的比例可提高解题速度，减少程序所需的存储空间，但会增加硬件成本，降低硬件利用率和计算机系统的灵活性及适应性；而提高软件功能的比例可降低硬件成本，提高系统的灵活性、适应性，但解题速度会下降，软件设计费用和所需存储器用量增加。</p><h2 id="3-2-软、硬件取舍的基本原则"><a href="#3-2-软、硬件取舍的基本原则" class="headerlink" title="3.2 软、硬件取舍的基本原则"></a>3.2 软、硬件取舍的基本原则</h2><p><strong>原则一</strong>：应考虑在现有硬、器件（主要是逻辑器件和存储器件）条件下，系统要有高的性价比，主要从实现费用、速度和其他性能要求来综合考虑。</p><p>只有对产量大的计算机系统，增大硬件功能实现的比例才是适宜的。如果用硬件实现不能给用户带来明显的好处，产量仍较低，则系统是不会有生命力的。</p><p><strong>原则二</strong>：要考虑到准备采用和可能采用的组成技术，使之尽可能不要过多或不合理地限制各种组成、实现技术的采用。</p><p><strong>原则三</strong>：不能仅从「硬」的角度考虑如何便于应用组成技术的成果和便于发挥器件技术的进展，还应从「软」的角度把如何为编译和操作系统的实现以及为高级语言程序的设计提供更多、更好的硬件支持放在首位。</p><p>应当进一步缩短高级语言与机器语言、操作系统与计算机系统结构、程序设计环境（如模块化、数据类型抽象）等计算机系统结构之间存在的语义差距。计算机系统结构、机器语言是用硬件和固件实现的，而这些语义差距是用软件来填补的。语义差距的大小实质上取决于软、硬件功能的分配，差距缩小了，系统结构对软件设计的支持就加强了。</p><h2 id="3-3-计算机系统的定量设计原理"><a href="#3-3-计算机系统的定量设计原理" class="headerlink" title="3.3 计算机系统的定量设计原理"></a>3.3 计算机系统的定量设计原理</h2><h3 id="3-3-1-哈夫曼（Huffman）压缩原理"><a href="#3-3-1-哈夫曼（Huffman）压缩原理" class="headerlink" title="3.3.1 哈夫曼（Huffman）压缩原理"></a>3.3.1 哈夫曼（Huffman）压缩原理</h3><p>尽可能加速处理高概率的事件远比加速处理概论很低的事件对性能的提高要显著。</p><p>例如：CPU 在运算中发生溢出的概率是很低的，为此，设计时可考虑加快不溢出时的运算速度，而对溢出时的速度不予考虑。</p><h3 id="3-3-2-Amdahl-定律"><a href="#3-3-2-Amdahl-定律" class="headerlink" title="3.3.2 Amdahl 定律"></a>3.3.2 Amdahl 定律</h3><p>该定律可用于确定对系统中性能瓶颈部件采取措施提高速度后系统性能改进的程度，即系统加速比 S<sub>p</sub>。系统加速比 S<sub>p</sub> 定义为系统改进后的性能与未改进时的性能的比值，或者定义为系统未改进时的程序执行时间 T<sub>old</sub> 与改进后的程序执行时间 T<sub>new</sub> 的比值。系统加速比 S<sub>p</sub> 与两个因素有关，即性能可改进比 f<sub>new</sub> 和部件加速比 r<sub>new</sub>。</p><p>性能可改进比 f<sub>new</sub> 是系统性能可改进部分占用的时间与未改进时系统总总执行时间的比值，显然 0 ≤ f<sub>new</sub> ≤ 1。部件加速比 r<sub>new</sub> 是系统性能可改进部分在改进后性能提高的比值，不难看出，r<sub>new</sub> ≥ 1。</p><p>这样，系统加速比为</p><p><img src="https://personal-blog.oss-cn-hangzhou.aliyuncs.com/CA_Amdahl.jpeg" alt="系统加速比公式"></p><p>其中 (1 - f<sub>new</sub>) 为不能改进性能这部分的比例。性能提高的复读受限于性能改进部分所占的比例大小，而性能改善的极限又受性能可改进比 f<sub>new</sub> 的约束。</p><p>例如：当 r<sub>new</sub> 趋近于 +∞ 时，f<sub>new</sub>&#x2F;r<sub>new</sub> ≈ 0，此时系统加速比只受限于 f<sub>new</sub> 了。</p><h3 id="3-3-3-程序访问的局部性定律"><a href="#3-3-3-程序访问的局部性定律" class="headerlink" title="3.3.3 程序访问的局部性定律"></a>3.3.3 程序访问的局部性定律</h3><p>程序访问的局部性包括了时间上和空间上的两个局部性。时间上的局部性指的是现在正使用的信息可能不久还要使用，这是因为程序存在着循环。空间上的局部性指的是最近的将来要用到的信息可能与现在正在使用的信息在程序位置上是邻近的，这是因为指令通常是顺序存放、顺序执行的，数据也通常是以向量、阵列、树、表等形式簇聚地存放在一起的。</p><p>统计表明，程序执行时，90% 的时间只访问整个程序的 10% 的那一部分，而其余 10% 的时间才访问另外 90% 的那部分程序。甚至有的程序部分访问时间连 1% 都不到。这为设计指令系统提供了重要的依据，即指令硬件的设计应尽量加速高频指令的执行。</p><h2 id="3-4-计算机系统的-3-种设计思路和存在的问题"><a href="#3-4-计算机系统的-3-种设计思路和存在的问题" class="headerlink" title="3.4 计算机系统的 3 种设计思路和存在的问题"></a>3.4 计算机系统的 3 种设计思路和存在的问题</h2><p>计算机系统设计的主要任务包括 <strong>系统结构</strong>、<strong>组成</strong> 和 <strong>实现</strong> 的设计。它涉及软硬件功能分配、计算机指令系统设计、功能组织、逻辑设计、集成电路设计、封装、电源、冷却等许多方面。优化设计时，还要熟悉编译系统和操作系统的设计技术。</p><p>计算机系统设计首先要根据市场和应用情况，确定用户对计算机系统的功能、性能和价格的要求。需要注意以下事项：</p><ol><li>要弄清楚其应用领域是专用的还是通用的；</li><li>要弄清软件兼容是放在哪级层次；</li><li>要弄清楚对操作系统有何种要求；</li><li>要如何保证有高的标准化程度；</li></ol><table><thead><tr><th align="center">实现方式</th><th align="center">优点</th><th align="center">缺点</th></tr></thead><tbody><tr><td align="center">硬件</td><td align="center">1. 速度往往较快；<br/>2. 性能好；</td><td align="center">1. 不灵活；<br/>2. 适应性差；</td></tr><tr><td align="center">软件</td><td align="center">1. 设计容易；<br/>2. 修改容易；<br/>3. 有灵活的适应性；</td><td align="center">1. 速度慢；<br/>2. 性能低；</td></tr></tbody></table><table><thead><tr><th align="center">设计方法</th><th align="center">描述</th><th align="center">问题</th></tr></thead><tbody><tr><td align="center">由上往下&#x2F;由顶向底</td><td align="center">先考虑如何满足应用要求，定好面向应用的那个虚拟机器级的特性和工作环境，再逐级的向下设计，每设计下一级都考虑对上一级是优化的。</td><td align="center">1. 串行设计，设计周期较长；<br/>2. 一旦环境改变，软、硬件分配就会很不适应，使系统效率急剧下降；<br/>3. 厂家为了经济效益，尽量避免研发生产批量少、专用性强、适用面窄的硬件；</td></tr><tr><td align="center">由下往上&#x2F;由底向顶</td><td align="center">先不管应用要求，只根据目前能用的器件，参照、吸收已有各种机器的特点，将微程序机器级（如果采用微程序控制）和传统机器级研制出来，然后，加配适用于不同应用领域的多种操作系统和编译系统软件，使应用人员可以根据不同的语言类型、数据形式，采用合适的系统软件和算法来满足应用的需要。</td><td align="center">1. 串行设计，设计周期较长；<br/>2. 软硬件脱节，软件因得不到硬件支持而显得繁杂；<br/>3. 有些性能指标往往是虚假的；</td></tr><tr><td align="center">从中间开始</td><td align="center">选择从层次结构的主要软、硬界面开始设计，即在传统机器语言机器级与操作系统机器级之间进行合理的软、硬件功能分配。即考虑到硬、器件的现状和发展，又考虑到可能使用的算法和数据结构，定义好这个界面，确定哪些功能由硬件实现，哪些功能由软件实现。同时，考虑硬件能对操作系统、编译系统的实现提供什么样的支持。然后，由这个中间界面分别向上、向下同时进行软、硬件的设计。</td><td align="center"></td></tr></tbody></table><p>计算机设计的大体步骤：</p><ol><li>需求分析：对系统的应用环境（科学计算、事务处理、实时处理、分时处理、网络、远程处理、容错、高保密性、高可靠性等）、所用语言的种类特性、对操作系统的要求、所用到的外围设备特征等，进行技术经济分析和市场分析；</li><li>需求分析说明书：需求分析说明书应包括设计准则、速度、造价、可行性、可扩性、兼容性、可靠性、灵活性、安全性、功能、所用芯片、新结构引入的风险、程序设计的方便性等的说明；</li><li>概念设计：对机器级界面，如数据表示、指令系统、寻址方式、存储机构、中断系统、输入&#x2F;输出系统、总线结构等进行具体细致的定义和设计，同时应提供几种方案，以便选择和比较；</li><li>模拟、测试：反复对所设计的系统进行优化和性能评价，使系统获得尽可能高的性能价格比；</li></ol><h2 id="3-5-计算机系统「由中间开始」设计的方法和优点"><a href="#3-5-计算机系统「由中间开始」设计的方法和优点" class="headerlink" title="3.5 计算机系统「由中间开始」设计的方法和优点"></a>3.5 计算机系统「由中间开始」设计的方法和优点</h2><p>选择从层次结构的主要软、硬界面开始设计，即在传统机器语言机器级与操作系统机器级之间进行合理的软、硬件功能分配。即考虑到硬、器件的现状和发展，又考虑到可能使用的算法和数据结构，定义好这个界面，确定哪些功能由硬件实现，哪些功能由软件实现。同时，考虑硬件能对操作系统、编译系统的实现提供什么样的支持。然后，由这个中间界面分别向上、向下同时进行软、硬件的设计。软件人员依次设计操作系统级、汇编语言级、高级语言级和应用语言级；硬件人员依次设计传统机器语言机器级、微程序机器级和数字逻辑级。软件和硬件并行设计，大大缩短了系统的设计周期，设计过程中两部分人可交流协调，适当微调软、硬件实现的比例。</p><p>优点：</p><ol><li>软、硬件并行设计，缩短了系统的设计周期；</li><li>软、硬件设计合理的分配；</li></ol><h1 id="4-系统结构设计要解决实现软件移植"><a href="#4-系统结构设计要解决实现软件移植" class="headerlink" title="4. 系统结构设计要解决实现软件移植"></a>4. 系统结构设计要解决实现软件移植</h1><p>由于软件相对于硬件的成本越来越高，产量和可靠性的提高越来越困难，所以，要改变过去那种把主要功能负担加在软件上以简化硬件的做法，就要重新分配软、硬件功能，充分利用硬、器件技术发展带来的好处，为程序设计日工更好的支持。</p><h2 id="4-1-软件可移植性的定义、实现途径，为什么要实现软件可移植"><a href="#4-1-软件可移植性的定义、实现途径，为什么要实现软件可移植" class="headerlink" title="4.1 软件可移植性的定义、实现途径，为什么要实现软件可移植"></a>4.1 软件可移植性的定义、实现途径，为什么要实现软件可移植</h2><p>由于目前已积累了大量成熟的软件，加上软件生产效率又很低，软件的排错比编写难，所以除非特殊情况，程序设计者一般不愿意，也不应该在短时间里按新的系统结构、新的指令系统去重新设计软件。为此，在系统结构设计时，提出应在新的系统结构上解决好软件的可移植性问题。</p><p><strong>软件的可以执行（Portability）</strong>指的是软件不修改或只经少量修改旧可由一台机器移到另一台机器上运行，同一软件可应用于不同的环境。</p><p>实现软件移植的技术主要有以下几种：</p><ol><li>统一高级语言；</li><li>采用系列机；</li><li>模拟和仿真；</li></ol><h2 id="4-2-采用统一高级语言实现软件移植的方法、适用场合、存在问题和对策"><a href="#4-2-采用统一高级语言实现软件移植的方法、适用场合、存在问题和对策" class="headerlink" title="4.2 采用统一高级语言实现软件移植的方法、适用场合、存在问题和对策"></a>4.2 采用统一高级语言实现软件移植的方法、适用场合、存在问题和对策</h2><p>由于高级语言是面向题目和算法的，与机器的具体结构意义不大，如果能统一出一种可满足各种应用需要的通用高级语言，那么用这种高级语言编写的应用软件就可以移植于不同的机器。如果操作系统的全部或一部分用这种高级语言编写，则系统软件中的这部分也可以移植。所以实现软件移植的一种技术就是统一高级语言，设计出一种完全 通用的高级语言，为所有程序员所使用。</p><p>这种技术应用于结构相同以至完全不同的机器之间高级语言程序的软件移植。</p><p>目前没有一种是对各种应用真正通用的高级语言原因如下：</p><ol><li>不同的用途要求语言的语法、语义结构不同；</li><li>人们对语言的基本结构看法不一；</li><li>即使同一种高级语言在不同厂家机器上也不能完全通用；</li><li>受习惯势力阻挠，人们不愿抛弃惯用的语言，因为熟悉、有经验，也不远抛弃长期积累的、用原有语言编写并已被实践证明是正确的软件；</li></ol><h2 id="4-3-采用系列机实现软件移植的方法、适用场合、存在问题和对策"><a href="#4-3-采用系列机实现软件移植的方法、适用场合、存在问题和对策" class="headerlink" title="4.3 采用系列机实现软件移植的方法、适用场合、存在问题和对策"></a>4.3 采用系列机实现软件移植的方法、适用场合、存在问题和对策</h2><p>在软、硬件界面上设定好一种系统系统结构（系列机中称系列结构），其后，软件设计者按此设计软件；硬件设计者根据机器速度、性能、价格的不同，选择不同的器件、硬件和组成、实现技术，研制并提供不同档次的机器。</p><p>只能应用在结构相同或相似的机器之间的汇编程序的软件移植。</p><p>在要求汇编语言程序兼容的前提下，系统结构的发展是很有限的，有时连突破性的组成技术都无法采用。所以这种软件兼容性要求到一定时候会反过来阻碍计算机系统结构的进一步变革。</p><p>因此，已积累的大量汇编语言应用软件资源不应轻易抛弃。同时为使新的系统结构有生命力，系列机概念和软件兼容性约束仍是设计新机器或新系列时所必须遵循的，只是到一定是会，不能固守旧系列，而要发展新系列。</p><h2 id="4-4-软件向前、向后、向下、向上兼容的定义，系列机对软件兼容的要求"><a href="#4-4-软件向前、向后、向下、向上兼容的定义，系列机对软件兼容的要求" class="headerlink" title="4.4 软件向前、向后、向下、向上兼容的定义，系列机对软件兼容的要求"></a>4.4 软件向前、向后、向下、向上兼容的定义，系列机对软件兼容的要求</h2><p>向前（后）兼容指的是在按某个时期投入市场的该型号机器上编制的软件，不加修改就能运行于在它之前（后）投入市场的机器上。</p><p>向上（下）兼容指的是按某档机器编制的软件，不加修改就能运行于比它高（低）的机器上。</p><p>同一系列内的软件一般应做到向上兼容，但向下兼容就不一定，特别是与机器速度有关的实时性软件向下兼容就难以做到。</p><p>让现在编制的程序以后都能用，这是系列机软件兼容的最基本要求和特征，即系列机软件必须保证向后兼容，力争向前兼容。</p><h2 id="4-5-正确判断系列机发展新型号机器的哪些做法可取"><a href="#4-5-正确判断系列机发展新型号机器的哪些做法可取" class="headerlink" title="4.5 正确判断系列机发展新型号机器的哪些做法可取"></a>4.5 正确判断系列机发展新型号机器的哪些做法可取</h2><p>对于那些不属于计算机系统结构，而属于计算机组成和实现的内容，不管是增加、删除还是修改，都不会影响到汇编语言程序和机器语言程序在系列机上的兼容。但是，对于属于计算机系统结构的内容，为保证软件的向后兼容，则只能为其增加新的功能和部件，而不能删掉或更改已有的功能或部件。否则，就保证不了原有的程序能在新机器上正确运行。</p><h2 id="4-6-采用模拟与仿真实现软件移植的方法、适用场合、优点、存在问题和对策"><a href="#4-6-采用模拟与仿真实现软件移植的方法、适用场合、优点、存在问题和对策" class="headerlink" title="4.6 采用模拟与仿真实现软件移植的方法、适用场合、优点、存在问题和对策"></a>4.6 采用模拟与仿真实现软件移植的方法、适用场合、优点、存在问题和对策</h2><h3 id="4-6-1-模拟"><a href="#4-6-1-模拟" class="headerlink" title="4.6.1 模拟"></a>4.6.1 模拟</h3><p>系列机只能在系统结构相同或相近（允许向后稍许发展）的机器之间实现汇编语言软件的移植。为实现不同系统结构的机器之间的机器语言软件移植，就必须做到在一种机器的系统结构上实现另一种机器的系统结构。从系统结构的主要方面—指令系统来看，就是要在一种机器上实现另一种机器的指令系统，即另一种机器语言。</p><p>例如，要求原来在 B 机器上运行的应用软件，能移植到有不同系统结构的 A 机器上，根据层次结构概念，可把 B 机器的机器语言看成是在 A 机器的机器语言级之上的一个虚拟机器语言，在 A 机器上用虚拟机概念来实现 B 机器的指令系统。B 机器的每条机器指令用 A 机器的一段机器语言程序解释，如同 A 机器上也有 B 机器的指令系统一样。这种用机器语言程序解释实现软件移植的方法称为 <code>模拟（Simulation）</code>。进行模拟的 A 机器称为宿主机，被模拟的 B 机器称为虚拟机。</p><p>为了使虚拟机的应用软件能在宿主机上运行，除了模拟虚拟机的机器语言外，还得模拟其存储体系、I&#x2F;O 系统和控制台的操作，以及形成虚拟机的操作系统。让虚拟机的操作系统受宿主机操作系统的控制。实际上是把它作为宿主机的一道应用程序，使原来分别在宿主机和虚拟机上运行的应用软件可以再宿主机上共同执行。所有为各种模拟所编制的解释程序统称为模拟程序。</p><p>模拟程序的编制是非常复杂和费时的。同时，虚拟机的每条机器指令是不能直接被宿主机的硬件执行的，需要经相应的由多条宿主机机器指令构成的解释程序来解释，这使得模拟的运行速度显著降低，实时性变差。</p><p>模拟方法只适合于移植运行时间短、使用次数少，而且在时间关系上没有约束和受限制的条件。</p><h3 id="4-6-2-仿真"><a href="#4-6-2-仿真" class="headerlink" title="4.6.2 仿真"></a>4.6.2 仿真</h3><p>如果宿主机本身采用微程序控制，那么模拟时，一条 B 机器指令的执行就需要通过二重解释：先经 A 机器的机器语言程序解释，然后每条 A 机器指令又经一段微程序解释。如果能直接用微程序去解释 B 机器的指令，显然就会加快这一解释过程。这种用微程序直接解释另一种机器指令系统的方法就称为 <code>仿真（Emulation）</code>。进行仿真的 A 机器称为宿主机，被仿真的 B 机器称为目标机。为仿真所写的解释程序称为仿真微程序。与模拟一样，除了仿真目标机的指令系统之外，还要仿真其存储体系、I&#x2F;O 系统和控制台的操作。</p><p><img src="https://personal-blog.oss-cn-hangzhou.aliyuncs.com/CA_simulation_emulator.png"></p><p><code>模拟</code> 和 <code>仿真</code> 的主要区别在于解释用的语言。仿真用的微程序解释，其解释程序存储于控制存储器中；而模拟时用机器语言程序解释，其解释程序存储于主存中。</p><p><code>仿真</code> 方法可以提高被移植软件的运行速度，但由于微程序机器级结构深深依赖于传统机器结构，故当两种机器结构差别较大时，就很难仿真，特别是 I&#x2F;O 系统差别较大时更是如此。</p><h3 id="4-6-3-模拟和仿真的选择"><a href="#4-6-3-模拟和仿真的选择" class="headerlink" title="4.6.3 模拟和仿真的选择"></a>4.6.3 模拟和仿真的选择</h3><p>不同系列间的软件移植一般是 <strong>仿真</strong> 和 <strong>模拟</strong> 并行。频繁使用的易于仿真的机器指令宜用 <strong>仿真</strong>，以提高速度；很少使用的、难以仿真的指令及 I&#x2F;O 操作宜用 <strong>模拟</strong>。即使两种机器系统差别不大，往往也需要用模拟来完成机器间的映像。</p><h2 id="4-7-软件移植手段综述"><a href="#4-7-软件移植手段综述" class="headerlink" title="4.7 软件移植手段综述"></a>4.7 软件移植手段综述</h2><p>就软件移植问题提出了统一高级语言、设计系列机及模拟与仿真等方法。统一高级语言可以解决结构相同或完全不同的机器间的软件移植，从长远看是方向，但目前难以解决，只能做相对统一。系列机时当前普遍采用的方法，但只能实现同一系列内的软件兼容，虽然允许发展、变化，但兼容的约束反过来会阻碍系统结构取得突破性的进展。模拟灵活，可实现不同系统间的软件移植，但结构差异太大时，效率、速度会急剧下降。仿真在速度上损失小，但不灵活，只能在差别不大的系统之间使用，否则效率也会过低且难以仿真，需与模拟结合才行。此外，发展异种机联网也是实现软件移植的一种途径。</p><h1 id="5-软件、应用、器件的发展对系统结构的影响"><a href="#5-软件、应用、器件的发展对系统结构的影响" class="headerlink" title="5. 软件、应用、器件的发展对系统结构的影响"></a>5. 软件、应用、器件的发展对系统结构的影响</h1><p>各种应用对结构设计会提出范围广泛的要求。其中，程序可移植、高性能价格比、便于使用、减少命令种类、简化操作步骤、高可靠性、便于维护等都是基本的要求。</p><p>计算机的性能是硬件性能（主频、CPU 运算速度、字长、数据类型、主存容量、寻址范围、存储体系、I&#x2F;O 处理能力、I&#x2F;O 设备量、指令系统等）、软件性能（高级语言状况、操作系统功能、用户程序包的配置等）、可靠性、可用性等多种指标的综合。</p><p>微型机发展的两个趋势：</p><ol><li>利用 VLSI 的发展，维持价格提高性能，向小型机靠拢；</li><li>维持性能降低价格，发展更抵挡的亚微型和微微型（掌上型）计算机，进一步扩大应用；</li></ol><p>计算机应用可归纳为向上升级的 4 类：</p><ol><li>数据处理（Data Processing）；</li><li>信息处理（Information Processing）；</li><li>只是处理（Knowledge Processing）；</li><li>智能处理（Intelligence Processing）；</li></ol><p>软件、应用、器件对计算机系统结构的发展有着很大的影响，反过来，计算机系统结构的发展又会对软件、应用、器件提出新的发展要求。结构设计不仅要了解结构、组成、实现，还要充分了解软件、应用、器件的发展，这样才能对计算机系统结构进行有效的设计、研究和探索。</p><h2 id="5-1-明白非用户片、现场片、用户片的定义"><a href="#5-1-明白非用户片、现场片、用户片的定义" class="headerlink" title="5.1 明白非用户片、现场片、用户片的定义"></a>5.1 明白非用户片、现场片、用户片的定义</h2><p><code>非用户片</code>：也称通用片，其功能是由器件厂家生产时固定的，器件的用户（即机器设计者）只能使用，不能改变器件内部功能。其中，门电路、触发器、多路开关、加法器、译码器、寄存器、计数器等逻辑类器件的继承度难以提高。</p><p><code>现场片</code>：用户根据需要可改变器件内部功能。</p><p><code>用户片</code>：专门按用户要求生产的高集成度的 VLSI 器件，完全按用户要求设计的用户片称为全用户片。全用户片由于设计周期长，设计费用高，销量小，成本高，器件厂家一般不愿生产。为解决器件厂与整机厂的矛盾，发展门阵列、门-触发器阵列等半用户片不失为一种好的选择。生产工序基本按通用片进行，仅最后在门电路或触发器间连线时按用户要求制作。</p><h2 id="5-2-概述器件发展是推动系统结构和组成前进的因素"><a href="#5-2-概述器件发展是推动系统结构和组成前进的因素" class="headerlink" title="5.2 概述器件发展是推动系统结构和组成前进的因素"></a>5.2 概述器件发展是推动系统结构和组成前进的因素</h2><p>计算机所用器件已从电子管、晶体管、小规模集成电路、大规模集成电路迅速发展到超大规模集成电路，并使用或开始使用砷化镓器件、高密度组装技术和光电子集成技术。计算机器件从电子管到小规模集成电路经历了 18 年，之后只用了 8 年就发展到使用大规模集成电路。在此期间，器件的功能和使用方法发生了很大变化，由早先使用非用户片，发展到现场片和用户片，它影响着结构和组成技术的发展。</p><h2 id="5-3-器件发展如何改变逻辑设计的方法"><a href="#5-3-器件发展如何改变逻辑设计的方法" class="headerlink" title="5.3 器件发展如何改变逻辑设计的方法"></a>5.3 器件发展如何改变逻辑设计的方法</h2><p>器件的发展改变了逻辑设计的传统方法。过去，逻辑设计主要是逻辑化简，节省门的个数、门电路的输入端数及门电路的级数，以节省功耗、降低成本、提高速度。但对于 VLSI 来说，这样做反而使设计周期延长，组成实现不规整，故障诊断困难，机器产量低，这些都将使成本反而增大。</p><h1 id="6-系统结构中的并行性开发及计算机系统的分类"><a href="#6-系统结构中的并行性开发及计算机系统的分类" class="headerlink" title="6. 系统结构中的并行性开发及计算机系统的分类"></a>6. 系统结构中的并行性开发及计算机系统的分类</h1><h2 id="6-1-并行性定义、二重含义及开发途径"><a href="#6-1-并行性定义、二重含义及开发途径" class="headerlink" title="6.1 并行性定义、二重含义及开发途径"></a>6.1 并行性定义、二重含义及开发途径</h2><p>解题中具有可以同时进行运算或操作的特性，称为 <code>并行性（Parallelism）</code>。</p><p><code>并行性</code> 包含 <strong>同时性</strong> 和 <strong>并发性</strong> 二重含义。<strong>同时性（Simultaneity）</strong> 指两个或多个事件在同一时刻发生。<strong>并发性（Concurrency）</strong>指两个或多个事件在同一时间间隔内发生。</p><h2 id="6-2-并行性等级划分"><a href="#6-2-并行性等级划分" class="headerlink" title="6.2 并行性等级划分"></a>6.2 并行性等级划分</h2><h3 id="6-2-1-从计算机系统执行程序的角度来看，并行性-等级由低到高可分为四级"><a href="#6-2-1-从计算机系统执行程序的角度来看，并行性-等级由低到高可分为四级" class="headerlink" title="6.2.1 从计算机系统执行程序的角度来看，并行性 等级由低到高可分为四级"></a>6.2.1 从计算机系统执行程序的角度来看，<strong>并行性</strong> 等级由低到高可分为四级</h3><ol><li>指令内部：一条指令内部各个微操作之间的并行执行；</li><li>指令之间：多条指令的并行执行；</li><li>任务或进程之间：多个任务或程序段的并行执行；</li><li>作业或程序之间：多个作业或多道程序的并行执行；</li></ol><h3 id="6-2-2-从计算机系统中处理数据的角度来看，并行性-等级从低到高可以分为四级"><a href="#6-2-2-从计算机系统中处理数据的角度来看，并行性-等级从低到高可以分为四级" class="headerlink" title="6.2.2 从计算机系统中处理数据的角度来看，并行性 等级从低到高可以分为四级"></a>6.2.2 从计算机系统中处理数据的角度来看，<strong>并行性</strong> 等级从低到高可以分为四级</h3><ol><li>位串子串：同时只对一个字的一位进行处理，这通常是指传统的串行单机处理机，没有并行性；</li><li>位并子串：同时对一个字的全部位进行处理，这通常是指传统的并行单机处理机，开始出现并行性；</li><li>位片串字并：同时对许多字的同一位（称位片）进行处理，开始进入并行处理领域；</li><li>全并行：同时对许多字的全部或部分位组进行处理；</li></ol><h3 id="6-2-3-并行性是贯穿于计算机信息加工的各个步骤和阶段的，从这个角度来看，并行性等级又分为"><a href="#6-2-3-并行性是贯穿于计算机信息加工的各个步骤和阶段的，从这个角度来看，并行性等级又分为" class="headerlink" title="6.2.3 并行性是贯穿于计算机信息加工的各个步骤和阶段的，从这个角度来看，并行性等级又分为"></a>6.2.3 并行性是贯穿于计算机信息加工的各个步骤和阶段的，从这个角度来看，并行性等级又分为</h3><ol><li>存储器操作并行：可用单体单字、多体单字或多体多字方式在一个存储周期内访问多个字，进而采用按内容访问方式在一个存储周期内用位片串字并或全并行方式实现对存储器中大量字的高速并行比较、检索、更新、变换等操作；</li><li>处理器操作步骤并行：指令的取指、分析、执行，浮点假发的求阶差、対阶、尾加、舍入、规格化等操作，执行步骤在时间上重叠流水地进行；</li><li>处理器操作并行：通过重复设置大量处理单元，让它们在同一控制器控制下按同一指令要求对向量、数组中各元素同时操作；</li><li>指令、任务、作业并行：这是高级的并行。虽然它也可以包含操作、操作步骤等较低级的并行，但与操作级并行不同。指令级以上的并行是多个处理器同时对多条指令和相关的多数据组进行处理，操作级并行是对同一指令及其相关的数据组进行处理。前者属于多指令流多数据流计算机，后者属于但指令流多数据计算机；</li></ol><h2 id="6-3-沿-3-种-并行性开发途径的多机系统类型和特点"><a href="#6-3-沿-3-种-并行性开发途径的多机系统类型和特点" class="headerlink" title="6.3 沿 3 种 并行性开发途径的多机系统类型和特点"></a>6.3 沿 3 种 并行性开发途径的多机系统类型和特点</h2><p>开发并行性的途径有时间重叠、资源重复和资源共享等。</p><h3 id="6-3-1-时间重叠"><a href="#6-3-1-时间重叠" class="headerlink" title="6.3.1 时间重叠"></a>6.3.1 时间重叠</h3><p>时间重叠（Time Interleaving）是在并行性概念中引入时间因素，让多个处理过程在时间上相互错开，轮流重叠地使用同一套硬件设备的各个部分，加快硬件周转来赢得速度。</p><h3 id="6-3-2-资源重复"><a href="#6-3-2-资源重复" class="headerlink" title="6.3.2 资源重复"></a>6.3.2 资源重复</h3><p>资源重复（Resource Replication）是在并行概念中引入空间因素，通过重复设置硬件资源来提高可靠性或性能。双工系统是通过使用两台相同的计算机完成同一任务来提高可靠性的。</p><h3 id="6-3-3-资源共享"><a href="#6-3-3-资源共享" class="headerlink" title="6.3.3 资源共享"></a>6.3.3 资源共享</h3><p>资源共享（Resource Sharing）是用软件方法，让多个用户按一定时间顺序轮流使用同一套资源来提高资源利用率，相应地也就提高了系统性能。</p><p>计算机系统通过各种技术途径，从不同角度和不同并行性等级上同时采用多种并行性措施，可以是执行程序方面的，也可以是处理数据方面的，还可以是在信息加工不同步骤和阶段上的。当并行性上升到一定级别形成新的结构时，就进入到并行处理的专门领域，如执行程序的并行性达到任务或进程级，处理数据的并行性达到位片串字并。并行处理是信息处理的一种有效形式，它着重发掘解题过程中的并行性。并行性的开发和并行处理技术的研究实际上是硬件、软件、语言、算法、性能评价研究的综合。</p><h2 id="6-4-耦合度概念"><a href="#6-4-耦合度概念" class="headerlink" title="6.4 耦合度概念"></a>6.4 耦合度概念</h2><p>一般同耦合度反映多级系统中各机器之间物理连接的紧密度和交叉作用能力的强弱，有最低耦合、松散耦合和紧密耦合之分。</p><p>各种脱机处理系统是最低耦合系统（Least Coupled System），其耦合度最低，除通过某种存储介质外，各计算机之间无物理连接，也无共享的联机硬件资源。</p><p>如果多台计算机通过通道或通信线路实现互连，共享某些如磁带、磁盘等外围设备，以较低频带在文件或数据集一级相互作用，则这种系统被称为松散耦合系统（Loosely Coupled System）或间接耦合系统（Indirectly Coupled System）。它有两种形式：一种是多台功能专用的计算机通过通道和共享的外围设备相连，各计算机以文件或数据集形式将结果发送到共享的外设，供其他计算机继续处理，使系统获得较高效率；另一种是各计算机经通信线路互连成计算机网，各尽所长，求得更大范围内的资源共享。这两种形式一般都是非对称的（由不同类型的计算机组成），并采用异步工作方式，结构较灵活，系统易于扩展，但需花费辅助操作开销，且系统信息的传输频带较窄，难以满足任务一级的并行处理，因而特别适合于分布处理。</p><p>如果多台计算机经总线或高速开关互连，共享主存，有较高的信息传输效率，可实现数据集一级、任务级、作业级并行，则称此系统为紧密耦合系统（Tightly Coupled System）或直接耦合系统（Directly Coupled System）。它可以是主辅机方式配合工作的非对称型系统，但更多的是对称型多处理机系统，在统一的操作系统管理下追求各处理机的高效率和负荷的均衡。</p><h2 id="6-5-计算机系统弗林分类法"><a href="#6-5-计算机系统弗林分类法" class="headerlink" title="6.5 计算机系统弗林分类法"></a>6.5 计算机系统弗林分类法</h2><p>1966 年，弗林（Michael J. Flynn）提出按 <strong>指令流</strong> 和 <strong>数据流</strong> 的 <strong>多倍性</strong> 对计算机系统分类。<strong>指令流</strong> 是指机器执行的指令序列。<strong>数据流</strong> 是指由 <strong>指令流</strong> 调用的数据序列，包括输入数据和中间结果。<strong>多倍性</strong>是指在系统性能瓶颈部件上处于同一执行阶段的指令或数据的最大可能个数。据此，把计算机系统分成如下类别：</p><ol><li>单指令流单数据流（Single Instruction Stream Single Data Stream，SISD）</li><li>单指令流多数据流（Single Instruction Stream Multiple Data Stream，SIMD）</li><li>多指令流单数据流（Multiple Instruction Stream Single Data Stream，MISD）</li><li>多指令流多数据流（Multiple Instruction Stream Multiple Data Stream，MIMD）</li></ol><p><img src="https://personal-blog.oss-cn-hangzhou.aliyuncs.com/CA_flynn.png" alt="弗林分类法"></p><p>弗林分类法能反映出大多数计算机的并行工作方式和结构特点，使用范围较广，但只能对控制流机器分类。像数据流计算机就无法用这种方法分类，而且对广泛使用的流水线处理机的分类也不确切。这种分类有时难以反映系统工作原理上的特色。</p><p>1978 年，美国的库克（David J. Kuck）提出用 <strong>指令流</strong> 和 <strong>执行流（Execution Stream）</strong>及其 <strong>多倍性</strong> 来描述计算机系统总控制器的结构特点。分类如下：</p><ol><li>单指令流单执行流（SISE）：典型的单处理机系统；</li><li>单指令流多执行流（SIME）：带多操作部件的处理机；</li><li>多指令流单执行流（MISE）：带指令级多道程序的单处理机；</li><li>多指令流多执行流（MIME）：典型的多处理机系统；</li></ol><p>1972 年，美籍华人冯泽云（Tse-yun Feng）提出了用 <strong>数据处理</strong> 的 <strong>并行度</strong> 来定量地描述各种计算机系统特征的冯氏分类法。他把计算机分成四类：</p><ol><li>字串位串（WSBS）– 称位串处理方式。每次只处理一个字中的一位，如早期的位串行机。</li><li>字串位并（WSBP）– 称字（字片）处理方式。每次处理一个字中的 n 位，如传统的位并行机。</li><li>字并位串（WPBS）– 称位（为片）处理方式。一次处理 m 个字中的 1 位，如某些相连处理机及阵列处理机。</li><li>字并位并（WPBP）– 称全并行处理方式。一次处理 m 个字，每个字为 n 位，如某些相连处理机、大多数阵列处理机及多处理机。</li></ol><p>1977 年，联邦德国的汉德勒（Wolfgang Handler）又在冯氏分类法基础上提出了基于硬件结构所含可并行处理单元数和可流水处理的级数的分类方法。</p><p>此外，还可以从对执行程序或指令的控制方式上，将计算机系统分为 <strong>有控制驱动的控制流方式</strong>，<strong>由数据驱动的数据流方式</strong>，<strong>按需求驱动的归约（Reduction）方式</strong>，以及 <strong>按模式驱动（Pattern Driven）的匹配（Matching）方式</strong> 等。</p>]]></content>
      
      
      <categories>
          
          <category> 计算机系统结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机系统结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>gRPC 三部曲之 -- gRPC</title>
      <link href="/2021/01/30/RPC/gRPC%20%E4%B8%89%E9%83%A8%E6%9B%B2%E4%B9%8B%20--%20gRPC/"/>
      <url>/2021/01/30/RPC/gRPC%20%E4%B8%89%E9%83%A8%E6%9B%B2%E4%B9%8B%20--%20gRPC/</url>
      
        <content type="html"><![CDATA[<p>gRPC 是一款由 Google 开发、语言中立、平台中立、开源的 RPC 系统。</p><p>与许多 RPC 系统类似，gRPC 也是基于以下理念：</p><ol><li>定义一个服务，指定其能够被远程调用的方法（包含参数和返回类型）；</li><li>在服务端实现这个接口，并运行一个 gRPC 服务器来处理客户端调用；</li><li>在客户端拥有一个存根能够像服务端一样的方法；</li></ol><p>gRPC 默认使用 Protocol Buffers，这是 Google 开源的一套成熟的结构数据序列化机制，当然也可以使用其他的数据格式。</p><p>gRPC 允许定义四类服务方法：</p><ol><li>单项 RPC：客户端发送一个请求给服务端，从服务端获取一个应答，就像一次普通的函数调用；</li><li>服务端流式 RPC：客户端发送一个请求给服务端，可获取一个数据流用来读取一系列消息，客户端从返回的数据流里一直读取知道没有更多消息为止；</li><li>客户端流式 RPC：客户端用提供的一个数据流写入并发送一系列消息给服务端，一旦客户端完成消息写入，就等待服务端读取这些消息并返回应答；</li><li>双向流式 RPC：两边都可以分别通过一个读写数据流来发送一系列消息。这两个数据流操作是相互独立的，所以客户端和服务端能按其希望的任意顺序读写；例如：服务端可以再写应答前等待所有的客户端消息，或者它可以先读一个消息再写一个消息，或者是读写消息相结合的其他方式。每个数据流里的消息的顺序都会被保持；</li></ol><p>学习一个框架最好的方式就是写一个例子，这样才能更好的理解框架。</p><p><strong>第一步：定义服务</strong></p><p>一个 RPC 服务通过参数和返回类型来指定可以远程调用方法，这里我们通过 Protocol Buffers 的 proto3 来实现。</p><figure class="highlight proto"><table><tr><td class="code"><pre><span class="line">syntax = <span class="string">&quot;proto3&quot;</span>; <span class="comment">// 协议版本</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">option</span> java_package = <span class="string">&quot;com.wd&quot;</span>; <span class="comment">// java 包名</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> com.wd; <span class="comment">// 文件包名</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义打招呼服务</span></span><br><span class="line"><span class="keyword">service </span><span class="title class_">Greeter</span> &#123;</span><br><span class="line">    <span class="comment">// 发送打招呼信息</span></span><br><span class="line">    <span class="function"><span class="keyword">rpc</span> SayHello (HelloRequest) <span class="keyword">returns</span> (HelloReplay)</span>&#123;&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 请求数据内容</span></span><br><span class="line"><span class="keyword">message </span><span class="title class_">HelloRequest</span> &#123;</span><br><span class="line">    <span class="type">string</span> name = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 响应数据内容</span></span><br><span class="line"><span class="keyword">message </span><span class="title class_">HelloReplay</span> &#123;</span><br><span class="line">    <span class="type">string</span> message = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>第二步：生成 gRPC 代码</strong></p><p>这里需要使用到 gRPC 插件和 protoc。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 客户端代码</span></span><br><span class="line"><span class="comment"> * A simple client that requests a greeting from the &#123;<span class="doctag">@link</span> HelloWorldServer&#125;.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloWorldClient</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Logger</span> <span class="variable">logger</span> <span class="operator">=</span> Logger.getLogger(HelloWorldClient.class.getName());</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> GreeterGrpc.GreeterBlockingStub blockingStub;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/** Construct client for accessing HelloWorld server using the existing channel. */</span></span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">HelloWorldClient</span><span class="params">(Channel channel)</span> &#123;</span><br><span class="line">    <span class="comment">// &#x27;channel&#x27; here is a Channel, not a ManagedChannel, so it is not this code&#x27;s responsibility to</span></span><br><span class="line">    <span class="comment">// shut it down.</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Passing Channels to code makes code easier to test and makes it easier to reuse Channels.</span></span><br><span class="line">    blockingStub = GreeterGrpc.newBlockingStub(channel);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/** Say hello to server. */</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">greet</span><span class="params">(String name)</span> &#123;</span><br><span class="line">    logger.info(<span class="string">&quot;Will try to greet &quot;</span> + name + <span class="string">&quot; ...&quot;</span>);</span><br><span class="line">    <span class="type">HelloRequest</span> <span class="variable">request</span> <span class="operator">=</span> HelloRequest.newBuilder().setName(name).build();</span><br><span class="line">    HelloReply response;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      response = blockingStub.sayHello(request);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (StatusRuntimeException e) &#123;</span><br><span class="line">      logger.log(Level.WARNING, <span class="string">&quot;RPC failed: &#123;0&#125;&quot;</span>, e.getStatus());</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    logger.info(<span class="string">&quot;Greeting: &quot;</span> + response.getMessage());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Greet server. If provided, the first element of &#123;<span class="doctag">@code</span> args&#125; is the name to use in the</span></span><br><span class="line"><span class="comment">   * greeting. The second argument is the target server.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">user</span> <span class="operator">=</span> <span class="string">&quot;world&quot;</span>;</span><br><span class="line">    <span class="comment">// Access a service running on the local machine on port 50051</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">target</span> <span class="operator">=</span> <span class="string">&quot;localhost:50051&quot;</span>;</span><br><span class="line">    <span class="comment">// Allow passing in the user and target strings as command line arguments</span></span><br><span class="line">    <span class="keyword">if</span> (args.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="string">&quot;--help&quot;</span>.equals(args[<span class="number">0</span>])) &#123;</span><br><span class="line">        System.err.println(<span class="string">&quot;Usage: [name [target]]&quot;</span>);</span><br><span class="line">        System.err.println(<span class="string">&quot;&quot;</span>);</span><br><span class="line">        System.err.println(<span class="string">&quot;  name    The name you wish to be greeted by. Defaults to &quot;</span> + user);</span><br><span class="line">        System.err.println(<span class="string">&quot;  target  The server to connect to. Defaults to &quot;</span> + target);</span><br><span class="line">        System.exit(<span class="number">1</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      user = args[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (args.length &gt; <span class="number">1</span>) &#123;</span><br><span class="line">      target = args[<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Create a communication channel to the server, known as a Channel. Channels are thread-safe</span></span><br><span class="line">    <span class="comment">// and reusable. It is common to create channels at the beginning of your application and reuse</span></span><br><span class="line">    <span class="comment">// them until the application shuts down.</span></span><br><span class="line">    <span class="type">ManagedChannel</span> <span class="variable">channel</span> <span class="operator">=</span> ManagedChannelBuilder.forTarget(target)</span><br><span class="line">        <span class="comment">// Channels are secure by default (via SSL/TLS). For the example we disable TLS to avoid</span></span><br><span class="line">        <span class="comment">// needing certificates.</span></span><br><span class="line">        .usePlaintext()</span><br><span class="line">        .build();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="type">HelloWorldClient</span> <span class="variable">client</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HelloWorldClient</span>(channel);</span><br><span class="line">      client.greet(user);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      <span class="comment">// ManagedChannels use resources like threads and TCP connections. To prevent leaking these</span></span><br><span class="line">      <span class="comment">// resources the channel should be shut down when it will no longer be used. If it may be used</span></span><br><span class="line">      <span class="comment">// again leave it running.</span></span><br><span class="line">      channel.shutdownNow().awaitTermination(<span class="number">5</span>, TimeUnit.SECONDS);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 服务端代码</span></span><br><span class="line"><span class="comment"> * Server that manages startup/shutdown of a &#123;<span class="doctag">@code</span> Greeter&#125; server.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloWorldServer</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Logger</span> <span class="variable">logger</span> <span class="operator">=</span> Logger.getLogger(HelloWorldServer.class.getName());</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> Server server;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">start</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="comment">/* The port on which the server should run */</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">port</span> <span class="operator">=</span> <span class="number">50051</span>;</span><br><span class="line">    server = ServerBuilder.forPort(port)</span><br><span class="line">        .addService(<span class="keyword">new</span> <span class="title class_">GreeterImpl</span>())</span><br><span class="line">        .build()</span><br><span class="line">        .start();</span><br><span class="line">    logger.info(<span class="string">&quot;Server started, listening on &quot;</span> + port);</span><br><span class="line">    Runtime.getRuntime().addShutdownHook(<span class="keyword">new</span> <span class="title class_">Thread</span>() &#123;</span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// Use stderr here since the logger may have been reset by its JVM shutdown hook.</span></span><br><span class="line">        System.err.println(<span class="string">&quot;*** shutting down gRPC server since JVM is shutting down&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          HelloWorldServer.<span class="built_in">this</span>.stop();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">          e.printStackTrace(System.err);</span><br><span class="line">        &#125;</span><br><span class="line">        System.err.println(<span class="string">&quot;*** server shut down&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">stop</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="keyword">if</span> (server != <span class="literal">null</span>) &#123;</span><br><span class="line">      server.shutdown().awaitTermination(<span class="number">30</span>, TimeUnit.SECONDS);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Await termination on the main thread since the grpc library uses daemon threads.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">blockUntilShutdown</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="keyword">if</span> (server != <span class="literal">null</span>) &#123;</span><br><span class="line">      server.awaitTermination();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Main launches the server from the command line.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, InterruptedException &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">HelloWorldServer</span> <span class="variable">server</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HelloWorldServer</span>();</span><br><span class="line">    server.start();</span><br><span class="line">    server.blockUntilShutdown();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">GreeterImpl</span> <span class="keyword">extends</span> <span class="title class_">GreeterGrpc</span>.GreeterImplBase &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sayHello</span><span class="params">(HelloRequest req, StreamObserver&lt;HelloReply&gt; responseObserver)</span> &#123;</span><br><span class="line">      <span class="type">HelloReply</span> <span class="variable">reply</span> <span class="operator">=</span> HelloReply.newBuilder().setMessage(<span class="string">&quot;Hello &quot;</span> + req.getName()).build();</span><br><span class="line">      responseObserver.onNext(reply);</span><br><span class="line">      responseObserver.onCompleted();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>第三步：创建服务器</strong></p><p>工作内容如下：</p><ol><li>实现服务定义的生成的服务接口；</li><li>运行一个 gRPC 服务器，监听来自客户端的请求并返回服务的响应；</li></ol><p><strong>第四步：启动服务器</strong></p><ol><li>创建服务实现类的一个实例并且将其传给其他生成的 Grpc 类的静态方法 bindService() 去获得服务定义；</li><li>使用生成器 forPort() 方法指定地址以及期望客户端请求监听的端口；</li><li>如果传入将 bindService() 返回的服务定义，用生成器注册服务实现到生成器的 addService() 方法；</li><li>调用生成器上的 build() 和 start() 方法为服务创建和启动一个 RPC 服务器；</li></ol><p><strong>第五步：创建客户端</strong></p><p>参考示例代码，创建客户实例。</p><p><strong>第六步：客户端与服务端通信</strong></p><ol><li>简单 RPC；</li><li>服务器流式 RPC；</li><li>客户端流式 RPC；</li><li>双向流式 RPC；</li></ol>]]></content>
      
      
      <categories>
          
          <category> RPC </category>
          
      </categories>
      
      
        <tags>
            
            <tag> gRPC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>gRPC 三部曲之 -- RPC</title>
      <link href="/2021/01/28/RPC/gRPC%20%E4%B8%89%E9%83%A8%E6%9B%B2%E4%B9%8B%20--%20RPC/"/>
      <url>/2021/01/28/RPC/gRPC%20%E4%B8%89%E9%83%A8%E6%9B%B2%E4%B9%8B%20--%20RPC/</url>
      
        <content type="html"><![CDATA[<p>RPC(Remote Procedure Call) 远程过程调用，是一个分布式系统间通信的必备技术。作为架构微服务化的基础组件，它能大大降低架构微服务化的成本，提高调用方与服务提供方的研发效率，屏蔽跨进程调用函数（服务）的各类复杂细节。让调用方感觉就像调用本地函数一样调用远端函数、让服务提供方感觉就像实现一个本地函数一样来实现服务。</p><h1 id="1-传输（Transport）"><a href="#1-传输（Transport）" class="headerlink" title="1. 传输（Transport）"></a>1. 传输（Transport）</h1><p>根据 RPC 名字来看，是为了调用远程函数（服务），既然是远程，当然逃脱不了 <strong>传输</strong> 了，如果没有 <strong>传输</strong>，那么又如何调用远程呢？所以，RPC 第一个关键词一定要想到 <strong>传输</strong>，<strong>传输</strong> 是 RPC 的基础。</p><p>既然作为基础，那么就一定要稳定、可靠，<strong>传输</strong> 并不是任意传输就可以的，而是需要 <em>可靠</em>，在 <em>可靠</em> 的前提下，后续其他的组件工作才有意义。</p><p>基于可靠、稳定的前提下，TCP 协议是首选，TCP 是面向连接的、全双工的、可靠的 <strong>传输协议</strong>。</p><p>TCP 就是可靠地把数据在不同的地址空间上搬运，例如在传统的阻塞 I&#x2F;O 模型中，当有数据过来的时候，操作系统内核把数据从 I&#x2F;O 中读出来存放在 kernal space，然后内核就通知 user space 可以拷贝走数据，用以腾出空间，让 TCP 滑动窗口向前移动，接收更多的数据。</p><h1 id="2-I-O-模型"><a href="#2-I-O-模型" class="headerlink" title="2. I&#x2F;O 模型"></a>2. I&#x2F;O 模型</h1><p>前面提到了 <strong>传输</strong>，传输就是通过 I&#x2F;O 流，那么高效、稳定的 I&#x2F;O 模型就是首选，I&#x2F;O 需要满足如下要求：</p><ol><li>服务端尽可能多的处理并发请求；</li><li>同时尽可能短的处理完毕；</li></ol><p>如果 I&#x2F;O 选择不好，就比如如果有线程或进程调用 I&#x2F;O 模型没有响应，CPU 只能选择挂起，线程或者进程也被阻塞住，浪费了 CPU 的性能。并且，频繁地挂起、唤醒切换，也会浪费系统资源。</p><p>如何协调 CPU 和 I&#x2F;O 呢？这里需要 Socket I&#x2F;O 做桥梁，协调二者。</p><p>RPC 框架可选择的 I&#x2F;O 模型有以下几种：</p><ol><li>Block I&#x2F;O</li><li>Non-Blocking I&#x2F;O</li><li>I&#x2F;O Multiplexing</li><li>Asynchronous I&#x2F;O</li><li>Signal Driven I&#x2F;O</li></ol><p>这里不对 I&#x2F;O 详细介绍，只是抛砖引玉，具体使用需要详细研究每一种模型。</p><p>这里，需要注意的是 <strong>同步 I&#x2F;O</strong> 和 <strong>异步 I&#x2F;O</strong>：</p><blockquote><p>同步 I&#x2F;O: 指用户线程发起 I&#x2F;O 请求后需要等待或轮询内核 I&#x2F;O 完成后再继续；</p><p>异步 I&#x2F;O: 指用户线程发起 I&#x2F;O 请求后直接退出，当内核 I&#x2F;O 操作完成后会通知用户线程来调用其回调函数；</p></blockquote><h1 id="3-进程、线程模型"><a href="#3-进程、线程模型" class="headerlink" title="3. 进程、线程模型"></a>3. 进程、线程模型</h1><p>基于 <strong>I&#x2F;O 模型</strong>，对信息进行处理，需要在进程、线程中进行，好的进程、线程模型也能极大的影响效率，好的模型能极大的提升 I&#x2F;O 性能。</p><p>业界早期很多实用的方案是：Blocking I&#x2F;O + ThreadPool 的方式实现的，比如 Tomcat&#x2F;Jetty 的默认配置就是这个方案，但是：</p><ol><li>I&#x2F;O 模型有可能会让工作线程卡在 I&#x2F;O 上；</li><li>线程的数量是有限制的，并不是线程可以无限量增加；</li><li>线程之间上下文切换很耗时，如果线程频繁的挂起、加载，会做很多无用功，并且浪费系统性能；</li></ol><p>所以，针对于 I&#x2F;O 阻塞，可以采用 <strong>异步 I&#x2F;O</strong>；针对于线程问题，可以考 <strong>虑多路复用</strong>。</p><h1 id="4-Schema-和序列化"><a href="#4-Schema-和序列化" class="headerlink" title="4. Schema 和序列化"></a>4. Schema 和序列化</h1><p>在前三步的配合下，传输假设完成，那么如何识别获取到的信息，也就是说发送方与接收方以何种方式交流呢？这里就使用到了 <strong>Schema</strong> 和 <strong>序列化</strong>。</p><p>通过反序列化，将二进制数据转换成程序可理解的对象，对象一般含有 Schema 或者结构，基于这些语义来做特定的业务逻辑处理。</p><p>一个序列化框架一般会关注以下几点：</p><ol><li>编码格式：是二进制呢，还是可读性高的格式；</li><li>契约声明：基于 IDL 的还是自描述的；</li><li>语言平台的中立性：不能局限于某种语言，要具有跨平台能力；</li><li>新老契约的兼容性：比如增加了一个字段，旧协议能否反序列化成功；</li><li>和压缩算法的契合度：结合压缩算法，能降低网络请求开销，加快响应速度；</li><li>性能：序列化与反序列化速度快慢、稳定性是关键指标，序列化的好坏影响 I&#x2F;O 的效率，进一步影响业务；</li></ol><p>常见的有 Protocol Buffers， Avro，Thrift，XML，JSON，MessagePack，Kyro，Hessian，Protostuff，Java Native Serialize，FST。如果对性能要求高，一般使用的较多的是 Protocol Buffers。</p><h1 id="5-协议结构"><a href="#5-协议结构" class="headerlink" title="5. 协议结构"></a>5. 协议结构</h1><p>TCP 是二进制的可靠搬运工，但是却不关心搬运的内容是什么，只是在一个通道上传输 message，通道中的 message 可能有很多很多条，那么如何确定哪些才是真正需要的 message，这就涉及到 message 识别，同时也要避免 <strong>粘包</strong> 和 <strong>半包</strong> 的问题，定义好协议结构后，才能正确的获取 message 并进行后续操作。</p><p>常用的方式有：</p><ol><li>分隔符：通过制定标识进行分割 message；</li><li>换行符：通过换行符 <code>/r/n</code> 进行区分；</li><li>固定长度：读取固定长度为一个完整的 message。RPC 常采用这种方式，使用 header + payload 的方式；</li></ol><p>HTTP 协议就是一种建立在 TCP 之上最广泛使用的 RPC，HTTP header 中就有 Content-Length 告知应用层如何正确读取一个 message。</p><h1 id="6-可靠性"><a href="#6-可靠性" class="headerlink" title="6. 可靠性"></a>6. 可靠性</h1><p>前面讲的是大概需要使用的技术所考虑的点，衡量一个框架是否能够应用到商业项目中，就跟 <strong>传输</strong> 一样，还需要考虑稳定性，谁也不希望项目三天两头出问题是吧。</p><p>除了技术使用方向的考虑外，还需要考虑心跳、断线恢复、重传、连接超时等等这些琐事，把琐事也处理好后，框架才能是一套可用、稳定的框架，才会有大批的人使用，让框架保持活力。</p><h1 id="7-易用性"><a href="#7-易用性" class="headerlink" title="7. 易用性"></a>7. 易用性</h1><p>框架所包含的信息基本上已经介绍了。试想一下，如果一个框架需要使用很多配置，代码接入等等，想用起来非常麻烦，会有多少人使用？</p><p>RPC 是需要让上层写业务逻辑来实现功能的，如何很方便的启停一个 server，注入 endpoint，客户端需要几步连接，重试调用，超时控制，版本升级后是否需要大改动等等，都决定了基于 RPC构建服务，甚至 SOA 的工程效率与生产率高低。</p>]]></content>
      
      
      <categories>
          
          <category> RPC </category>
          
      </categories>
      
      
        <tags>
            
            <tag> gRPC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>gRPC 三部曲之 -- 基础篇</title>
      <link href="/2021/01/26/RPC/gRPC%20%E4%B8%89%E9%83%A8%E6%9B%B2%E4%B9%8B%20--%20%E5%9F%BA%E7%A1%80%E7%AF%87/"/>
      <url>/2021/01/26/RPC/gRPC%20%E4%B8%89%E9%83%A8%E6%9B%B2%E4%B9%8B%20--%20%E5%9F%BA%E7%A1%80%E7%AF%87/</url>
      
        <content type="html"><![CDATA[<p>学习一种技术，首先要理解概念，然后进行实践，如果基础不打牢，后续的开发过程会举步维艰，项目也会如无根之萍，随着项目增大，倒塌的风险也会越来越大。</p><p>在介绍 <code>gRPC</code> 如何使用之前，先来认识一下，什么叫 <code>gRPC</code>：</p><blockquote><p>gRPC 是一个 <strong>高性能</strong>、<strong>开源</strong> 和 <strong>通用</strong> 的 <code>RPC</code> 框架，面向移动和 HTTP&#x2F;2 设计。</p></blockquote><p>这里面的关键词如下：</p><ol><li>高性能；</li><li>开源；</li><li>通用；</li><li>RPC；</li><li>移动；</li><li>HTTP&#x2F;2；</li></ol><p>其中 <code>高性能</code>、<code>RPC</code> 涉及到框架设计方案，会在后续中讲解，今天先讲讲基础。</p><h1 id="1-开源"><a href="#1-开源" class="headerlink" title="1. 开源"></a>1. 开源</h1><p>记住，<code>开源</code> 和 <code>免费</code> 是两码事：</p><blockquote><p><code>免费</code>：可以免费使用别人提供的服务，但是所有权、内部细节不一定可知，出问题后解决问题也很麻烦，如果别人不提供解决方案，岂不是凉凉？</p><p><code>开源</code>：可以下载源代码进行使用（还要注意开源协议），有了源代码后，可以做定制化开发，可以修复框架本身的问题，可以分析框架从而反哺更好的使用框架等等，总之，开源带来无限可能。</p></blockquote><h1 id="2-通用"><a href="#2-通用" class="headerlink" title="2. 通用"></a>2. 通用</h1><p>一个框架的受欢迎程度跟 <code>通用</code> 有很大的关系，如果只是局限于某一个细分领域，哪怕框架再好，由于受众面窄，也很难达到火爆的程度。<code>gRPC</code> 目前提供 C、Java 和 Go 语言版本，分别是：grpc、grpc-java、grpc-go。</p><p>当然，通用的也不是完美无缺的，比如：不符合当前业务场景怎么办？这里就是 <code>开源</code> 的意义所在了，在 <code>开源</code> 下可以定制化开发，从而满足业务场景需求。</p><h1 id="3-移动"><a href="#3-移动" class="headerlink" title="3. 移动"></a>3. 移动</h1><p>顾名思义，就是针对移动平台的进行优化的，适合于移动平台，在流量、电量等进行优化，降低由于卡顿、耗电量快等影响用户体验的问题。</p><blockquote><p>gRPC 基于 HTTP&#x2F;2 标准设计，带来诸如双向流、流控、头部压缩、单 TCP 链接上的多路复用请求等待。这些特性使得其在移动设备上表现更好，更省电和节省空间占用。</p></blockquote><h1 id="4-HTTP"><a href="#4-HTTP" class="headerlink" title="4. HTTP"></a>4. HTTP</h1><blockquote><p>超文本传输协议（HyperText Transfer Protocol， HTTP）是一个简单的请求-响应应用层协议，它通常运行在 TCP 之上。它指定了客户端可能发送给服务器什么样的消息以及得到什么样的响应。请求和响应消息的头以 ASCII 形式给出；而消息内容具有一个类似 MIME 的格式。</p></blockquote><h2 id="4-1-HTTP-0-9-及以前"><a href="#4-1-HTTP-0-9-及以前" class="headerlink" title="4.1 HTTP 0.9 及以前"></a>4.1 HTTP 0.9 及以前</h2><p>早期的 HTTP 协议功能很简单，直进行简单的文字传输，并且只提供了简单的 <strong>GET</strong> 的请求，服务器只能响应 HTML 格式的字符串。就是这么简单，朴实无华。</p><h2 id="4-2-HTTP-1-0"><a href="#4-2-HTTP-1-0" class="headerlink" title="4.2 HTTP 1.0"></a>4.2 HTTP 1.0</h2><p>随着 HTTP 推出之后，使用的用户越来越多，HTTP 协议也进行了升级。</p><p>相比于前面的版本，增加了 <strong>POST</strong>、<strong>HEAD</strong>，支持 <strong>cache</strong>，提供了更多的选择方式。同时，发送的内容也支持多种格式，为以后的文本、图像、音频、视频、二进制文件奠定了基础。</p><p>但是缺点也还不少：</p><ol><li>头部信息阻塞：消息队列中，如果某条消息因为某种原因造成阻塞，后面的消息也会被阻塞；</li><li>只支持短连接：比如一个界面需要加载 20 张图，由于不支持长链接，需要创建、回收 20 个 TCP&#x2F;IP 连接，性能存在极大的浪费，并且浏览器针对单个域名的连接是有数量限制的，导致加载时间过长；</li><li>带宽和延迟：在当网络不好的情况下，头部信息过多阻塞、连接无法复用，导致用户体验欠佳；</li></ol><h2 id="4-3-HTTP-1-1"><a href="#4-3-HTTP-1-1" class="headerlink" title="4.3 HTTP 1.1"></a>4.3 HTTP 1.1</h2><p>此版本解决了连接无法复用的诟病，是 HTTP 重要的一个版本。</p><p>HTTP 1.1 支持持久连接，在一个 TCP 连接上可以传送多个 HTTP 请求和响应，减少了建立和关闭连接的延迟和消耗。并且还允许客户端不用等待上一次请求结果返回，就可以发出下一次请求，但服务器端必须按照接收到客户端请求的先后顺序依次回送响应的结果，以保证客户端能够区分出每次请求的响应内容，这样也显著地减少了整个下载过程所需要的时间。</p><p>同时，新增了几种请求方式：<strong>PUT</strong>、<strong>DELETE</strong>、<strong>TRACE</strong>、<strong>CONNECT</strong>、<strong>OPTIONS</strong>。</p><h2 id="4-4-HTTP-2"><a href="#4-4-HTTP-2" class="headerlink" title="4.4 HTTP 2"></a>4.4 HTTP 2</h2><p>优点：</p><ol><li>多路复用技术：允许同时通过单一的 HTTP&#x2F;2 连接发起多重的请求-响应消息；</li><li>二进制分帧：在应用层和传输层之间增加了一个二进制分帧层，HTTP&#x2F;2 会将所有传输的信息分割为更小的消息和帧，并对它们采用二进制格式的编码；</li><li>首部压缩：SPDY 使用的是通用的 DEFLATE 算法，而 HTTP&#x2F;2 则使用了专门为首部压缩而设计的 HPACK 算法；</li><li>服务端推送：服务器可以对客户端的一个请求发送多个响应；</li></ol><p>缺点：</p><ol><li>TCP 以及 TCP + TLS 建立连接的时延：三次握手大概消耗 1~2 个 RTT；</li><li>TCP 的队头阻塞并没有彻底解决：TCP 为了保证可靠传输，有一个「超时重传」机制，丢失的包必须等待重传确认，整个 TCP 都要等待重传，会阻塞该 TCP 链接中的所有请求；</li><li>多路复用导致服务器压力上升：没有限制同时请求数，会有许多请求的短暂爆发，导致瞬时 QPS 暴增；</li><li>多路复用容易 Timeout：大批量的请求同时发送，由于贷款和服务器资源有限，可能存在排队时间过长的问题，有可能触发超时；</li></ol><h2 id="4-5-HTTP-3"><a href="#4-5-HTTP-3" class="headerlink" title="4.5 HTTP 3"></a>4.5 HTTP 3</h2><p>在 SPDY 推出以后，Google 已经意识到上述的问题，于是基于 UDP 协议推出了 QUIC 协议，而这个就是 HTTP 3。主要特点如下：</p><ol><li>改进的拥塞控制、可靠传输；</li><li>快速握手；</li><li>集成了 TLS 1.3 加密；</li><li>多路复用；</li><li>连接迁移；</li></ol><p>HTTP 协议很庞大，这里只做简单的介绍，如果有需要使用到某个具体版本，自行深入研究学习。</p><p><img src="https://pic2.zhimg.com/80/v2-042349861ba29fc613bd2364bb3f3881_1440w.jpg"></p>]]></content>
      
      
      <categories>
          
          <category> RPC </category>
          
      </categories>
      
      
        <tags>
            
            <tag> gRPC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法笔记 1~99</title>
      <link href="/2021/01/10/Algorithm/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0%201~99/"/>
      <url>/2021/01/10/Algorithm/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0%201~99/</url>
      
        <content type="html"><![CDATA[<h1 id="1-两数之和"><a href="#1-两数之和" class="headerlink" title="1. 两数之和"></a>1. 两数之和</h1><p>题目描述：</p><blockquote><p>给定一个整数数组 <code>nums</code> 和一个整数目标值 <code>target</code>，请你在该数组中找出 <strong>和为目标值</strong> 的那 <strong>两个</strong> 整数，并返回它们的数组下标。</p><p>你可以假设每种输入只会对应一个答案。但是，数组中同一个元素不能使用两遍。</p><p>你可以按任意顺序返回答案。</p><p>提示：<br>2 &lt;&#x3D; nums.length &lt;&#x3D; 103</p><p>-109 &lt;&#x3D; nums[i] &lt;&#x3D; 109</p><p>-109 &lt;&#x3D; target &lt;&#x3D; 109</p><p><strong>只会存在一个有效答案</strong></p></blockquote><p>解题思路一：</p><p>双重循环，时间复杂度为 T(n<sup>2</sup>)。</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 方式一</span></span><br><span class="line"><span class="comment"> * 冒泡方式</span></span><br><span class="line"><span class="comment"> * 时间复杂度 T(n²)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">twoSum1</span><span class="params">(num: <span class="type">IntArray</span>, target: <span class="type">Int</span>)</span></span>: IntArray &#123;</span><br><span class="line">    <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">0</span> until (num.size - <span class="number">1</span>)) &#123;</span><br><span class="line">        <span class="comment">// 从剩余的数据中查找能相加等于 target 的数，如果存在，则返回</span></span><br><span class="line">        <span class="keyword">for</span> (j <span class="keyword">in</span> (i + <span class="number">1</span>) until num.size) &#123;</span><br><span class="line">            <span class="keyword">if</span> (num[i] + num[j] == target) <span class="keyword">return</span> intArrayOf(i, j)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> intArrayOf(<span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// twoSum1 总计：测试次数 100000 次，耗时 515 ms, 内存开销：45.08 Mb</span></span><br></pre></td></tr></table></figure><p>解题思路二：</p><p>采用对已处理数据缓存的方式，可以降低时间复杂度，时间复杂度为 T(n)。</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 采用 Map 作为缓存的方式</span></span><br><span class="line"><span class="comment"> * 时间复杂度 T(n)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">twoSum2</span><span class="params">(nums: <span class="type">IntArray</span>, target: <span class="type">Int</span>)</span></span>: IntArray &#123;</span><br><span class="line">    <span class="keyword">val</span> paramMap = mutableMapOf&lt;<span class="built_in">Int</span>, <span class="built_in">Int</span>&gt;()</span><br><span class="line">    <span class="keyword">for</span> (i <span class="keyword">in</span> nums.indices) &#123;</span><br><span class="line">        <span class="keyword">val</span> diff = target - nums[i]</span><br><span class="line">        <span class="comment">// 如果数据匹配，则返回结果</span></span><br><span class="line">        <span class="keyword">if</span> (paramMap.containsKey(diff)) <span class="keyword">return</span> intArrayOf(paramMap[diff]!!, i)</span><br><span class="line">        <span class="comment">// 如果数据不匹配，则计入缓存中</span></span><br><span class="line">        paramMap[nums[i]] = i</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> intArrayOf(<span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// twoSum2 总计：测试次数 100000 次，耗时 86 ms, 内存开销：5.44 Mb</span></span><br></pre></td></tr></table></figure><h1 id="2-两数相加"><a href="#2-两数相加" class="headerlink" title="2. 两数相加"></a>2. 两数相加</h1><p>题目描述：</p><blockquote><p>给你两个 <strong>非空</strong> 的链表，表示两个非负的整数。它们每位数字都是按照 <strong>逆序</strong> 的方式存储的，并且每个节点只能存储 <strong>一位</strong> 数字。</p><p>请你将两个数相加，并以相同形式返回一个表示和的链表。</p><p>你可以假设除了数字 0 之外，这两个数都不会以 0 开头。</p></blockquote><p>解题思路一：</p><p>将数据转换为正常数字，然后相加，最后倒序加入链表中，时间复杂度为 T(n<sup>2</sup>)。</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 方式一</span></span><br><span class="line"><span class="comment"> * 转换成对应的整数再进行计算，然后逆序输出</span></span><br><span class="line"><span class="comment"> * 时间复杂度 T(n)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">addTwoNumbers1</span><span class="params">(l1: <span class="type">ListNode</span>?, l2: <span class="type">ListNode</span>?)</span></span>: ListNode? &#123;</span><br><span class="line">    <span class="keyword">val</span> str1 = l1.contentToString() <span class="comment">// l1 逆序</span></span><br><span class="line">    <span class="keyword">val</span> str2 = l2.contentToString() <span class="comment">// l2 逆序</span></span><br><span class="line">    <span class="keyword">val</span> num1 = <span class="keyword">if</span> (str1.isBlank()) <span class="number">0</span> <span class="keyword">else</span> str1.reversed().toInt() <span class="comment">// l1 真实数值</span></span><br><span class="line">    <span class="keyword">val</span> num2 = <span class="keyword">if</span> (str2.isBlank()) <span class="number">0</span> <span class="keyword">else</span> str2.reversed().toInt() <span class="comment">// l2 真是数值</span></span><br><span class="line">    <span class="keyword">val</span> result = (num1 + num2).toString().reversed() <span class="comment">// 求出结果并逆序</span></span><br><span class="line">    <span class="keyword">val</span> <span class="keyword">data</span> = IntArray(result.length)  <span class="comment">// 转换成数组</span></span><br><span class="line">    <span class="keyword">for</span> (i <span class="keyword">in</span> result.indices) <span class="keyword">data</span>[i] = result[i].toString().toInt()</span><br><span class="line">    <span class="keyword">return</span> getListNode(<span class="keyword">data</span>) <span class="comment">// 获取返回结果</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// addTwoNumbers1 总计：测试次数 100000 次，耗时 663 ms, 内存开销：5.13 Mb</span></span><br></pre></td></tr></table></figure><p>解题思路二：</p><p>将两个链表同步进行循环，相同位上的数据叠加，直到两个链表都到末尾为止，时间复杂度为 T(n)。</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 方式二</span></span><br><span class="line"><span class="comment"> * 按节点进位处理</span></span><br><span class="line"><span class="comment"> * 时间复杂度 T(n)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">addTwoNumbers2</span><span class="params">(l1: <span class="type">ListNode</span>?, l2: <span class="type">ListNode</span>?)</span></span>: ListNode? &#123;</span><br><span class="line">    <span class="keyword">var</span> node = ListNode(<span class="number">0</span>) <span class="comment">// 待返回数据</span></span><br><span class="line">    <span class="keyword">var</span> curr: ListNode? = node <span class="comment">// 待返回数据当前节点</span></span><br><span class="line">    <span class="keyword">var</span> currNode1 = l1 <span class="comment">// l1 当前节点</span></span><br><span class="line">    <span class="keyword">var</span> currNode2 = l2 <span class="comment">// l2 当前节点</span></span><br><span class="line">    <span class="keyword">var</span> carry = <span class="number">0</span> <span class="comment">// 进位值</span></span><br><span class="line">    <span class="keyword">while</span> (currNode1 != <span class="literal">null</span> || currNode2 != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">val</span> result = (currNode1?.`<span class="keyword">val</span>` ?: <span class="number">0</span>) + (currNode2?.`<span class="keyword">val</span>` ?: <span class="number">0</span>) + carry</span><br><span class="line">        carry = result / <span class="number">10</span></span><br><span class="line">        curr?.next = ListNode(result % <span class="number">10</span>)</span><br><span class="line">        curr = curr?.next</span><br><span class="line">        <span class="keyword">if</span> (currNode1 != <span class="literal">null</span>) currNode1 = currNode1?.next</span><br><span class="line">        <span class="keyword">if</span> (currNode2 != <span class="literal">null</span>) currNode2 = currNode2?.next</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (carry == <span class="number">1</span>) curr?.next = ListNode(carry) <span class="comment">// 虽然测试结束，如果有进位，需要增加一个节点</span></span><br><span class="line">    <span class="keyword">return</span> node.next</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// addTwoNumbers2 总计：测试次数 100000 次，耗时 58 ms, 内存开销：28.07 Mb</span></span><br></pre></td></tr></table></figure><h1 id="3-无重复字符的最长子串"><a href="#3-无重复字符的最长子串" class="headerlink" title="3. 无重复字符的最长子串"></a>3. 无重复字符的最长子串</h1><p>题目描述：</p><blockquote><p>给定一个字符串，请你找出其中不含有重复字符的 最长子串 的长度。</p></blockquote><p>解题思路一：</p><p>逐个生产子字符串，看看是否含有重复的字符，时间复杂度为 T(n<sup>2</sup>)。</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 方式一：暴力解法</span></span><br><span class="line"><span class="comment"> * 逐个生产子字符串，看看是否含有重复的字符</span></span><br><span class="line"><span class="comment"> * 时间复杂度 T(n²)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">lengthOfLongestSubstring1</span><span class="params">(s: <span class="type">String</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> endIndex = <span class="number">0</span></span><br><span class="line">    <span class="keyword">var</span> maxLength = <span class="number">0</span></span><br><span class="line">    <span class="keyword">val</span> <span class="keyword">data</span> = s.toCharArray()</span><br><span class="line">    <span class="keyword">val</span> <span class="keyword">set</span> = HashSet&lt;<span class="built_in">Int</span>&gt;(<span class="keyword">data</span>.size)</span><br><span class="line">    <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="keyword">data</span>.indices) &#123;</span><br><span class="line">        endIndex = i</span><br><span class="line">        <span class="keyword">set</span>.clear()</span><br><span class="line">        <span class="keyword">set</span>.add(<span class="keyword">data</span>[i].toInt())</span><br><span class="line">        <span class="keyword">if</span> (i == <span class="keyword">data</span>.size - <span class="number">1</span>) endIndex++</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">for</span> (j <span class="keyword">in</span> (i + <span class="number">1</span>) until <span class="keyword">data</span>.size) &#123;</span><br><span class="line">            endIndex = j</span><br><span class="line">            <span class="keyword">val</span> index = <span class="keyword">data</span>[j].toInt()</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">set</span>.contains(index)) <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">set</span>.add(index)</span><br><span class="line">            <span class="keyword">if</span> (j == s.length - <span class="number">1</span>) endIndex++</span><br><span class="line">        &#125;</span><br><span class="line">        maxLength = maxLength.coerceAtLeast(endIndex - i)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> maxLength</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// lengthOfLongestSubstring1 总计：测试次数 100000 次，耗时 450 ms, 内存开销：35.88 Mb</span></span><br></pre></td></tr></table></figure><p>解题思路二：</p><p>向右递增，如果发现重复，则移动起始点下标，并记录当前长度，时间复杂度 T(n)。</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 方式二：滑动窗口及优化</span></span><br><span class="line"><span class="comment"> * 向右递增，如果发现重复，则移动起始点下标，并记录当前长度</span></span><br><span class="line"><span class="comment"> * 时间复杂度 T(n)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">lengthOfLongestSubstring2</span><span class="params">(s: <span class="type">String</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> startIndex = <span class="number">0</span></span><br><span class="line">    <span class="keyword">var</span> maxLength = <span class="number">0</span></span><br><span class="line">    <span class="keyword">val</span> <span class="keyword">data</span> = s.toCharArray()</span><br><span class="line">    <span class="keyword">val</span> map = HashMap&lt;<span class="built_in">Int</span>, <span class="built_in">Int</span>&gt;(<span class="keyword">data</span>.size)</span><br><span class="line">    <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="keyword">data</span>.indices) &#123;</span><br><span class="line">        <span class="keyword">val</span> index = <span class="keyword">data</span>[i].toInt()</span><br><span class="line">        <span class="keyword">if</span> (map.containsKey(index) &amp;&amp; map[index]!! &gt;= startIndex) &#123;</span><br><span class="line">            maxLength = maxLength.coerceAtLeast(i - startIndex)</span><br><span class="line">            startIndex = map[index]!! + <span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line">        map[index] = i</span><br><span class="line">        <span class="keyword">if</span> (i == s.length - <span class="number">1</span>) maxLength = maxLength.coerceAtLeast(i + <span class="number">1</span> - startIndex)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> maxLength</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// lengthOfLongestSubstring2 总计：测试次数 100000 次，耗时 46 ms, 内存开销：32.31 Mb</span></span><br></pre></td></tr></table></figure><h1 id="4-寻找两个正序数组的中位数"><a href="#4-寻找两个正序数组的中位数" class="headerlink" title="4. 寻找两个正序数组的中位数"></a>4. 寻找两个正序数组的中位数</h1><p>题目描述：</p><blockquote><p>给定两个大小为 m 和 n 的正序（从小到大）数组 <code>nums1</code> 和 <code>nums2</code>。请你找出并返回这两个正序数组的中位数。</p><p>进阶：你能设计一个时间复杂度为 <code>O(log (m+n))</code> 的算法解决此问题吗？</p></blockquote><p>解题思路一：</p><p>两个数组合并成新数组，然后爬子虚，最后在新数组中查询中位数，时间复杂度为 T(n<sup>2</sup>)。</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 方式一：暴力解法</span></span><br><span class="line"><span class="comment"> * 将 2 个数组合并，然后取中位数</span></span><br><span class="line"><span class="comment"> * 时间复杂度 T(m + n)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">findMedianSortedArrays1</span><span class="params">(nums1: <span class="type">IntArray</span>, nums2: <span class="type">IntArray</span>)</span></span>: <span class="built_in">Double</span> &#123;</span><br><span class="line">    <span class="keyword">val</span> nums = nums1.plus(nums2)</span><br><span class="line">    nums.sort()</span><br><span class="line">    <span class="keyword">val</span> index = nums.size / <span class="number">2</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">when</span> &#123;</span><br><span class="line">        nums.size % <span class="number">2</span> != <span class="number">0</span> -&gt; nums[index].toDouble()</span><br><span class="line">        <span class="keyword">else</span> -&gt; (nums[index - <span class="number">1</span>] + nums[index]) / <span class="number">2.0</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// findMedianSortedArrays1 总计：测试次数 100000 次，耗时 544 ms, 内存开销：48.92 Mb</span></span><br></pre></td></tr></table></figure><p>解题思路二：</p><p>已知条件：</p><ol><li>数组升序排列；</li><li>求中位数，中位数既不是最大值，也不是最小值，循环到中间位置即可；</li></ol><p>解：需要求两个数组中位数，那么中位数的位置基本上就是数组长度之和的中位数，并且区分奇偶情况，那么可以从 2 个数组同时进发，当数组 1 和数组 2 下标和为中位数下标时，就可以退出循环了，T(min(m, n))。</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 方式二：二分查找</span></span><br><span class="line"><span class="comment"> * 通过二分查找找出分割位置，然后比较左上、右下 和 左下、右上数据信息，符合条件即为对接点</span></span><br><span class="line"><span class="comment"> * 时间复杂度 T(min(m, n))</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">findMedianSortedArrays2</span><span class="params">(nums1: <span class="type">IntArray</span>, nums2: <span class="type">IntArray</span>)</span></span>: <span class="built_in">Double</span> &#123;</span><br><span class="line">    <span class="keyword">val</span> totalNum = nums1.size + nums2.size</span><br><span class="line">    <span class="keyword">val</span> isEven = totalNum % <span class="number">2</span> == <span class="number">0</span></span><br><span class="line">    <span class="keyword">val</span> halfIndex = totalNum / <span class="number">2</span></span><br><span class="line">    <span class="keyword">var</span> index = <span class="number">0</span></span><br><span class="line">    <span class="keyword">var</span> left = <span class="number">0</span></span><br><span class="line">    <span class="keyword">var</span> right = <span class="number">0</span></span><br><span class="line">    <span class="keyword">var</span> middle = <span class="number">0.0</span></span><br><span class="line">    <span class="keyword">while</span> (left &lt; nums1.size || right &lt; nums2.size) &#123;</span><br><span class="line">        <span class="keyword">val</span> value = <span class="keyword">when</span> &#123;</span><br><span class="line">            left &gt;= nums1.size -&gt; nums2[right++]</span><br><span class="line">            right &gt;= nums2.size -&gt; nums1[left++]</span><br><span class="line">            nums1[left] &gt; nums2[right] -&gt; nums2[right++]</span><br><span class="line">            <span class="keyword">else</span> -&gt; nums1[left++]</span><br><span class="line">        &#125;.toDouble()</span><br><span class="line">        <span class="keyword">if</span> (index == halfIndex) &#123;</span><br><span class="line">            middle = <span class="keyword">if</span> (isEven) (middle + value) / <span class="number">2</span> <span class="keyword">else</span> value</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125; <span class="keyword">else</span> middle = value</span><br><span class="line">        index++</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> middle</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// findMedianSortedArrays2 总计：测试次数 100000 次，耗时 39 ms, 内存开销：9.37 Mb</span></span><br></pre></td></tr></table></figure><h1 id="5-最长回文子串"><a href="#5-最长回文子串" class="headerlink" title="5. 最长回文子串"></a>5. 最长回文子串</h1><p>题目描述：</p><blockquote><p>给你一个字符串 <code>s</code>，找到 <code>s</code> 中最长的回文子串。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> Kotlin </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>垃圾回收</title>
      <link href="/2021/01/06/Java/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/"/>
      <url>/2021/01/06/Java/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/</url>
      
        <content type="html"><![CDATA[<p>作为一门优秀的开发语言，Java 除了 <strong>安全性</strong>、<strong>跨平台&#x2F;可移植性</strong>、<strong>动态性</strong>、<strong>高性能</strong>、<strong>多线程</strong> 等优点外，不得不提的还有 <strong>垃圾回收机制（GC）</strong>，好的 <strong>垃圾回收机制（GC）</strong> 能让开发人员更加专注于业务的开发，大幅提升开发效率。</p><h1 id="1-垃圾回收，回收的到底是什么？"><a href="#1-垃圾回收，回收的到底是什么？" class="headerlink" title="1. 垃圾回收，回收的到底是什么？"></a>1. 垃圾回收，回收的到底是什么？</h1><p>进入正题之前，首先要了解需要回收的内容是什么，如果连待回收对象都不清楚，那么也就无法实现 <code>垃圾回收</code> 了。</p><p>众所周知，Java 是一门优秀的面向对象语言，<strong>创建对象</strong> 是绕不开的话题，可是每个 <strong>对象</strong> 的生命周期不同，在对象不会再次被使用的情况下，会对其进行回收，从而减少内存开销，这就是传说中的 <code>垃圾回收</code>。</p><p>简单来讲，<code>垃圾回收</code> 回收的就是那些不会再被使用到的对象。</p><p>先来一波简单的 GC 示例代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br></pre></td></tr></table></figure><p><strong>&#x2F;&#x2F; 未完待续</strong></p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
            <tag> Java </tag>
            
            <tag> GC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>从字节码分析 i++ 与 ++i 的区别</title>
      <link href="/2021/01/04/Java/%E4%BB%8E%E5%AD%97%E8%8A%82%E7%A0%81%E5%88%86%E6%9E%90%20i++%20%E4%B8%8E%20++i%20%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
      <url>/2021/01/04/Java/%E4%BB%8E%E5%AD%97%E8%8A%82%E7%A0%81%E5%88%86%E6%9E%90%20i++%20%E4%B8%8E%20++i%20%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
      
        <content type="html"><![CDATA[<p>初学编程时，i++ 与 ++i 经常搞错，哪怕是在工作多年后，也只是知道 ++i 是先自增运算赋值再进行操作，i++ 是先进行操作，然后再进行自增运算赋值，只能说是知其然，却不知其所以然，作为研究 JVM 第一站，先剖析一下这个经典的问题。</p><p>首先，先列出今天的测试代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 从字节码层面分析 i++ 和 ++i 为什么不同</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AnalyseBytecode</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> i++;</span><br><span class="line">        System.out.println(<span class="string">&quot;num: &quot;</span> + num);</span><br><span class="line">        num = ++i;</span><br><span class="line">        System.out.println(<span class="string">&quot;num: &quot;</span> + num);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码很简单，就不过多介绍了。</p><p>其次，执行 <code>javac -g:vars 具体文件路径/AnalyseBytecode .java</code> 将 java 文件编译成 class 文件。</p><p><strong>注意，<span style="color:red">-g:vars</span> 一定要加上，要不然 LocalVariableTable 不会出现。</strong></p><p>然后，通过执行 <code>javap -v 文件路径/AnalyseBytecode.class &gt; 指定路径/AnalyseBytecode.txt</code> 实现反汇编，就可以进入正题了。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Classfile ~/AnalyseBytecode.<span class="keyword">class</span></span><br><span class="line">  <span class="title class_">Last</span> modified <span class="number">2021</span>-<span class="number">1</span>-<span class="number">5</span>; size <span class="number">752</span> bytes</span><br><span class="line">  MD5 checksum 06e2e2dd5a25824e2d4033df5539f693</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">com</span>.wd.clazz.AnalyseBytecode</span><br><span class="line">  minor version: <span class="number">0</span></span><br><span class="line">  major version: <span class="number">52</span></span><br><span class="line">  flags: ACC_PUBLIC, ACC_SUPER</span><br><span class="line">Constant pool:</span><br><span class="line">   #<span class="number">1</span> = Methodref          #<span class="number">11.</span>#<span class="number">25</span>        <span class="comment">// java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span></span><br><span class="line">   #<span class="number">2</span> = Fieldref           #<span class="number">26.</span>#<span class="number">27</span>        <span class="comment">// java/lang/System.out:Ljava/io/PrintStream;</span></span><br><span class="line">   #<span class="number">3</span> = Class              #<span class="number">28</span>            <span class="comment">// java/lang/StringBuilder</span></span><br><span class="line">   #<span class="number">4</span> = Methodref          #<span class="number">3.</span>#<span class="number">25</span>         <span class="comment">// java/lang/StringBuilder.&quot;&lt;init&gt;&quot;:()V</span></span><br><span class="line">   #<span class="number">5</span> = String             #<span class="number">29</span>            <span class="comment">// num:</span></span><br><span class="line">   #<span class="number">6</span> = Methodref          #<span class="number">3.</span>#<span class="number">30</span>         <span class="comment">// java/lang/StringBuilder.append:(Ljava/lang/String;)Ljava/lang/StringBuilder;</span></span><br><span class="line">   #<span class="number">7</span> = Methodref          #<span class="number">3.</span>#<span class="number">31</span>         <span class="comment">// java/lang/StringBuilder.append:(I)Ljava/lang/StringBuilder;</span></span><br><span class="line">   #<span class="number">8</span> = Methodref          #<span class="number">3.</span>#<span class="number">32</span>         <span class="comment">// java/lang/StringBuilder.toString:()Ljava/lang/String;</span></span><br><span class="line">   #<span class="number">9</span> = Methodref          #<span class="number">33.</span>#<span class="number">34</span>        <span class="comment">// java/io/PrintStream.println:(Ljava/lang/String;)V</span></span><br><span class="line">  #<span class="number">10</span> = Class              #<span class="number">35</span>            <span class="comment">// com/wd/clazz/AnalyseBytecode</span></span><br><span class="line">  #<span class="number">11</span> = Class              #<span class="number">36</span>            <span class="comment">// java/lang/Object</span></span><br><span class="line">  #<span class="number">12</span> = Utf8               &lt;init&gt;</span><br><span class="line">  #<span class="number">13</span> = Utf8               ()V</span><br><span class="line">  #<span class="number">14</span> = Utf8               Code</span><br><span class="line">  #<span class="number">15</span> = Utf8               LocalVariableTable</span><br><span class="line">  #<span class="number">16</span> = Utf8               <span class="built_in">this</span></span><br><span class="line">  #<span class="number">17</span> = Utf8               Lcom/wd/clazz/AnalyseBytecode;</span><br><span class="line">  #<span class="number">18</span> = Utf8               main</span><br><span class="line">  #<span class="number">19</span> = Utf8               ([Ljava/lang/String;)V</span><br><span class="line">  #<span class="number">20</span> = Utf8               args</span><br><span class="line">  #<span class="number">21</span> = Utf8               [Ljava/lang/String;</span><br><span class="line">  #<span class="number">22</span> = Utf8               i</span><br><span class="line">  #<span class="number">23</span> = Utf8               I</span><br><span class="line">  #<span class="number">24</span> = Utf8               num</span><br><span class="line">  #<span class="number">25</span> = NameAndType        #<span class="number">12</span>:#<span class="number">13</span>        <span class="comment">// &quot;&lt;init&gt;&quot;:()V</span></span><br><span class="line">  #<span class="number">26</span> = Class              #<span class="number">37</span>            <span class="comment">// java/lang/System</span></span><br><span class="line">  #<span class="number">27</span> = NameAndType        #<span class="number">38</span>:#<span class="number">39</span>        <span class="comment">// out:Ljava/io/PrintStream;</span></span><br><span class="line">  #<span class="number">28</span> = Utf8               java/lang/StringBuilder</span><br><span class="line">  #<span class="number">29</span> = Utf8               num:</span><br><span class="line">  #<span class="number">30</span> = NameAndType        #<span class="number">40</span>:#<span class="number">41</span>        <span class="comment">// append:(Ljava/lang/String;)Ljava/lang/StringBuilder;</span></span><br><span class="line">  #<span class="number">31</span> = NameAndType        #<span class="number">40</span>:#<span class="number">42</span>        <span class="comment">// append:(I)Ljava/lang/StringBuilder;</span></span><br><span class="line">  #<span class="number">32</span> = NameAndType        #<span class="number">43</span>:#<span class="number">44</span>        <span class="comment">// toString:()Ljava/lang/String;</span></span><br><span class="line">  #<span class="number">33</span> = Class              #<span class="number">45</span>            <span class="comment">// java/io/PrintStream</span></span><br><span class="line">  #<span class="number">34</span> = NameAndType        #<span class="number">46</span>:#<span class="number">47</span>        <span class="comment">// println:(Ljava/lang/String;)V</span></span><br><span class="line">  #<span class="number">35</span> = Utf8               com/wd/clazz/AnalyseBytecode</span><br><span class="line">  #<span class="number">36</span> = Utf8               java/lang/Object</span><br><span class="line">  #<span class="number">37</span> = Utf8               java/lang/System</span><br><span class="line">  #<span class="number">38</span> = Utf8               out</span><br><span class="line">  #<span class="number">39</span> = Utf8               Ljava/io/PrintStream;</span><br><span class="line">  #<span class="number">40</span> = Utf8               append</span><br><span class="line">  #<span class="number">41</span> = Utf8               (Ljava/lang/String;)Ljava/lang/StringBuilder;</span><br><span class="line">  #<span class="number">42</span> = Utf8               (I)Ljava/lang/StringBuilder;</span><br><span class="line">  #<span class="number">43</span> = Utf8               toString</span><br><span class="line">  #<span class="number">44</span> = Utf8               ()Ljava/lang/String;</span><br><span class="line">  #<span class="number">45</span> = Utf8               java/io/PrintStream</span><br><span class="line">  #<span class="number">46</span> = Utf8               println</span><br><span class="line">  #<span class="number">47</span> = Utf8               (Ljava/lang/String;)V</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">public</span> com.wd.clazz.AnalyseBytecode();</span><br><span class="line">    descriptor: ()V</span><br><span class="line">    flags: ACC_PUBLIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=<span class="number">1</span>, locals=<span class="number">1</span>, args_size=<span class="number">1</span></span><br><span class="line">         <span class="number">0</span>: aload_0</span><br><span class="line">         <span class="number">1</span>: invokespecial #<span class="number">1</span>                  <span class="comment">// Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span></span><br><span class="line">         <span class="number">4</span>: <span class="keyword">return</span></span><br><span class="line">      LocalVariableTable:</span><br><span class="line">        Start  Length  Slot  Name   Signature</span><br><span class="line">            <span class="number">0</span>       <span class="number">5</span>     <span class="number">0</span>  <span class="built_in">this</span>   Lcom/wd/clazz/AnalyseBytecode;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(java.lang.String[])</span>;</span><br><span class="line">    descriptor: ([Ljava/lang/String;)V</span><br><span class="line">    flags: ACC_PUBLIC, ACC_STATIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=<span class="number">3</span>, locals=<span class="number">3</span>, args_size=<span class="number">1</span></span><br><span class="line">         <span class="number">0</span>: iconst_0</span><br><span class="line">         <span class="number">1</span>: istore_1</span><br><span class="line">         <span class="number">2</span>: iload_1</span><br><span class="line">         <span class="number">3</span>: iinc          <span class="number">1</span>, <span class="number">1</span></span><br><span class="line">         <span class="number">6</span>: istore_2</span><br><span class="line">         <span class="number">7</span>: getstatic     #<span class="number">2</span>                  <span class="comment">// Field java/lang/System.out:Ljava/io/PrintStream;</span></span><br><span class="line">        <span class="number">10</span>: <span class="keyword">new</span>           #<span class="number">3</span>                  <span class="comment">// class java/lang/StringBuilder</span></span><br><span class="line">        <span class="number">13</span>: dup</span><br><span class="line">        <span class="number">14</span>: invokespecial #<span class="number">4</span>                  <span class="comment">// Method java/lang/StringBuilder.&quot;&lt;init&gt;&quot;:()V</span></span><br><span class="line">        <span class="number">17</span>: ldc           #<span class="number">5</span>                  <span class="comment">// String num:</span></span><br><span class="line">        <span class="number">19</span>: invokevirtual #<span class="number">6</span>                  <span class="comment">// Method java/lang/StringBuilder.append:(Ljava/lang/String;)Ljava/lang/StringBuilder;</span></span><br><span class="line">        <span class="number">22</span>: iload_2</span><br><span class="line">        <span class="number">23</span>: invokevirtual #<span class="number">7</span>                  <span class="comment">// Method java/lang/StringBuilder.append:(I)Ljava/lang/StringBuilder;</span></span><br><span class="line">        <span class="number">26</span>: invokevirtual #<span class="number">8</span>                  <span class="comment">// Method java/lang/StringBuilder.toString:()Ljava/lang/String;</span></span><br><span class="line">        <span class="number">29</span>: invokevirtual #<span class="number">9</span>                  <span class="comment">// Method java/io/PrintStream.println:(Ljava/lang/String;)V</span></span><br><span class="line">        <span class="number">32</span>: iinc          <span class="number">1</span>, <span class="number">1</span></span><br><span class="line">        <span class="number">35</span>: iload_1</span><br><span class="line">        <span class="number">36</span>: istore_2</span><br><span class="line">        <span class="number">37</span>: getstatic     #<span class="number">2</span>                  <span class="comment">// Field java/lang/System.out:Ljava/io/PrintStream;</span></span><br><span class="line">        <span class="number">40</span>: <span class="keyword">new</span>           #<span class="number">3</span>                  <span class="comment">// class java/lang/StringBuilder</span></span><br><span class="line">        <span class="number">43</span>: dup</span><br><span class="line">        <span class="number">44</span>: invokespecial #<span class="number">4</span>                  <span class="comment">// Method java/lang/StringBuilder.&quot;&lt;init&gt;&quot;:()V</span></span><br><span class="line">        <span class="number">47</span>: ldc           #<span class="number">5</span>                  <span class="comment">// String num:</span></span><br><span class="line">        <span class="number">49</span>: invokevirtual #<span class="number">6</span>                  <span class="comment">// Method java/lang/StringBuilder.append:(Ljava/lang/String;)Ljava/lang/StringBuilder;</span></span><br><span class="line">        <span class="number">52</span>: iload_2</span><br><span class="line">        <span class="number">53</span>: invokevirtual #<span class="number">7</span>                  <span class="comment">// Method java/lang/StringBuilder.append:(I)Ljava/lang/StringBuilder;</span></span><br><span class="line">        <span class="number">56</span>: invokevirtual #<span class="number">8</span>                  <span class="comment">// Method java/lang/StringBuilder.toString:()Ljava/lang/String;</span></span><br><span class="line">        <span class="number">59</span>: invokevirtual #<span class="number">9</span>                  <span class="comment">// Method java/io/PrintStream.println:(Ljava/lang/String;)V</span></span><br><span class="line">        <span class="number">62</span>: <span class="keyword">return</span></span><br><span class="line">      LocalVariableTable:</span><br><span class="line">        Start  Length  Slot  Name   Signature</span><br><span class="line">            <span class="number">0</span>      <span class="number">63</span>     <span class="number">0</span>  args   [Ljava/lang/String;</span><br><span class="line">            <span class="number">2</span>      <span class="number">61</span>     <span class="number">1</span>     i   I</span><br><span class="line">            <span class="number">7</span>      <span class="number">56</span>     <span class="number">2</span>   num   I</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>先看第一部分关键代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">0</span>: iconst_0 <span class="comment">// 将 0 压入栈中</span></span><br><span class="line"><span class="number">1</span>: istore_1 <span class="comment">// 将栈顶的值放入变量 1 中并出栈，从 LocalVariableTable 中查询，变量 1 为 i</span></span><br><span class="line"><span class="number">2</span>: iload_1 <span class="comment">// 将变量 1 放入栈顶</span></span><br><span class="line"><span class="number">3</span>: iinc          <span class="number">1</span>, <span class="number">1</span> <span class="comment">// 将变量 1 的值加 1</span></span><br><span class="line"><span class="number">6</span>: istore_2 <span class="comment">// 将栈顶的值放入变量 2 中并出栈，从 LocalVariableTable 中查询，变量 2 为 num</span></span><br></pre></td></tr></table></figure><p>敲黑板，关键点解析，<strong>3: iinc</strong> 这一步虽然将 i 值递增了，但是并没有将递增后的结果重新入栈，所以此时栈顶的值还是旧值 0，<strong>6: istore_2</strong> 又将栈顶的值赋值给变量 2 ，此时的值还是变量 1 未被重新赋值时的数值，所以此时 num 为 0。</p><p>再看第二部分：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">32</span>: iinc          <span class="number">1</span>, <span class="number">1</span> <span class="comment">// 变量 1 递增 1</span></span><br><span class="line"><span class="number">35</span>: iload_1 <span class="comment">// 变量 1 入栈</span></span><br><span class="line"><span class="number">36</span>: istore_2 <span class="comment">// 将栈顶的值赋值给变量 2 并出栈</span></span><br></pre></td></tr></table></figure><p>这里 num 的值就是 i 递增后的值。</p><p>总结：i++ 操作，先入栈，再递增，此时栈中的值还是旧值；++i 操作，先递增，再入栈，此时栈中的值是最新值。<strong>iload_</strong> 和 <strong>iinc</strong> 的顺序导致了结果的不同。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
            <tag> Java </tag>
            
            <tag> Bytecode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>多线程</title>
      <link href="/2020/12/30/Java/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
      <url>/2020/12/30/Java/%E5%A4%9A%E7%BA%BF%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<p>在开发过程中，遇到 IO 操作、网络请求等耗时操作，通常都会放到子线程中去处理，如果有多个操作，就涉及到了 <strong>多线程</strong>，现在就来扒一扒 <strong>多线程</strong>，然后基于扒皮之后的结果，进行线程优化。</p><p>在进入正题之前，先介绍一下基础概念，不仅要知其然，还要知其所以然。</p><h1 id="1-基础概念"><a href="#1-基础概念" class="headerlink" title="1. 基础概念"></a>1. 基础概念</h1><blockquote><p><code>时钟频率</code>：时钟频率（又译：时钟频率速度，英语：clock rate），是指同步电路中时钟的基础频率，它以「若干次周期每秒」来度量，量度单位采用 SI 单位赫兹（Hz）。</p><p><code>主频</code>：主频即 CPU 的时钟频率，计算机的操作在时钟信号的控制下分步执行，每个时钟信号周期完成一步操作，时钟频率的高低在很大程度上反映了 CPU 速度的快慢。</p><p><code>外频</code>：是 CPU 外部的工作频率，是由主板提供的基准时钟频率。</p><p><code>FSB 频率</code>：是连接 CPU 和主板芯片组中的北桥芯片的前端总线（Front Side Bus）上的数据传输频率。</p><p>CPU 的主频和外频间存在这样的关系：主频 &#x3D; 外频 × 倍频。</p><p><code>进程</code>：进程（Process）是计算机中的程序关于某数据集合上的一次运行活动，是系统进行资源分配和调度的基本单位，是操作系统结构的基础。</p><p><code>线程</code>：线程（英语：thread）是操作系统能够进行运算调度的最小单位。</p><p><code>并发</code>：在同一个时间段内，两个或多个程序执行，有时间上的重叠（宏观上是同时，微观上仍是顺序执行）。</p><p><code>并行</code>：一组程序按独立异步的速度执行，不等于时间上的重叠（同一个时刻发生)。</p></blockquote><p>从理论上来讲，<strong>主频</strong> 越高，CPU 运算能力越强，再根据 <code>摩尔定律</code> 来看，每过 18 个月计算机性能就会翻一倍，那么岂不是只管提升 <strong>主频</strong> 就行了，还有 <strong>多线程</strong> 什么事情啊。</p><p>其实不然，到目前的发展状况来看，由于CPU是在半导体硅片上制造的，在硅片上的元件之间需要导线进行联接，由于在高频状态下要求导线越细越短越好，这样才能减小导线分布电容等杂散干扰以保证 CPU 运算正确。因此制造工艺的限制，是 CPU 主频发展的最大障碍之一。</p><p>举个栗子就明白了。以前的绿皮火车特别特别慢，导致在一个时间周期内，只能跑一次运输，相当于早期的 CPU；后来，列车速度不断提升，有了快车；再后来，有了动车；现在，有了高铁和复兴号。在同一个时间周期内，绿皮火车只能完成一次运输，复兴号却可以完成 4~5 次运输（相当于主频提升），效率大大提升。可是当达到一定的速度后，再想提升速度就很难了。</p><p>那么…性能提升发展到此停止了吗？</p><p>不存在的，既然 <strong>主频</strong> 提升困难，那多个 CPU 一起运行，不也可以提升性能嘛，多核就涉及到了多线程，也就是今天要讲的主题的由来。</p><p>接上个🌰，铺设多条轨道，同时跑多列车，性能不就提升起来了嘛。</p><h1 id="2-查看线程信息示例"><a href="#2-查看线程信息示例" class="headerlink" title="2. 查看线程信息示例"></a>2. 查看线程信息示例</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="comment">// 虚拟机线程管理接口</span></span><br><span class="line">    <span class="type">ThreadMXBean</span> <span class="variable">threadMXBean</span> <span class="operator">=</span> ManagementFactory.getThreadMXBean();</span><br><span class="line">    <span class="comment">// 获去线程信息</span></span><br><span class="line">    ThreadInfo[] threadInfos = threadMXBean.dumpAllThreads(<span class="literal">false</span>, <span class="literal">false</span>);</span><br><span class="line">    <span class="comment">// 输出线程信息</span></span><br><span class="line">    <span class="keyword">for</span> (ThreadInfo threadInfo : threadInfos) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;[&quot;</span> + threadInfo.getThreadId() + <span class="string">&quot;]&quot;</span> + <span class="string">&quot; &quot;</span> + threadInfo.getThreadName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用上述方法后，会输出虚拟机中的线程信息，我电脑上的输出信息如下：</p><pre><code>[4] Signal Dispatcher // 信令分发[3] Finalizer // 对象被销毁时调用，但是不一定百分比调用成功[2] Reference Handler // 引用处理[1] main // 主线程</code></pre><h1 id="3-线程的使用"><a href="#3-线程的使用" class="headerlink" title="3. 线程的使用"></a>3. 线程的使用</h1><p>一般来讲，想使用线程，有 3 种方式：</p><p>方式 1：继承 Thread</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 1. 派生 Thread</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">UseThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.run();</span><br><span class="line">        System.out.println(<span class="string">&quot;I am extends Thread&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方式 2：实现 Runnable</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">UseRun</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;I am implements Runnable&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方式 3：实现 Callable，有返回值</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">UseCall</span> <span class="keyword">implements</span> <span class="title class_">Callable</span>&lt;String&gt; &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">call</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;I am implements Callable&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Call result&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实际而言，只有第一种才能算称得上 <code>线程</code>，Runnable 和 Callable 表示的是 <code>线程</code> 中的 <strong>任务</strong>，而非线程，还是需要传递到 <code>线程</code> 中，通过 <code>线程</code> 的 start() 方法启动线程。</p><p>测试代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 测试方法</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> args</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> ExecutionException</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> InterruptedException</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 实际而言，只有 Thread 才能代表线程；</span></span><br><span class="line"><span class="comment"> * Runnable、Callable 表示的是任务</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 基于 Thread 派生启动线程</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">UseThread</span> <span class="variable">useThread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UseThread</span>();</span><br><span class="line">    useThread.start();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 基于 Runnable 启动线程</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">UseRun</span> <span class="variable">useRun</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UseRun</span>();</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Thread</span>(useRun).start();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 通过 Callable 可以获取回调信息</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">UseCall</span> <span class="variable">useCall</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UseCall</span>();</span><br><span class="line">    FutureTask&lt;String&gt; futureTask = <span class="keyword">new</span> <span class="title class_">FutureTask</span>&lt;&gt;(useCall);</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Thread</span>(futureTask).start();</span><br><span class="line">    System.out.println(futureTask.get());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意：start() 方法不一定代表线程立即执行，只是告诉线程目前处于就绪状态，具体什么时间执行是等待系统通知的。</p><h1 id="4-线程的停止"><a href="#4-线程的停止" class="headerlink" title="4. 线程的停止"></a>4. 线程的停止</h1><p>前面讲了开启 <code>线程</code>，那么线程也要能停止才行啊。</p><p>在讲停止之前，先补充一下 <strong>抢占式</strong> 任务基本信息：在调用 stop() 方法之后，线程直接停止，加入线程现在在处理的信息是否重要，可能会造成丢失，比如正在写一个关键文件，已经写入 90%，如果此时停止，文件就会出现异常，导致信息丢失。</p><p>由于 <strong>抢占式任务</strong> 的种种弊端，现已废弃 <strong>stop()</strong> 方法，改为 <strong>协作式任务</strong>。这就温柔的多了，只是告诉 <code>线程</code>，你被打断了，线程可以继续执行任务，也可以择时停止，这样就能避免信息丢失，同时，对开发人员的要求也提高了不少。</p><p>下面，简单介绍一下几个方法，避免混淆；</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Interrupts this thread.</span></span><br><span class="line"><span class="comment"> * Unless the current thread is interrupting itself, which is always permitted, the checkAccess method of this thread is invoked, which may cause a SecurityException to be thrown.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">interrupt</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span> != Thread.currentThread())</span><br><span class="line">        checkAccess();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">synchronized</span> (blockerLock) &#123;</span><br><span class="line">        <span class="type">Interruptible</span> <span class="variable">b</span> <span class="operator">=</span> blocker;</span><br><span class="line">        <span class="keyword">if</span> (b != <span class="literal">null</span>) &#123;</span><br><span class="line">            interrupt0(); <span class="comment">// Just to set the interrupt flag，注意这个官方注释哟，这里其实只是设置了 interrupt 标识符，具体是否停止要看线程本身。</span></span><br><span class="line">            b.interrupt(<span class="built_in">this</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    interrupt0();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 这是一个 native 方法，主要作用是测试线程是否 interrupted，注意传的参数，如果为 true，则会清空当前 interrupted 状态，千万要注意</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">native</span> <span class="type">boolean</span> <span class="title function_">isInterrupted</span><span class="params">(<span class="type">boolean</span> ClearInterrupted)</span>;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 其实就是调用了上面的 isInterrupted 方法，并表示不清除 interrupted 状态</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isInterrupted</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> isInterrupted(<span class="literal">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 同上，与  isInterrupted() 的区别就是：会清除 interrupted 状态</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">interrupted</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> currentThread().isInterrupted(<span class="literal">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="5-线程常用方法"><a href="#5-线程常用方法" class="headerlink" title="5. 线程常用方法"></a>5. 线程常用方法</h1><p>前面介绍了开始、结束，再介绍一下线程的其它常用方法。</p><table><thead><tr><th align="center">方法</th><th align="center">介绍</th></tr></thead><tbody><tr><td align="center">yield()</td><td align="center">native 方法，线程从运行状态切换为可运行状态，也就是就绪状态</td></tr><tr><td align="center">sleep()</td><td align="center">native 方法，线程会切换为阻塞状态</td></tr><tr><td align="center">join()</td><td align="center">实际上内部调用了 wait 方法，线程切换为阻塞状态</td></tr></tbody></table><h1 id="6-线程锁"><a href="#6-线程锁" class="headerlink" title="6. 线程锁"></a>6. 线程锁</h1><p>前面讲到过，进程下的资源对所有子线程共享，那么子线程就可以对资源进行读写，多个线程同时抢夺资源，就会出现数据错乱。</p><p>在讲锁之前，先说说 <strong>等待和通知的标准范式</strong>：</p><p><strong>等待方</strong>：</p><ol><li>获取对象的锁；</li><li>如果条件不满足，那么调用对象的 wait() 方法，被通知后仍要检查条件；<br>3、如果条件满足则执行对应的逻辑；</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">synchronized</span>(Object) &#123;</span><br><span class="line">    <span class="keyword">while</span>(条件不满足) &#123;</span><br><span class="line">        Object.wait();</span><br><span class="line">    &#125;</span><br><span class="line">    对应的处理逻辑</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>接收方</strong>:</p><ol><li>获得对象的锁；</li><li>改变条件；</li><li>通知所有等待在对象上的线程。</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">synchronized</span>(Object) &#123;</span><br><span class="line">    改变条件</span><br><span class="line">    对象.notifyAll();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>先列举一个示例代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SynTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">long</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">long</span> <span class="title function_">getCount</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setCount</span><span class="params">(<span class="type">long</span> count)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.count = count;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对 count 进行累加，由于没有加锁，计算的结果会偏小，不正确</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">incCount1</span><span class="params">()</span> &#123;</span><br><span class="line">        count++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 加方法锁</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">incCount2</span><span class="params">()</span> &#123;</span><br><span class="line">        count++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 加指定对象锁</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">incCount3</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (obj) &#123;</span><br><span class="line">            count++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 加当前对象锁</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">incCount4</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">            count++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 开启线程进行操作</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Count</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> SynTest synTest;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">Count</span><span class="params">(SynTest test)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.synTest = test;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++) &#123;</span><br><span class="line">                synTest.incCount1();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">SynTest</span> <span class="variable">synTest</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SynTest</span>();</span><br><span class="line">        <span class="comment">// 启动两个线程对 count 进行操作</span></span><br><span class="line">        <span class="type">Count</span> <span class="variable">thread1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Count</span>(synTest);</span><br><span class="line">        <span class="type">Count</span> <span class="variable">thread2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Count</span>(synTest);</span><br><span class="line">        thread1.start();</span><br><span class="line">        thread2.start();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">50</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(synTest.getCount());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>加锁除了 synchronized，还有显示锁 Lock。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LockDemo</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">Lock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">increment</span><span class="params">()</span> &#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            count++;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">LockDemo</span> <span class="variable">demo</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LockDemo</span>();</span><br><span class="line">        demo.increment();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Lock 是进行加锁，但是对于频繁读、少量写的 IO 操作，就会大大降低性能，ReadWriteLock 就是用来处理这类问题，性能至少是 10 倍提升，其实 ReadWriteLock 也很简单，先看看代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ReadWriteLock</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns the lock used for reading.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the lock used for reading</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    Lock <span class="title function_">readLock</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns the lock used for writing.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the lock used for writing</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    Lock <span class="title function_">writeLock</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>就是由 1 把锁变为 2 把锁，读锁相互之间不干扰，写锁控制所有锁，这样就可能将性能大幅提升。</p><p>先来展示 Synchronized 方式示例代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UseSyn</span> <span class="keyword">implements</span> <span class="title class_">GoodsService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> GoodsInfo goodsInfo;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">UseSyn</span><span class="params">(GoodsInfo goodsInfo)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.goodsInfo = goodsInfo;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> GoodsInfo <span class="title function_">getNum</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">5</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>.goodsInfo;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">setNum</span><span class="params">(<span class="type">int</span> number)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">5</span>);</span><br><span class="line">            goodsInfo.changeNumber(number);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出结果为：</span></span><br><span class="line">Thread-<span class="number">22</span>写商品数据耗时：<span class="number">2247</span> ms----</span><br><span class="line">Thread-<span class="number">26</span>读取商品数据耗时：<span class="number">3051</span> ms</span><br><span class="line">Thread-<span class="number">15</span>读取商品数据耗时：<span class="number">5433</span> ms</span><br><span class="line">Thread-<span class="number">13</span>读取商品数据耗时：<span class="number">6265</span> ms</span><br><span class="line">Thread-<span class="number">16</span>读取商品数据耗时：<span class="number">6594</span> ms</span><br><span class="line">Thread-<span class="number">21</span>读取商品数据耗时：<span class="number">7508</span> ms</span><br><span class="line">Thread-<span class="number">25</span>读取商品数据耗时：<span class="number">7780</span> ms</span><br><span class="line">Thread-<span class="number">30</span>读取商品数据耗时：<span class="number">9123</span> ms</span><br><span class="line">Thread-<span class="number">32</span>读取商品数据耗时：<span class="number">9894</span> ms</span><br><span class="line">Thread-<span class="number">9</span>读取商品数据耗时：<span class="number">10379</span> ms</span><br><span class="line">Thread-<span class="number">5</span>读取商品数据耗时：<span class="number">11117</span> ms</span><br><span class="line">Thread-<span class="number">4</span>读取商品数据耗时：<span class="number">11264</span> ms</span><br><span class="line">Thread-<span class="number">3</span>读取商品数据耗时：<span class="number">11828</span> ms</span><br><span class="line">Thread-<span class="number">7</span>读取商品数据耗时：<span class="number">12215</span> ms</span><br><span class="line">Thread-<span class="number">10</span>读取商品数据耗时：<span class="number">12448</span> ms</span><br><span class="line">Thread-<span class="number">11</span>写商品数据耗时：<span class="number">12506</span> ms----</span><br><span class="line">Thread-<span class="number">24</span>读取商品数据耗时：<span class="number">12630</span> ms</span><br><span class="line">Thread-<span class="number">0</span>写商品数据耗时：<span class="number">12819</span> ms----</span><br><span class="line">Thread-<span class="number">14</span>读取商品数据耗时：<span class="number">13211</span> ms</span><br><span class="line">Thread-<span class="number">17</span>读取商品数据耗时：<span class="number">13617</span> ms</span><br><span class="line">Thread-<span class="number">18</span>读取商品数据耗时：<span class="number">14142</span> ms</span><br><span class="line">Thread-<span class="number">23</span>读取商品数据耗时：<span class="number">15084</span> ms</span><br><span class="line">Thread-<span class="number">27</span>读取商品数据耗时：<span class="number">15282</span> ms</span><br><span class="line">Thread-<span class="number">29</span>读取商品数据耗时：<span class="number">15700</span> ms</span><br><span class="line">Thread-<span class="number">1</span>读取商品数据耗时：<span class="number">16594</span> ms</span><br><span class="line">Thread-<span class="number">8</span>读取商品数据耗时：<span class="number">16966</span> ms</span><br><span class="line">Thread-<span class="number">6</span>读取商品数据耗时：<span class="number">17235</span> ms</span><br><span class="line">Thread-<span class="number">31</span>读取商品数据耗时：<span class="number">17336</span> ms</span><br><span class="line">Thread-<span class="number">28</span>读取商品数据耗时：<span class="number">17639</span> ms</span><br><span class="line">Thread-<span class="number">20</span>读取商品数据耗时：<span class="number">17919</span> ms</span><br><span class="line">Thread-<span class="number">19</span>读取商品数据耗时：<span class="number">18386</span> ms</span><br><span class="line">Thread-<span class="number">2</span>读取商品数据耗时：<span class="number">18631</span> ms</span><br><span class="line">Thread-<span class="number">12</span>读取商品数据耗时：<span class="number">18687</span> ms</span><br></pre></td></tr></table></figure><p>接下来展示 ReadWriteLock 方式代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UseRwLock</span> <span class="keyword">implements</span> <span class="title class_">GoodsService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> GoodsInfo goodsInfo;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">ReadWriteLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantReadWriteLock</span>();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Lock</span> <span class="variable">readLock</span> <span class="operator">=</span> lock.readLock();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Lock</span> <span class="variable">writeLock</span> <span class="operator">=</span> lock.writeLock();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">UseRwLock</span><span class="params">(GoodsInfo goodsInfo)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.goodsInfo = goodsInfo;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> GoodsInfo <span class="title function_">getNum</span><span class="params">()</span> &#123;</span><br><span class="line">        readLock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">5</span>);</span><br><span class="line">            <span class="keyword">return</span> goodsInfo;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            readLock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setNum</span><span class="params">(<span class="type">int</span> number)</span> &#123;</span><br><span class="line">        writeLock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">5</span>);</span><br><span class="line">            goodsInfo.changeNumber(number);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            writeLock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出结果为：</span></span><br><span class="line">Thread-<span class="number">11</span>写商品数据耗时：<span class="number">219</span> ms----</span><br><span class="line">Thread-<span class="number">22</span>写商品数据耗时：<span class="number">219</span> ms----</span><br><span class="line">Thread-<span class="number">0</span>写商品数据耗时：<span class="number">274</span> ms----</span><br><span class="line">Thread-<span class="number">7</span>读取商品数据耗时：<span class="number">780</span> ms</span><br><span class="line">Thread-<span class="number">1</span>读取商品数据耗时：<span class="number">781</span> ms</span><br><span class="line">Thread-<span class="number">4</span>读取商品数据耗时：<span class="number">780</span> ms</span><br><span class="line">Thread-<span class="number">6</span>读取商品数据耗时：<span class="number">780</span> ms</span><br><span class="line">Thread-<span class="number">9</span>读取商品数据耗时：<span class="number">781</span> ms</span><br><span class="line">Thread-<span class="number">3</span>读取商品数据耗时：<span class="number">782</span> ms</span><br><span class="line">Thread-<span class="number">5</span>读取商品数据耗时：<span class="number">786</span> ms</span><br><span class="line">Thread-<span class="number">2</span>读取商品数据耗时：<span class="number">787</span> ms</span><br><span class="line">Thread-<span class="number">18</span>读取商品数据耗时：<span class="number">780</span> ms</span><br><span class="line">Thread-<span class="number">15</span>读取商品数据耗时：<span class="number">780</span> ms</span><br><span class="line">Thread-<span class="number">12</span>读取商品数据耗时：<span class="number">780</span> ms</span><br><span class="line">Thread-<span class="number">8</span>读取商品数据耗时：<span class="number">786</span> ms</span><br><span class="line">Thread-<span class="number">10</span>读取商品数据耗时：<span class="number">786</span> ms</span><br><span class="line">Thread-<span class="number">17</span>读取商品数据耗时：<span class="number">780</span> ms</span><br><span class="line">Thread-<span class="number">21</span>读取商品数据耗时：<span class="number">785</span> ms</span><br><span class="line">Thread-<span class="number">13</span>读取商品数据耗时：<span class="number">785</span> ms</span><br><span class="line">Thread-<span class="number">14</span>读取商品数据耗时：<span class="number">785</span> ms</span><br><span class="line">Thread-<span class="number">20</span>读取商品数据耗时：<span class="number">785</span> ms</span><br><span class="line">Thread-<span class="number">19</span>读取商品数据耗时：<span class="number">785</span> ms</span><br><span class="line">Thread-<span class="number">16</span>读取商品数据耗时：<span class="number">785</span> ms</span><br><span class="line">Thread-<span class="number">28</span>读取商品数据耗时：<span class="number">784</span> ms</span><br><span class="line">Thread-<span class="number">31</span>读取商品数据耗时：<span class="number">783</span> ms</span><br><span class="line">Thread-<span class="number">30</span>读取商品数据耗时：<span class="number">784</span> ms</span><br><span class="line">Thread-<span class="number">27</span>读取商品数据耗时：<span class="number">784</span> ms</span><br><span class="line">Thread-<span class="number">29</span>读取商品数据耗时：<span class="number">784</span> ms</span><br><span class="line">Thread-<span class="number">24</span>读取商品数据耗时：<span class="number">784</span> ms</span><br><span class="line">Thread-<span class="number">23</span>读取商品数据耗时：<span class="number">784</span> ms</span><br><span class="line">Thread-<span class="number">25</span>读取商品数据耗时：<span class="number">784</span> ms</span><br><span class="line">Thread-<span class="number">26</span>读取商品数据耗时：<span class="number">790</span> ms</span><br><span class="line">Thread-<span class="number">32</span>读取商品数据耗时：<span class="number">789</span> ms</span><br></pre></td></tr></table></figure><p>做同样的时，耗时由 18687 ms 降低为 790 ms，由此可见性能提升之巨大，小伙伴们在加锁的时候，要注意选择合适的锁，避免性能浪费。</p><h1 id="7-线程变量"><a href="#7-线程变量" class="headerlink" title="7. 线程变量"></a>7. 线程变量</h1><p>锁保证了操作资源的原子性，那么在一个类中，希望每个线程拿到的值都是一样的初始值，而不是被别的线程改变过后的值，如何解决呢？例子如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 期望每个线程拿到这个值都是指定值，然后进行处理，而不被其它线程所干扰</span></span><br><span class="line"><span class="keyword">static</span> <span class="type">Integer</span> <span class="variable">count</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 启动 3 个线程</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">startThreadArray</span><span class="params">()</span> &#123;</span><br><span class="line">    Thread[] runs = <span class="keyword">new</span> <span class="title class_">Thread</span>[<span class="number">3</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; runs.length; i++) &#123;</span><br><span class="line">        runs[i] = <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">TestTask</span>(i));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; runs.length; i++) &#123;</span><br><span class="line">        runs[i].start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码中，是无法满足要求的，如何处理呢？</p><p>在翻阅了源码后发现，有一个 <strong>ThreadLocal</strong>，即 <code>线程变量</code>，是一个以 <strong>ThreadLocal</strong> 对象为键、任意对象为值的存储结构。这个结构被附带在线程上，也就是说一个线程可以根据一个 <strong>ThreadLocal</strong> 对象查询到绑定在这个线程上的一个值，用来实现变量在线程之间的隔离。</p><p>修改后如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 改动后，即可满足要求</span></span><br><span class="line"><span class="keyword">static</span> ThreadLocal&lt;Integer&gt; count = ThreadLocal.withInitial(() -&gt; <span class="number">1</span>);</span><br></pre></td></tr></table></figure><h1 id="8-线程池"><a href="#8-线程池" class="headerlink" title="8. 线程池"></a>8. 线程池</h1><p><code>线程池</code> 是一种多线程处理形式，处理过程中将任务添加到队列，然后在创建线程后自动启动这些任务。</p><p>简单一点来说，由于 <em>创建线程</em> 和 <em>销毁线程</em> 是比较消耗资源的，对于执行任务内容较少且数量较多时，效率偏低，如果将资源提前创建并缓存到资源池中，每次使用的时候即拿即用，效率会得到大幅提升，并且也能有效的管理线程资源。</p><p>线程池优点：</p><ol><li>降低资源消耗；</li><li>提高响应速度；</li><li>提高线程的可管理性；</li></ol><p>在 Java 中，系统提供的有线程池：ThreadPoolExecutor，通过构造函数，我们知道线程池几个核心的控制数据。</p><blockquote><p>corePoolSize: 线程池中的核心线程数量，如果 <code>线程池</code> 中的线程数量大于等于这个数值后，继续提交的任务会被保存到阻塞队列中，等待被执行；</p><p>maximumPoolSize: <strong>线程池</strong> 中允许的最大线程数，如果当前阻塞队列满了，并且继续提交任务，则创建新的线程执行任务，但是这个数量要小于 maximumPoolSize；</p><p>keepAliveTime: 非核心线程空闲时存活时间；</p><p>unit: keepAliveTime 的时间单位；</p><p>workQueue: 必须是 BlockQuene 阻塞队列，当线程池中的线程数超过 corePoolSize 时，线程会进入阻塞队列进行阻塞等待。</p><p>threadFactory: 创建线程的工厂，可以自定义增加更多控制、资源信息；</p><p>handler: 饱和策略，当阻塞队列满了，且没有空闲的工作线程，如果继续提交任务，必须采用一种策略处理该任务，线程池提供了 4 种策略:</p><ol><li><p>AbortPolicy: 直接抛出异常，默认策略；</p></li><li><p>CallerRunsPolicy：用调用者所在的线程执行任务；</p></li><li><p>DiscardOldestPolicy：丢弃阻塞队列中靠最前的任务，并执行当前任务；</p></li><li><p>DiscardPolicy: 直接丢弃任务；</p></li></ol><p>补充：除了这 4 种策略外，还可以自定义策略，哪怕不新增处理方案，可以记录到文件中，待合适时机从文件中读取任务继续执行，或者记录日志，留备以后分析使用。</p></blockquote><p>线程池清楚了，那么如何合理配置线程池呢？最终要的是分析任务特性，可以从以下几个方面进行分析：</p><ol><li>任务的性质：CPU 密集型、IO 密集型和混合任务型；</li><li>任务的优先级：高、中和低；</li><li>任务的执行时间：长、中和短；</li><li>任务的依赖性：是否依赖其他的系统资源，如数据库连接；</li></ol>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
            <tag> Java </tag>
            
            <tag> 多线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>代理与动态代理</title>
      <link href="/2020/12/25/Java/%E4%BB%A3%E7%90%86%E4%B8%8E%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/"/>
      <url>/2020/12/25/Java/%E4%BB%A3%E7%90%86%E4%B8%8E%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/</url>
      
        <content type="html"><![CDATA[<p>在前面学习 <code>设计模式</code> 的时候，学习过 <a href="https://walkerdenial.com/2017/02/24/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/">代理模式</a>，如果没看过的可以点击链接看一下。</p><p>我们经常听到的是 <strong>没有中间商赚差价</strong>，<strong>代理</strong> 其实就相当于是 <strong>中间商</strong>，既然中间商会赚差价（额外增加开销），那么我们为什么要使用 <strong>代理</strong> 呢？</p><p>举个栗子，现在需要购买食物大米，你是直接去超市、小卖部、粮油店等 <strong>中间商</strong> 处买呢？还是直接下乡，去种植户里购买？如果直接购买的话，你不仅要知道你需要的是大米，还需要知道大米产自哪里、哪个季节收获、哪个区域售卖等等一系列问题，会额外增加消费者负担，而这些，其实可以交给 <strong>代理</strong> 搞定就行了，省心、省力。</p><h1 id="1-静态代理"><a href="#1-静态代理" class="headerlink" title="1. 静态代理"></a>1. 静态代理</h1><p><img src="https://personal-blog.oss-cn-hangzhou.aliyuncs.com/static_proxy.jpg" alt="静态代理"></p><p>场景：购买大米。</p><p>Step. 1 定义食物接口</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">IFood</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">buyFood</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Step. 2 定义大米</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RiceFood</span> <span class="keyword">implements</span> <span class="title class_">IFood</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">buyFood</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;buy food for rice&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Step. 3 代理入场</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 食物代理类</span></span><br><span class="line"><span class="comment"> * 作用：用户只需要通过代理商购买食物，而不需要去农田里购买</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NormalFoodProxy</span> <span class="keyword">implements</span> <span class="title class_">IFood</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> IFood food;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">NormalFoodProxy</span><span class="params">(IFood food)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.food = food; <span class="comment">// 设置具体代理商</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 通过委托代理商购买商品</span></span><br><span class="line"><span class="comment">     * 好处：可以对商品进行加工处理</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">buyFood</span><span class="params">()</span> &#123;</span><br><span class="line">        beforeSale();</span><br><span class="line">        food.buyFood();</span><br><span class="line">        afterSale();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 售前服务</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">beforeSale</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;代理商检查食物是否安全&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 售后服务</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">afterSale</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;代理商提供送货上门服务&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Step. 4 消费者购买</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1. 找到代理商并告诉 ta，需要购买大米</span></span><br><span class="line"><span class="type">NormalFoodProxy</span> <span class="variable">proxy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">new</span> NormalFoodProxy(<span class="keyword">new</span> <span class="title class_">RiceFood</span>());</span><br><span class="line"><span class="comment">// 2. 购买大米</span></span><br><span class="line">proxy.buyRice();</span><br></pre></td></tr></table></figure><p>就是这么简单，2 步就搞定了，花费一些可以接受的代价，尽快满足需求，何乐而不为呢？</p><p>做过支付的同学应该深有体会，是对接支付宝、微信支付呢，还是分别对接几百家银行方便，相比不用多说了吧。</p><p>优点：</p><ol><li>通过代理可以提供增值服务（扩展更多信息）</li><li>通过代理可以不需要知道具体实现细节</li></ol><p>同时，缺点也很明显：</p><ol><li>增加一个新的操作，需要增加新的接口，违反开闭原则，可扩展性差</li><li>虽然不需要知道具体实现细节，但是需要知道具体实现类，造成类的额外负担</li><li>还是需要知道具体实现类，导致类变得复杂</li></ol><p>如果需要的种类成千上万，那么代理类就会庞大到无法维护，所以 <code>动态代理</code> 应用而生。</p><h1 id="2-动态代理"><a href="#2-动态代理" class="headerlink" title="2. 动态代理"></a>2. 动态代理</h1><p>动态代理的核心是 JDK 提供的 <strong>Proxy</strong> 和 <strong>InvocationHandler</strong>。</p><p>结合 Proxy 注释介绍 Proxy 是什么：</p><blockquote><p>Proxy provides static methods for creating dynamic proxy classes and instances, and it is also the superclass of all dynamic proxy classes created by those methods.</p></blockquote><p>简单翻译一下就是：Proxy 提供静态方法用来创建动态代理类和实例，所有的动态代理类都基于它。</p><p>看来，想要使用动态代理是绕不过 <strong>Proxy</strong> 的了。</p><p>与 <strong>Proxy</strong> 紧密结合的，还要有 ** InvocationHandler** 类。</p><blockquote><p>InvocationHandler is the interface implemented by the invocation handler of a proxy instance.</p><p>Each proxy instance has an associated invocation handler. When a method is invoked on a proxy instance, the method invocation is encoded and dispatched to the invoke method of its invocation handler.</p></blockquote><p>代码也很简单，就只有一个方法。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">InvocationHandler</span> &#123;</span><br><span class="line"><span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span></span><br><span class="line">        <span class="keyword">throws</span> Throwable;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么，<strong>Proxy</strong> 倒是是如何结合 <strong>InvocationHandler</strong> 的呢，接下来看一下源码：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Proxy</span> <span class="keyword">implements</span> <span class="title class_">java</span>.io.Serializable &#123;</span><br><span class="line"><span class="comment">// 省略若干代码</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// parameter types of a proxy class constructor</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Class&lt;?&gt;[] constructorParams = &#123; InvocationHandler.class &#125;;</span><br><span class="line"><span class="comment">// a cache of proxy classes</span></span><br><span class="line"><span class="keyword">protected</span> InvocationHandler h;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title function_">newProxyInstance</span><span class="params">(ClassLoader loader, Class&lt;?&gt;[] interfaces, InvocationHandler h)</span> <span class="keyword">throws</span> IllegalArgumentException &#123;</span><br><span class="line"><span class="comment">// 省略若干代码</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过反射的方式将 InvocationHandler 对象 h 传递给实例化的类</span></span><br><span class="line"><span class="keyword">return</span> cons.newInstance(<span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;h&#125;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后看一下动态生成的类中 <strong>InvocationHandler</strong> 如何工作的。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">buyFood</span><span class="params">()</span> <span class="keyword">throws</span>  &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// 调用 InvocationHandler 的 invoke 方法进行处理</span></span><br><span class="line">      <span class="comment">// 由此可见，自定义动态代理需要实现 InvocationHandler 的，要不然流程无法走通</span></span><br><span class="line">        <span class="built_in">super</span>.h.invoke(<span class="built_in">this</span>, m3, (Object[])<span class="literal">null</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (RuntimeException | Error var2) &#123;</span><br><span class="line">        <span class="keyword">throw</span> var2;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable var3) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UndeclaredThrowableException</span>(var3);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>整体 JDK 实现流程如下图：</p><p><img src="https://personal-blog.oss-cn-hangzhou.aliyuncs.com/dynamic_proxy.png" alt="动态代理"></p><h1 id="3-动态代理示例"><a href="#3-动态代理示例" class="headerlink" title="3. 动态代理示例"></a>3. 动态代理示例</h1><p>由上面源码分析，自定义动态代理类需要 implements InvocationHandler，先定义一个代理。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 除了 InvocationHandler，不需要实现额外接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DynamicProxy</span> <span class="keyword">implements</span> <span class="title class_">InvocationHandler</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Object factory;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setFactory</span><span class="params">(Object factory)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.factory = factory;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">getFactory</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> factory;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 通过 Proxy 获得动态代理对象</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">getProxyInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Proxy.newProxyInstance(factory.getClass().getClassLoader(),</span><br><span class="line">                factory.getClass().getInterfaces(), <span class="built_in">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 通过动态代理方法进行增强</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> proxy</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> method</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> args</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Throwable</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        doBefore();</span><br><span class="line">        <span class="type">Object</span> <span class="variable">result</span> <span class="operator">=</span> method.invoke(factory, args);</span><br><span class="line">        doAfter();</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">doBefore</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;提供代理前服务&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">doAfter</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;提供代理后服务&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="comment">// 初始化动态代理类</span></span><br><span class="line">    <span class="type">DynamicProxy</span> <span class="variable">proxy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DynamicProxy</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 代理 RiceFood（此时动态代理类里面没有实现 IFood 接口）</span></span><br><span class="line">    <span class="type">RiceFood</span> <span class="variable">riceFood</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RiceFood</span>();</span><br><span class="line">    proxy.setFactory(riceFood);</span><br><span class="line">    <span class="comment">// 获取动态代理类实例</span></span><br><span class="line">    <span class="type">IFood</span> <span class="variable">riceProxy</span> <span class="operator">=</span> (IFood) proxy.getProxyInstance();</span><br><span class="line">    riceProxy.buyFood();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">输出信息如下：</span><br><span class="line"></span><br><span class="line">提供代理前服务</span><br><span class="line">buy food <span class="keyword">for</span> rice</span><br><span class="line">提供代理后服务</span><br></pre></td></tr></table></figure><p>总结：相较于静态代理，动态代理可扩展性更强，Retrofit 使用的就是 动态代理，Spring 中也大量使用到动态代理，掌握好动态代理，能提升框架搭建的能力。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
            <tag> Java </tag>
            
            <tag> 代理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>接口与抽象类的区别</title>
      <link href="/2020/12/14/Java/%E6%8E%A5%E5%8F%A3%E4%B8%8E%E6%8A%BD%E8%B1%A1%E7%B1%BB%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
      <url>/2020/12/14/Java/%E6%8E%A5%E5%8F%A3%E4%B8%8E%E6%8A%BD%E8%B1%A1%E7%B1%BB%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
      
        <content type="html"><![CDATA[<p>OOP 中，核心是 <code>封装</code>、<code>继承</code> 和 <code>多态</code>，而在 <code>继承</code> 中，常常关联的是 <code>接口</code> 和 <code>抽象类</code>，经常用倒是不假，但是使用语言组织描述一下，有可能就会卡壳，而这些是基础，基础的掌握程度决定了大厦的高度，因此，经常重新梳理一下 <code>封装</code> 中常用的 <code>接口</code> 和 <code>抽象类</code>。</p><p>老规矩，想学什么东西，第一件事就是要了解 <strong>是什么</strong>，如果概念不清，就相当于开车路线不清楚，在路上瞎开，有时候，不一定能开到期望的终点。</p><h1 id="1-基础概念"><a href="#1-基础概念" class="headerlink" title="1. 基础概念"></a>1. 基础概念</h1><h2 id="1-1-接口"><a href="#1-1-接口" class="headerlink" title="1.1 接口"></a>1.1 接口</h2><blockquote><p>接口（英语：Interface），在Java编程语言中是一个抽象类型（Abstract Type），它被用来要求类(Class) 必须实现指定的方法，使不同类的对象可以利用相同的界面进行沟通。接口通常以 interface 来宣告，它仅能包含方法签名（Method Signature）以及常量宣告（变量宣告包含了 static 及 final），一个接口不会包含方法的实现（仅有定义）。</p></blockquote><p><code>接口</code> 的特点：</p><ol><li>接口无法被实例化，但是可以被实现。一个实现接口的类，必须实现接口内所描述的所有方法，否则就必须宣告为抽象类（Abstract Class）</li><li>在Java中，接口类型可用来宣告一个变量，他们可以成为一个空指针，或是被绑定在一个以此接口实现的对象</li><li>其中一个使用接口的优势是，可以利用他们模拟多重继承，类在JAVA中不允许多重继承，所有在JAVA中的类必须而且仅能有一个父类，而java.lang.Object（JAVA类型系统中最顶层的类型）是唯一一个例外</li><li>JAVA的类可以被实现许多个接口，然而一个接口则无法实现其他的接口</li></ol><p>知道 <code>接口</code> 是什么，以及其特点以后，我们能用 <code>接口</code> 做什么呢？</p><p>开发中，可以使用 <code>接口</code> 用来统一类的共通行为，当不同的类需要进行信息共享时，是不需要特别去创建类间的关系。</p><p>举个 🌰：</p><p>一个人（Human）及一只鹦鹉（Parrot）都会吹口哨（whistle），然而 Human 及 Parrot 不应该为 Whistler 的子类，最好的做法是令他们为 Animal 的子类，而他们可以使用 Whistler 的接口进行沟通。其中 Whistler 就可以是一个 <code>接口</code> ，规约了 whistle 功能。</p><h2 id="1-2-抽象类"><a href="#1-2-抽象类" class="headerlink" title="1.2  抽象类"></a>1.2  抽象类</h2><p>介绍 <code>抽象</code> 类之前，先简单介绍下 <strong>不抽象</strong> 的 <code>类</code>。</p><blockquote><p>类（英语：class）在面向对象编程中是一种面向对象计算机编程语言的构造，是创建对象的蓝图，描述了所创建的对象共同的属性和方法。</p><p>类的更严格的定义是由某种特定的元数据所组成的内聚的包。它描述了一些对象的行为规则，而这些对象就被称为该类的实例。</p></blockquote><p>简单来讲，<code>类</code> 就是对 <code>属性</code> 和 <code>方法</code> 的封装。使用伪码举个 🌰 ：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class 人 &#123;</span><br><span class="line">属性：身高</span><br><span class="line">属性：性别</span><br><span class="line">属性：肤色</span><br><span class="line"></span><br><span class="line">方法：学习() &#123;</span><br><span class="line">输出：比如正在看这篇文章的你正在学习</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">方法：跑步() &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结合上面简单的伪码，就能简单的理解 <code>类</code> 了，你可以尝试举一反三。</p><p>接下来，进入正题，介绍介绍 <code>抽象类</code>。</p><blockquote><p>抽象类：被定义为永远不会也不能被实例化为具体的对象。它往往用于定义一种抽象上的概念，在类的继承关系中它往往被定义在较上层的位置。</p></blockquote><p>敲黑板！敲黑板！敲黑板！</p><p><strong>永远不会也不能被实例化为具体的对象</strong>，这是重点，圈起来要考。</p><p>既然不能被实例化，那么它的作用是什么呢，请往后看：<strong>定义一种抽象上的概念</strong>，这就是 <code>抽象类</code> 的核心目的。是一个 <strong>概念</strong>，而不是具体的实现。</p><h1 id="2-抽象类-和-接口-对比分析"><a href="#2-抽象类-和-接口-对比分析" class="headerlink" title="2. 抽象类 和 接口 对比分析"></a>2. <code>抽象类</code> 和 <code>接口</code> 对比分析</h1><table><thead><tr><th align="center"></th><th align="center">接口</th><th align="center">抽象类</th></tr></thead><tbody><tr><td align="center">是不完整的类</td><td align="center">✅</td><td align="center">✅</td></tr><tr><td align="center">定义抽象方法</td><td align="center">✅</td><td align="center">✅</td></tr><tr><td align="center">定义非抽象方法</td><td align="center">❎</td><td align="center">✅</td></tr><tr><td align="center">定义不可变属性</td><td align="center">✅</td><td align="center">✅</td></tr><tr><td align="center">定义可变属性</td><td align="center">❎</td><td align="center">✅</td></tr><tr><td align="center">单继承</td><td align="center">✅</td><td align="center">✅</td></tr><tr><td align="center">多继承</td><td align="center">✅</td><td align="center">❎</td></tr></tbody></table><p>由上面可见，<code>接口</code> 可以看做一种特殊的 <code>抽象类</code>。</p><h1 id="3-抽象类-和-接口-的选择"><a href="#3-抽象类-和-接口-的选择" class="headerlink" title="3. 抽象类 和 接口 的选择"></a>3. <code>抽象类</code> 和 <code>接口</code> 的选择</h1><h2 id="3-1-从-属性-和-方法-进行判断"><a href="#3-1-从-属性-和-方法-进行判断" class="headerlink" title="3.1 从 属性 和 方法 进行判断"></a>3.1 从 <code>属性</code> 和 <code>方法</code> 进行判断</h2><ol><li>属性是可变的</li><li>提供默认方法实现，减少重复代码编写</li></ol><p>如果满足上面任何一个条件，选择 <code>抽象类</code>，反之，选择 <code>接口</code>；</p><h3 id="3-2-从-is-T-判断"><a href="#3-2-从-is-T-判断" class="headerlink" title="3.2 从 is T 判断"></a>3.2 从 is T 判断</h3><p>采用 is 的方式进行判断。举个例子，<strong>苹果</strong> 细分领域还有很多，比如：<strong>红富士</strong>、<strong>烟台苹果</strong> 等等，这里 <strong>红富士</strong> is <strong>苹果</strong>，是一个可具象化的类型，这种场景应选择 <code>抽象类</code>；</p><p>如果只是一个一个概念性的东西，比如 <strong>飞翔</strong>，可以具有该行为能力的物种有很多，并且是可选的，大部分鸟类可以飞，但是还有不会飞的鸟类，那么 <code>飞翔</code> 就是一个可选动作属性，此处使用 <code>接口</code> 适宜；</p><p>最后，再次送上一个 🌰：“水果”可以算作一个抽象类，而“苹果”、“香蕉”则可以作为它的派生类。区别在于，“水果”是个概念，它不会有实例，但是“苹果”、“香蕉”则肯定会有实例。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 基础 </tag>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>面向对象回顾</title>
      <link href="/2020/12/07/Kotlin/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%9B%9E%E9%A1%BE/"/>
      <url>/2020/12/07/Kotlin/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%9B%9E%E9%A1%BE/</url>
      
        <content type="html"><![CDATA[<p>记得刚开始学习编程的时候，老师在介绍 <code>面向对象</code> 的时候，讲述到了 <code>面向对象</code> 编程的核心：<strong>封装</strong>、<strong>继承</strong> 和 <strong>多态</strong>。在开发生涯中，是绕不开这三点的，今天简单回顾一下这三点，相当于做一个笔记吧。</p><h1 id="1-封装"><a href="#1-封装" class="headerlink" title="1. 封装"></a>1. 封装</h1><p>先用官方版本的定义开场吧：</p><blockquote><p>封装，即隐藏对象的属性和实现细节，仅对外公开接口，控制在程序中属性的读和修改的访问级别；将抽象得到的数据和行为（或功能）相结合，形成一个有机的整体，也就是将数据与操作数据的源代码进行有机的结合，形成“类”，其中数据和函数都是类的成员。</p></blockquote><p>如果你有点懵？那么我来举个栗子就明白了。现在人们日常生活越来越离不开手机，就以手机来举栗子吧。</p><blockquote><p>隐藏对象的属性和实现细节 –&gt; 我们拿到的手机是组装好的成品，而不是一个个零件，即手机对我们隐藏了内部软件、硬件等相关细节；换个角度，如果给我一堆零件让我自己组装，我可能会放弃使用手机了吧。</p><p>仅对外公开接口，控制在程序中属性的读和修改的访问级别 –&gt; 手机对我们开放的也就是 「开&#x2F;关机」、「音量」、「主页」等少部分可操作功能，如果不开放，那手机也就没法使用了，跟个砖头没啥区别，所以需要对外开放部分操作，但是，用户不需要具体知道某个功能如何实现的。同理，司机不需要知道汽车是如何制造的，但是要能操作「启动」、「转向」等功能。</p></blockquote><p>生活中处处皆 <code>封装</code>，比如：热水壶（需要烧水功能，但是用户不需要知道如何实现的）、空调（需要制冷&#x2F;制热功能，用户不需要知道如何实现空气温度调节的）等等，这也是 <code>面向对象</code> 的由来，所以结合现实生活中的例子，就能更好的理解 <code>封装</code> 概念了。</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Phone</span> &#123;</span><br><span class="line"><span class="keyword">val</span> name = <span class="string">&quot;Mi 10&quot;</span> <span class="comment">// 手机名称</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">turnOn</span> <span class="params">()</span></span> &#123; <span class="comment">// 开机</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">turnOff</span> <span class="params">()</span></span> &#123; <span class="comment">// 关机</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="2-继承"><a href="#2-继承" class="headerlink" title="2. 继承"></a>2. 继承</h1><blockquote><p>继承就是子类继承父类的特征和行为，使得子类对象（实例）具有父类的属性和方法，或子类从父类继承方法，使得子类具有父类相同的行为。</p></blockquote><p><code>继承</code> 就比较简单了，这个概念经常在生活中听到，所以理解起来不难。例如：</p><p>子女（<code>子类</code>）可以继承自己祖辈（<code>父类</code>）的基因（<code>属性</code>）、财产（<code>方法</code>）等特性，同时，<code>子类</code> 也可以有别于 <code>父类</code>，不止能 <code>继承</code>，还能自己玩出新花样，比如不同的爱好、技能等等。</p><p>为什么要使用 <code>继承</code> 呢？人类进化到现在，用了几千万时间，如果不使用 <code>继承</code>，你现在可能还是个 <code>单细胞生物</code>，也没机会阅读这篇文章了，所以 使用<code>继承</code> 是相当有必要的，通过 <code>继承</code> 拥有 <code>父类</code> 的特性，减少重复操作，提升复用性。</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Father</span> &#123;</span><br><span class="line"><span class="keyword">val</span> dna = <span class="string">&quot;xxx&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son</span> : <span class="type">Father</span>() &#123; <span class="comment">// 通过继承，就拥有了父类的 dna 特性，如果不继承，就没有</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="3-多态"><a href="#3-多态" class="headerlink" title="3. 多态"></a>3. 多态</h1><blockquote><p>同一操作作用于不同的对象，可以有不同的解释，产生不同的执行结果。</p></blockquote><p>用白话文来举个栗子：有的家庭有多个小孩，这些小孩有同一个爸爸&#x2F;妈妈（继承），但是，这些小孩却并不完全一模一样，包括但不限于身高、体重、长相、天赋等等，这…就是多态，虽然是 <code>继承</code> 自同一个 <code>父类</code>，却有不同的表现，哪怕是双胞胎也不例外，这就叫 <code>多态</code>。所以说，<code>多态</code> 没有那么难以理解，正是因为有了 <code>多态</code>，世界才会更多姿多彩。</p><h2 id="3-1-多态举例"><a href="#3-1-多态举例" class="headerlink" title="3.1 多态举例"></a>3.1 多态举例</h2><p>多态由于可变性很强，所以结合例子服用效果更佳。</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">open</span> <span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">open</span> <span class="function"><span class="keyword">fun</span> <span class="title">show</span><span class="params">(obj: <span class="type">D</span>)</span></span>: String &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;A show D&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">open</span> <span class="function"><span class="keyword">fun</span> <span class="title">show</span><span class="params">(obj: <span class="type">A</span>)</span></span>: String &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;A show A&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">open</span> <span class="keyword">class</span> <span class="title class_">B</span> : <span class="type">A</span>() &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">show</span><span class="params">(obj: <span class="type">B</span>)</span></span>: String &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;B show B&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">show</span><span class="params">(obj: <span class="type">A</span>)</span></span>: String &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;B show A&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span> : <span class="type">B</span>()</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">D</span> : <span class="type">B</span>()</span><br></pre></td></tr></table></figure><p>上述代码逻辑比较简单，定义了父类 <code>A</code> ，以及子类 <code>B</code>、<code>C</code>、<code>D</code>，<code>A</code> 中有两个方法，接下来请看考题：</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> a1: A = A()</span><br><span class="line"><span class="keyword">val</span> a2: A = B()</span><br><span class="line"><span class="keyword">val</span> b: B = B()</span><br><span class="line"><span class="keyword">val</span> c: C = C()</span><br><span class="line"><span class="keyword">val</span> d: D = D()</span><br><span class="line">println(a1.show(b)) <span class="comment">// 1</span></span><br><span class="line">println(a1.show(c)) <span class="comment">// 2</span></span><br><span class="line">println(a1.show(d)) <span class="comment">//3</span></span><br><span class="line">println(a2.show(b)) <span class="comment">// 4</span></span><br><span class="line">println(a2.show(c)) <span class="comment">// 5</span></span><br><span class="line">println(a2.show(d)) <span class="comment">// 6</span></span><br><span class="line">println(b.show(b)) <span class="comment">// 7</span></span><br><span class="line">println(b.show(c)) <span class="comment">// 8</span></span><br><span class="line">println(b.show(d)) <span class="comment">// 9</span></span><br></pre></td></tr></table></figure><p>1~9 的答案分别是多少呢？接下来一步一步分析。</p><p>解题 1：</p><blockquote><ol><li>注意 a1 的实例化对象是 <code>A()</code>，b 的实例化对象是 <code>B()</code>，那么 a1.show 方法调用的也就是 Class A 中的方法了；</li><li>接下来就看 <code>参数</code> 了，此处传递的对象为 <code>B</code>，查看方法，发现并没有 show(obj: B) 的方法，那么再找找有没有 <code>B</code> 的父类的方法，还真有 show(obj: A)，那么调用的方法也就是这里了；</li><li>在明确了 <strong>调用对象</strong> 和 <strong>输入参数</strong> 的情况下，答案就出来了：<strong>A show A</strong></li></ol></blockquote><p>解题 2：</p><blockquote><ol><li>注意 a1 的实例化对象是 <code>A()</code>，c 的实例化对象是 <code>C()</code>，那么 a1.show 方法调用的也就是 Class A 中的方法了；</li><li>接下来就看 <code>参数</code> 了，此处传递的对象为 <code>C</code>，查看方法，发现并没有 show(obj: C) 的方法，那么再找找有没有 <code>C</code> 的父类的方法，还真有 show(obj: A)，那么调用的方法也就是这里了；</li><li>在明确了 <strong>调用对象</strong> 和 <strong>输入参数</strong> 的情况下，答案就出来了：<strong>A show A</strong></li></ol></blockquote><p>解题 3：</p><blockquote><ol><li>注意 a1 的实例化对象是 <code>A()</code>，d 的实例化对象是 <code>D()</code>，那么 a1.show 方法调用的也就是 Class A 中的方法了；</li><li>接下来就看 <code>参数</code> 了，此处传递的对象为 <code>D</code>，查看方法，发现有 show(obj: D) 的方法，那么调用的方法也就是这里了；</li><li>在明确了 <strong>调用对象</strong> 和 <strong>输入参数</strong> 的情况下，答案就出来了：<strong>A show D</strong></li></ol></blockquote><p>解题 4：</p><blockquote><ol><li>注意 a2 的实例化对象是 <code>B()</code>，但是，a2 的声明类型是 <code>A</code>，b 的实例化对象是 <code>B()</code>，那么 a2.show 方法调用的也就是 Class B 中继承自 Class A 的方法了；</li><li>接下来就看 <code>参数</code> 了，此处传递的对象为 <code>B</code>，查看方法，发现有 show(obj: B) 的方法，<strong>但是</strong>，这个方法并不是重写父类中的方法，而是 <code>B</code> 独有的方法，因此，a2 是不知道有 show(obj: B) 存在的，接下来查找重写的方法，发现并没有 override fun show(obj: B)，再尝试查找 override fun show(obj: A)，发现有这个方法，那么调用的方法也就是这里了；</li><li>在明确了 <strong>调用对象</strong> 和 <strong>输入参数</strong> 的情况下，答案就出来了：<strong>B show A</strong></li></ol></blockquote><p>解题 5：</p><blockquote><ol><li>注意 a2 的实例化对象是 <code>B()</code>，但是，a2 的声明类型是 <code>A</code>，c 的实例化对象是 <code>C()</code>，那么 a2.show 方法调用的也就是 Class B 中的方法了；</li><li>接下来就看 <code>参数</code> 了，此处传递的对象为 <code>C</code>，查看方法，发现并没有 show(obj: C) 的方法，那么再找找有没有 <code>C</code> 的父类的方法，还真有 show(obj: A)，那么调用的方法也就是这里了；</li><li>在明确了 <strong>调用对象</strong> 和 <strong>输入参数</strong> 的情况下，答案就出来了：<strong>B show A</strong></li></ol></blockquote><p>解题 6：</p><blockquote><ol><li>注意 a2 的实例化对象是 <code>B()</code>，但是，a2 的声明类型是 <code>A</code>，d 的实例化对象是 <code>D()</code>，那么 a2.show 方法调用的也就是 Class B 中的方法了；</li><li>接下来就看 <code>参数</code> 了，此处传递的对象为 <code>D</code>，查看方法，发现并没有 show(obj: D) 的方法，那么再找找父类中有没有 <code>D</code> 的方法，还真有 show(obj: D)，那么调用的方法也就是这里了；</li><li>在明确了 <strong>调用对象</strong> 和 <strong>输入参数</strong> 的情况下，答案就出来了：<strong>A show D</strong></li></ol></blockquote><p>解题 7：</p><blockquote><ol><li>注意 b 的实例化对象是 <code>B()</code>，b 的实例化对象是 <code>B()</code>，那么 b.show 方法调用的也就是 Class B 中的方法了；</li><li>接下来就看 <code>参数</code> 了，此处传递的对象为 <code>B</code>，查看方法，发现有 show(obj: B) 的方法，那么调用的方法也就是这里了；</li><li>在明确了 <strong>调用对象</strong> 和 <strong>输入参数</strong> 的情况下，答案就出来了：<strong>B show B</strong></li></ol></blockquote><p>解题 8：</p><blockquote><ol><li>注意 b 的实例化对象是 <code>B()</code>，c 的实例化对象是 <code>C()</code>，那么 b.show 方法调用的也就是 Class B 中的方法了；</li><li>接下来就看 <code>参数</code> 了，此处传递的对象为 <code>C</code>，查看方法，发现并没有 show(obj: C) 的方法，那么再找找有没有 <code>C</code> 的父类的方法，还真有 show(obj: B)，那么调用的方法也就是这里了；</li><li>在明确了 <strong>调用对象</strong> 和 <strong>输入参数</strong> 的情况下，答案就出来了：<strong>B show B</strong></li></ol></blockquote><p>解题 9：</p><blockquote><ol><li>注意 b 的实例化对象是 <code>B()</code>，d 的实例化对象是 <code>D()</code>，那么 a2.show 方法调用的也就是 Class B 中的方法了；</li><li>接下来就看 <code>参数</code> 了，此处传递的对象为 <code>D</code>，查看方法，发现并没有 show(obj: D) 的方法，那么再找找父类中有没有 <code>D</code> 的方法，还真有 show(obj: D)，那么调用的方法也就是这里了；</li><li>在明确了 <strong>调用对象</strong> 和 <strong>输入参数</strong> 的情况下，答案就出来了：<strong>A show D</strong></li></ol></blockquote><p>虽然看起来很难，但是只要确定好 <strong>调用对象</strong>、<strong>输入参数</strong> 以后，就可以找到具体的调用方法，问题也就迎刃而解了，所以以后再遇到这类问题，可以做减法，将问题划分成一个个小问题点，分别求解，然后组合起来就行了。</p><p>带注释的代码如下，有兴趣的话可以自己尝试一下。</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> a1: A = A()</span><br><span class="line">    <span class="keyword">val</span> a2: A = B()</span><br><span class="line">    <span class="keyword">val</span> b: B = B()</span><br><span class="line">    <span class="keyword">val</span> c: C = C()</span><br><span class="line">    <span class="keyword">val</span> d: D = D()</span><br><span class="line">    println(a1.show(b)) <span class="comment">// A show A</span></span><br><span class="line">    println(a1.show(c)) <span class="comment">// A show A</span></span><br><span class="line">    println(a1.show(d)) <span class="comment">// A show D</span></span><br><span class="line">    println(a2.show(b)) <span class="comment">// B show A</span></span><br><span class="line">    println(a2.show(c)) <span class="comment">// B show A</span></span><br><span class="line">    println(a2.show(d)) <span class="comment">// A show D</span></span><br><span class="line">    println(b.show(b)) <span class="comment">// B show B</span></span><br><span class="line">    println(b.show(c)) <span class="comment">// B show B</span></span><br><span class="line">    println(b.show(d)) <span class="comment">// A show D</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Kotlin </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 封装 </tag>
            
            <tag> 继承 </tag>
            
            <tag> 多态 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>反射</title>
      <link href="/2020/12/03/Java/%E5%8F%8D%E5%B0%84/"/>
      <url>/2020/12/03/Java/%E5%8F%8D%E5%B0%84/</url>
      
        <content type="html"><![CDATA[<p>前面讲到了 <code>注解</code>，也自定义了 <code>注解</code> 来规约数据类型，避免传入错误数据，以及使用自定义 <code>注解</code> 检测机制，替代 <code>枚举</code>，降低内存开销。今天来讲讲 <code>注解</code> 结合 <code>反射</code> 的化学反应。</p><p>在结合使用之前，先来简单讲讲 <code>反射</code>。</p><h1 id="1-什么是反射"><a href="#1-什么是反射" class="headerlink" title="1. 什么是反射"></a>1. 什么是反射</h1><blockquote><p>Java 的反射（reflection）机制是指在程序的运行状态中，可以构造任意一个类的对象，可以了解任意一个对象所属的类，可以了解任意一个类的成员变量和方法，可以调用任意一个对象的属性和方法。这种动态获取程序信息以及动态调用对象的功能称为 Java 语言的反射机制。反射被视为动态语言的关键。</p></blockquote><h1 id="2-反射的主要作用"><a href="#2-反射的主要作用" class="headerlink" title="2. 反射的主要作用"></a>2. 反射的主要作用</h1><ol><li>在运行时判断任意一个对象所属的类；</li><li>在运行时构造任意一个类的对象；</li><li>在运行时判断任意一个类所具有的成员变量和方法；</li><li>在运行时调用任意一个对象的方法；</li><li>生成动态代理；</li></ol><h1 id="3-反射常用示例"><a href="#3-反射常用示例" class="headerlink" title="3. 反射常用示例"></a>3. 反射常用示例</h1><h2 id="3-1-获取-ClassLoader"><a href="#3-1-获取-ClassLoader" class="headerlink" title="3.1 获取 ClassLoader"></a>3.1 获取 ClassLoader</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1. 获取一个系统的类加载器（可以获取，当前这个类就是由它加载的）</span></span><br><span class="line"><span class="type">ClassLoader</span> <span class="variable">classLoader</span> <span class="operator">=</span> ClassLoader.getSystemClassLoader();</span><br><span class="line">System.out.println(classLoader);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 获取系统类加载器的父类加载器（扩展类加载器，可以获取）</span></span><br><span class="line">classLoader = classLoader.getParent();</span><br><span class="line">System.out.println(classLoader);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 获取扩展类加载器的父类加载器（引导类加载器，不可获取）</span></span><br><span class="line">classLoader = classLoader.getParent();</span><br><span class="line">System.out.println(classLoader);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4. 测试当前类由哪个类加载器加载（系统类加载器）</span></span><br><span class="line">classLoader = Class.forName(<span class="string">&quot;com.wd.reflect.ext.ClassLoaderTest&quot;</span>).getClassLoader();</span><br><span class="line">System.out.println(classLoader);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 5. 测试系统提供的 Object 类由哪个类加载器负责加载（引导类）</span></span><br><span class="line">classLoader = Class.forName(<span class="string">&quot;java.lang.Object&quot;</span>).getClassLoader();</span><br><span class="line">System.out.println(classLoader);</span><br></pre></td></tr></table></figure><h2 id="3-2-获取构造方法信息"><a href="#3-2-获取构造方法信息" class="headerlink" title="3.2 获取构造方法信息"></a>3.2 获取构造方法信息</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">className</span> <span class="operator">=</span> <span class="string">&quot;com.wd.reflect.ext.Child&quot;</span>;</span><br><span class="line"><span class="type">Class</span> <span class="variable">clazz</span> <span class="operator">=</span> Class.forName(className);</span><br><span class="line"><span class="comment">// 获取所有构造方法</span></span><br><span class="line">System.out.println(<span class="string">&quot;get construct method&quot;</span>);</span><br><span class="line">Constructor[] constructors = clazz.getConstructors();</span><br><span class="line"><span class="keyword">for</span> (Constructor item : constructors) &#123;</span><br><span class="line">    System.out.println(item);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取某一个 Constructor 对象</span></span><br><span class="line"><span class="type">Constructor</span> <span class="variable">constructor</span> <span class="operator">=</span> clazz.getConstructor(<span class="type">boolean</span>.class);</span><br><span class="line">System.out.println(constructor);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用构造器的 newInstance() 方法创建对象</span></span><br><span class="line"><span class="type">Child</span> <span class="variable">child</span> <span class="operator">=</span> (Child) constructor.newInstance(<span class="literal">false</span>);</span><br><span class="line">System.out.println(child.toString());</span><br></pre></td></tr></table></figure><h2 id="3-3-获取方法信息"><a href="#3-3-获取方法信息" class="headerlink" title="3.3 获取方法信息"></a>3.3 获取方法信息</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">className</span> <span class="operator">=</span> <span class="string">&quot;com.wd.reflect.ext.Child&quot;</span>;</span><br><span class="line"><span class="type">Class</span> <span class="variable">clazz</span> <span class="operator">=</span> Class.forName(className);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1. 获取类及其父类所有 public 方法</span></span><br><span class="line">Method[] methods = clazz.getMethods();</span><br><span class="line"><span class="keyword">for</span> (Method method : methods) &#123;</span><br><span class="line">    System.out.println(method);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">&quot;---------------&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 获取当前类的所有方法</span></span><br><span class="line">methods = clazz.getDeclaredMethods();</span><br><span class="line"><span class="keyword">for</span> (Method method : methods) &#123;</span><br><span class="line">    System.out.println(method);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">&quot;---------------&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 获取指定方法</span></span><br><span class="line"><span class="type">Method</span> <span class="variable">method</span> <span class="operator">=</span> clazz.getDeclaredMethod(<span class="string">&quot;privateChildMethod&quot;</span>);</span><br><span class="line">System.out.println(method);</span><br><span class="line">method.setAccessible(<span class="literal">true</span>);</span><br><span class="line">method.invoke(clazz.newInstance());</span><br></pre></td></tr></table></figure><h2 id="3-4-获取属性信息"><a href="#3-4-获取属性信息" class="headerlink" title="3.4 获取属性信息"></a>3.4 获取属性信息</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">className</span> <span class="operator">=</span> <span class="string">&quot;com.wd.reflect.ext.Child&quot;</span>;</span><br><span class="line"><span class="type">Class</span> <span class="variable">clazz</span> <span class="operator">=</span> Class.forName(className);</span><br><span class="line"><span class="type">Child</span> <span class="variable">child</span> <span class="operator">=</span> (Child) clazz.newInstance();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1. 获取类及其父类所有 public 属性</span></span><br><span class="line">Field[] fields = clazz.getFields();</span><br><span class="line"><span class="keyword">for</span> (Field field : fields) &#123;</span><br><span class="line">    System.out.println(field);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">&quot;---------------&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 获取当前类的所有属性</span></span><br><span class="line">fields = clazz.getDeclaredFields();</span><br><span class="line"><span class="keyword">for</span> (Field field : fields) &#123;</span><br><span class="line">    System.out.println(field);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">&quot;---------------&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 获取指定属性</span></span><br><span class="line"><span class="type">Field</span> <span class="variable">field</span> <span class="operator">=</span> clazz.getDeclaredField(<span class="string">&quot;privateChildField&quot;</span>);</span><br><span class="line">field.setAccessible(<span class="literal">true</span>);</span><br><span class="line"><span class="comment">// 输出属性值</span></span><br><span class="line">System.out.println(field.get(child));</span><br><span class="line"><span class="comment">// 修改属性值</span></span><br><span class="line">field.set(child, -<span class="number">1</span>);</span><br><span class="line">System.out.println(field.get(child));</span><br></pre></td></tr></table></figure><h1 id="4-反射结合注解"><a href="#4-反射结合注解" class="headerlink" title="4. 反射结合注解"></a>4. 反射结合注解</h1><p>前面讲了 <code>反射</code> 能动态的获取类的相关信息以及构件类，而 <code>注解</code> 能标记相关的信息，那么二者相结合，能实现什么效果呢？接下来结合案例进行分析。</p><p>场景：现有两个界面：MainActivity 和 SecondActivity，从 MainActivity 跳转到 SecondActivity 中时，需要携带 name、age 两个参数，通过注解的方式，动态获取参数。</p><h2 id="第一步：自定义注解"><a href="#第一步：自定义注解" class="headerlink" title="第一步：自定义注解"></a>第一步：自定义注解</h2><p><strong>注意：</strong>此处注解必须为 <code>运行时注解</code>，因为需要通过反射动态获取类型，如果不设置为运行时，在代码编译后，注解将会被抹除，无法使用；</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Target(AnnotationTarget.FIELD)</span></span><br><span class="line"><span class="meta">@Retention(AnnotationRetention.RUNTIME)</span></span><br><span class="line"><span class="keyword">annotation</span> <span class="keyword">class</span> <span class="title class_">AutoWired</span>(<span class="keyword">val</span> value: String = <span class="string">&quot;&quot;</span>)</span><br></pre></td></tr></table></figure><h2 id="第二步：MainActivity-和-SecondActivity-的创建以及跳转的实现"><a href="#第二步：MainActivity-和-SecondActivity-的创建以及跳转的实现" class="headerlink" title="第二步：MainActivity 和 SecondActivity 的创建以及跳转的实现"></a>第二步：MainActivity 和 SecondActivity 的创建以及跳转的实现</h2><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MainActivity</span> : <span class="type">ContainerActivity</span>&lt;<span class="type">MainFragment</span>&gt;() &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">getContentFragment</span><span class="params">()</span></span>: MainFragment = MainFragment()</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SecondActivity</span> : <span class="type">ContainerActivity</span>&lt;<span class="type">SecondFragment</span>&gt;() &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">getContentFragment</span><span class="params">()</span></span>: SecondFragment = SecondFragment()</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="第三步：通过反射自动注入传入的值，也是最关键的一步"><a href="#第三步：通过反射自动注入传入的值，也是最关键的一步" class="headerlink" title="第三步：通过反射自动注入传入的值，也是最关键的一步"></a>第三步：通过反射自动注入传入的值，也是最关键的一步</h2><p>首先：在 SecondFragment 中添加注解</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="meta">@AutoWired</span> <span class="comment">// 此处添加注解</span></span><br><span class="line"><span class="keyword">var</span> name: String = <span class="string">&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@AutoWired</span> <span class="comment">// 此处添加注解</span></span><br><span class="line"><span class="keyword">var</span> age: <span class="built_in">Int</span> = <span class="number">0</span></span><br></pre></td></tr></table></figure><p>其次：调用自动注入方法</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">AutoWiredUtil.inject(<span class="keyword">this</span>)</span><br></pre></td></tr></table></figure><p>然后：通过 <code>反射</code> 获取被 <code>注解</code> 标识过的属性，解析并注入值</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 通过反射获取到 Fragment 中的所有属性</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">inject</span><span class="params">(fragment: <span class="type">Fragment</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> fields = fragment.javaClass.declaredFields</span><br><span class="line">    <span class="keyword">if</span> (fields.isNullOrEmpty()) <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">val</span> extra = fragment.activity?.intent?.extras ?: <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">for</span> (item <span class="keyword">in</span> fields) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!item.isAnnotationPresent(AutoWired::<span class="keyword">class</span>.java)) <span class="keyword">continue</span></span><br><span class="line">        <span class="keyword">var</span> key = item.getDeclaredAnnotation(AutoWired::<span class="keyword">class</span>.java).value</span><br><span class="line">        <span class="keyword">if</span> (key.isNullOrEmpty()) key = item.name</span><br><span class="line">        item.isAccessible = <span class="literal">true</span></span><br><span class="line">        item.<span class="keyword">set</span>(fragment, extra.<span class="keyword">get</span>(key))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后：刷新界面数据，此处通过 DataBinding 绑定 LiveData 数据进行刷新</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">viewModel.name.postValue(name)</span><br><span class="line">viewModel.age.postValue(age)</span><br></pre></td></tr></table></figure><p>如果属性过多的情况下，会省略很多 xxx.getIntent().getXXXExtra 方法，也能避免自己忘记手动获取，即提高了效率，也降低了出错的概率，何乐而不为呢。</p><h1 id="5-反射为何慢"><a href="#5-反射为何慢" class="headerlink" title="5. 反射为何慢"></a>5. 反射为何慢</h1><p>最常听说的就是 <strong>反射慢</strong>、<strong>反射性能低</strong>，那么反射为什么会有这种情况呢，接下来简单了解一下。</p><h2 id="5-1-JVM-无法优化反射代码"><a href="#5-1-JVM-无法优化反射代码" class="headerlink" title="5.1 JVM 无法优化反射代码"></a>5.1 JVM 无法优化反射代码</h2><p>反射作为动态语言的特征，使用反射前，系统是无法知道具体要反射的类的信息的，因此也就无法进行优化，所以感觉会慢。</p><h2 id="5-2-Class-forName-比较耗时"><a href="#5-2-Class-forName-比较耗时" class="headerlink" title="5.2 Class.forName 比较耗时"></a>5.2 Class.forName 比较耗时</h2><p>这一点可以参考源码，是 native 代码，中间需要做很多检查、容错性处理，导致较耗性能。</p><h2 id="5-3-遍历-Field、Method-耗时"><a href="#5-3-遍历-Field、Method-耗时" class="headerlink" title="5.3 遍历 Field、Method 耗时"></a>5.3 遍历 Field、Method 耗时</h2><p>如果有上百个 Field、Method，只需要使用其中一个，遍历过程就是一个耗时过程。</p><h2 id="5-4-invoke-耗时"><a href="#5-4-invoke-耗时" class="headerlink" title="5.4 invoke 耗时"></a>5.4 invoke 耗时</h2><p>invoke 调用比正常调用方法多了很多中间步骤，导致耗时的产生。</p><p>最后，示例项目地址信息 <a href="https://github.com/WalkerDenial/KotlinStudy">示例代码</a>，欢迎交流学习，如果错误，请指正。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Kotlin </tag>
            
            <tag> Android </tag>
            
            <tag> Java </tag>
            
            <tag> 反射 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>注解</title>
      <link href="/2020/11/30/Java/%E6%B3%A8%E8%A7%A3/"/>
      <url>/2020/11/30/Java/%E6%B3%A8%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<p>在编码中，经常使用到 <code>注解</code>，例如：@Nullable、@LayoutRes、@ColorRes 等等，为工程开发提供了极大的便捷性，那么今天就来扒一扒 <code>注解</code>。</p><h1 id="1、-注解在-Java-中的定义"><a href="#1、-注解在-Java-中的定义" class="headerlink" title="1、 注解在 Java 中的定义"></a>1、 注解在 Java 中的定义</h1><blockquote><p>Java 注解（Annotation）又称为 Java 标注，是 JDK1.5 引入的一种注释机制。是元数据的一种形式，提供有关于程序但不属于程序本身的数据。注解对它们注解的代码的操作没有直接影响。</p></blockquote><h2 id="2、注解扒皮"><a href="#2、注解扒皮" class="headerlink" title="2、注解扒皮"></a>2、注解扒皮</h2><p>是不是有点绕？简单来讲，<code>注解</code> 就是一种注释，提供标注功能，但是对所标注的代码没有任何影响，例如自定义一个注解：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Retention(RetentionPolicy.SOURCE)</span> <span class="comment">// 元注解</span></span><br><span class="line"><span class="meta">@Target(ElementType.METHOD)</span> <span class="comment">// 元注解</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> WD &#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在此处自定义了一个注解 <code>WD</code>，使用如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@WD</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">annotationTest</span><span class="params">()</span> &#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>就这么简单，一个 <code>注解</code> 就诞生了，<strong>但是</strong> 这个 <code>注解</code> 并没有什么用，你没看错，就是一个标记而已，但是没有任何实质作用。</p><p>Emmm… 平常不是经常用注解嘛，都是有作用的啊，这是不是一个假注解呢？</p><p>不存在的，这就是货真价实的真注解，我们再深一步，扒一扒和平常用的注解有什么不同。先来分析一下 <a href="https://github.com/JakeWharton/butterknife">ButterKnife</a> 的使用：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">implementation <span class="string">&#x27;com.jakewharton:butterknife:10.2.3&#x27;</span></span><br><span class="line">annotationProcessor <span class="string">&#x27;com.jakewharton:butterknife-compiler:10.2.3&#x27;</span></span><br></pre></td></tr></table></figure><p>第一行引入，项目工程打开一看，跟上面自定义的 <code>注解</code> 一模一样，也就证明了，自定义的注解是没有问题的，但是，我们没有第二行代码，那么，问题就很明确了，区别在第二行代码上。</p><p>第二行代码的本质就是通过 APT 技术，动态生成代码，也是 ButterKnife 动态生成 Java 文件的核心。所以，学习 <code>注解</code> 同时，也要结合 <code>反射</code>、<code>APT</code> 等技术手段，让注解变得更有意义，如果只是单纯的 <code>注解</code>，那么跟注释的差别不会太大。<code>注解</code> 的主要作用是：可以通过反射获取标注内容。</p><h1 id="3、概念介绍"><a href="#3、概念介绍" class="headerlink" title="3、概念介绍"></a>3、概念介绍</h1><p>Java 定义了一套注解，共有 10 个，3 个在 java.lang 中，剩下 4 个在 java.lang.annotation 中。</p><h2 id="3-1-作用在代码的注解是"><a href="#3-1-作用在代码的注解是" class="headerlink" title="3.1 作用在代码的注解是"></a>3.1 作用在代码的注解是</h2><ol><li>@Override - 检查该方法是否是重写方法。如果发现其父类，或者是引用的接口中并没有该方法时，会报编译错误。</li><li>@Deprecated - 标记过时方法。如果使用该方法，会报编译警告。</li><li>@SuppressWarnings - 指示编译器去忽略注解中声明的警告。</li></ol><h2 id="3-2-作用在其他注解的注解-或者说-元注解-是"><a href="#3-2-作用在其他注解的注解-或者说-元注解-是" class="headerlink" title="3.2 作用在其他注解的注解(或者说 元注解)是:"></a>3.2 作用在其他注解的注解(或者说 元注解)是:</h2><ol><li>@Retention - 标识这个注解怎么保存，是只在代码中，还是编入class文件中，或者是在运行时可以通过反射访问。</li><li>@Documented - 标记这些注解是否包含在用户文档中。</li><li>@Target - 标记这个注解应该是哪种 Java 成员。</li><li>@Inherited - 标记这个注解是继承于哪个注解类(默认 注解并没有继承于任何子类)</li></ol><h2 id="3-3-从-Java-7-开始，额外添加了-3-个注解"><a href="#3-3-从-Java-7-开始，额外添加了-3-个注解" class="headerlink" title="3.3 从 Java 7 开始，额外添加了 3 个注解:"></a>3.3 从 Java 7 开始，额外添加了 3 个注解:</h2><ol><li>@SafeVarargs - Java 7 开始支持，忽略任何使用参数为泛型变量的方法或构造函数调用产生的警告。</li><li>@FunctionalInterface - Java 8 开始支持，标识一个匿名函数或函数式接口。</li><li>@Repeatable - Java 8 开始支持，标识某注解可以在同一个声明上使用多次。</li></ol><h1 id="4、注解的应用场景"><a href="#4、注解的应用场景" class="headerlink" title="4、注解的应用场景"></a>4、注解的应用场景</h1><table><thead><tr><th align="center">级别</th><th align="center">技术</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">源码</td><td align="center">APT</td><td align="center">在编译期能够获取注解与注解声明的类，包括类中所有成员信息，一般用于生产额外的辅助类。</td></tr><tr><td align="center">字节码</td><td align="center">字节码增强</td><td align="center">在编译出 class 文件后，通过修改 class 数据以实现修改代码逻辑目的。对于是否需要修改的区分或者修改为不同逻辑的判断可以使用注解。</td></tr><tr><td align="center">运行时</td><td align="center">反射</td><td align="center">在程序运行期间，通过反射技术动态获取注解与其元素，从而完成不同的逻辑判定。</td></tr></tbody></table><h1 id="5、注解-IntDef-使用"><a href="#5、注解-IntDef-使用" class="headerlink" title="5、注解 IntDef 使用"></a>5、注解 IntDef 使用</h1><p>IntDef 顾名思义就是对 Int 数据进行规约的，比如我们常用的 view.setBackgroundResource(xxx)，此处 xxx 为 int 类型，但是如果我们随便传入一个 int 类型进去，会发现编译器报错，这里就是类似 IntDef 的功劳，编译器帮我们检查数据是否合法，从而避免很多不必要的错误。以往，为了确保数据唯一，我们常常使用 <code>枚举</code> 来进行规约，但是随着项目增大，枚举会很多很多，导致内存开销也比较大，为了优化性能，可以考虑尝试使用 IntDef 解解毒。</p><p>先看一下 <code>枚举</code> 的写法：</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 列举周几信息</span></span><br><span class="line"><span class="comment"> * 常规写法：枚举</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 列举周几信息</span></span><br><span class="line"><span class="comment"> * 常规写法：枚举</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">enum</span> <span class="keyword">class</span> <span class="title class_">Weeks</span> &#123;</span><br><span class="line">    MONDAY,</span><br><span class="line">    TUESDAY,</span><br><span class="line">    WEDNESDAY,</span><br><span class="line">    THURSDAY,</span><br><span class="line">    FRIDAY,</span><br><span class="line">    SATURDAY,</span><br><span class="line">    SUNDAY</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后，我们再看一下对应的字节码：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">enum</span> <span class="title class_">com</span>/wd/kt/annotation/Weeks <span class="keyword">extends</span> <span class="title class_">java</span>/lang/Enum &#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// access flags 0x4019</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">enum</span> <span class="title class_">Lcom</span>/wd/kt/annotation/Weeks; MONDAY</span><br><span class="line"></span><br><span class="line">  <span class="comment">// access flags 0x4019</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">enum</span> <span class="title class_">Lcom</span>/wd/kt/annotation/Weeks; TUESDAY</span><br><span class="line"></span><br><span class="line">  <span class="comment">// access flags 0x4019</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">enum</span> <span class="title class_">Lcom</span>/wd/kt/annotation/Weeks; WEDNESDAY</span><br><span class="line"></span><br><span class="line">  <span class="comment">// access flags 0x4019</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">enum</span> <span class="title class_">Lcom</span>/wd/kt/annotation/Weeks; THURSDAY</span><br><span class="line"></span><br><span class="line">  <span class="comment">// access flags 0x4019</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">enum</span> <span class="title class_">Lcom</span>/wd/kt/annotation/Weeks; FRIDAY</span><br><span class="line"></span><br><span class="line">  <span class="comment">// access flags 0x4019</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">enum</span> <span class="title class_">Lcom</span>/wd/kt/annotation/Weeks; SATURDAY</span><br><span class="line"></span><br><span class="line">  <span class="comment">// access flags 0x4019</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">enum</span> <span class="title class_">Lcom</span>/wd/kt/annotation/Weeks; SUNDAY</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 其余代码省略，有兴趣的同学可以自己生成字节码查看一下</span></span><br></pre></td></tr></table></figure><p>我们看到，字节码生成了 7 个对象用来表述星期信息，而对象的开销又比较大，从而会增加应用开销，从字节码也能看出，为什么 <code>枚举</code> 开销会比较大了，这里只有 7 个枚举，对应 7 个对象，那么如果 700 个枚举呢？7000 个呢？所以，寻找一种替代办法还是很有必要的。</p><p>接下来，我们看一下另一种写法，IntDef 写法：</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="meta">@IntDef(MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY, SATURDAY, SUNDAY)</span></span><br><span class="line"><span class="meta">@Target(AnnotationTarget.FIELD, AnnotationTarget.TYPE_PARAMETER, AnnotationTarget.VALUE_PARAMETER)</span></span><br><span class="line"><span class="meta">@Retention(AnnotationRetention.SOURCE)</span></span><br><span class="line"><span class="keyword">annotation</span> <span class="keyword">class</span> <span class="title class_">WeekDays</span></span><br></pre></td></tr></table></figure><p>此处设置了 <strong>注解</strong> WeekDays，再看看如何使用的：</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">showWeek</span><span class="params">(<span class="meta">@WeekDays</span> day: <span class="type">Int</span>)</span></span> &#123;</span><br><span class="line">    print(day)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">test</span><span class="params">()</span></span> &#123;</span><br><span class="line">    showWeek(<span class="number">99</span>) <span class="comment">// Java 版本此处编译器会直接报错，Kotlin 目前还存在问题</span></span><br><span class="line">    showWeek(THURSDAY) <span class="comment">// 只有限定范围内的数据，传入才能通过编译</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里只是定义了 7 个常量，开销比对象小多了，达到了优化的目的。</p><p>综上所述，在要使用枚举的时候，看看能不能使用 <code>IntDef</code>、<code>StringDef</code> 替代，从而降低内存的开销。</p>]]></content>
      
      
      <categories>
          
          <category> Kotlin </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Kotlin </tag>
            
            <tag> Android </tag>
            
            <tag> Java </tag>
            
            <tag> 注解 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MarkDown 介绍</title>
      <link href="/2020/11/16/%E5%85%B6%E4%BB%96/MarkDown%20%E4%BB%8B%E7%BB%8D/"/>
      <url>/2020/11/16/%E5%85%B6%E4%BB%96/MarkDown%20%E4%BB%8B%E7%BB%8D/</url>
      
        <content type="html"><![CDATA[<h1 id="MarkDown-介绍"><a href="#MarkDown-介绍" class="headerlink" title="MarkDown 介绍"></a>MarkDown 介绍</h1><h2 id="一、认识-MarkDown"><a href="#一、认识-MarkDown" class="headerlink" title="一、认识 MarkDown"></a>一、认识 MarkDown</h2><p>什么是 <strong>MarkDown</strong> ?</p><p><strong>MarkDown</strong> 是一种 <strong>轻量级的标记语言</strong> ，可以使用普通文本编辑器编写的语言。通过简单的标记语法，使普通的文本具有一定的格式。</p><p><strong>MarkDown</strong> 的优点在于，它用简洁的语法代替了排版。而不像一般我们用的处理软件 <strong>Word</strong> 或 <strong>Pages</strong> 有大量的排版、字体设置。它使我们专注于内容的编写。</p><p><strong>MarkDown</strong> 不仅支持文字排版，还支持插入 <strong>图片</strong>、<strong>链接</strong>、<strong>视频</strong>、<strong>音频</strong> 等。而这些操作我们都可以只使用键盘完成。</p><h3 id="MarkDown-优点"><a href="#MarkDown-优点" class="headerlink" title="MarkDown 优点"></a>MarkDown 优点</h3><ol><li>使我们专注于内容，而不用再去使用鼠标进行排版；</li><li>可以导出为 <code>PDF</code>、<code>HTML</code> 以及 <code>.md</code> 本身的格式文件；</li><li>上手简单。</li></ol><h2 id="二、MacDown-编辑器"><a href="#二、MacDown-编辑器" class="headerlink" title="二、MacDown 编辑器"></a>二、MacDown 编辑器</h2><p><strong>在线 MacDown 编辑器</strong></p><p>现在多个论坛或者博客都支持 <code>MarkDown</code> 语法，例如：<a href="http://www.csdn.net/">CSDN</a>、<a href="http://www.jianshu.com/">简书</a> 等。</p><p>MAC 系统专用的 MarkDown 编辑器为 <a href="http://macdown.uranusjr.com/"><code>MacDown</code></a></p><p><strong>MacDown</strong> 是一款既简单又容易使用的 MarkDown 编辑器。<br><strong>MacDown</strong> 既可以把内容导出为 HTML 文件、PSD 文件，还可以实时预览。</p><p>比如：左边是内容，右边是实时预览。</p><h3 id="MacDown-特性"><a href="#MacDown-特性" class="headerlink" title="MacDown 特性"></a>MacDown 特性</h3><ul><li>支持原始的 MarkDown 语言，并且有更多功能</li><li>支持实时预览</li></ul><h2 id="三、常用语法"><a href="#三、常用语法" class="headerlink" title="三、常用语法"></a>三、常用语法</h2><h3 id="换行"><a href="#换行" class="headerlink" title="换行"></a>换行</h3><hr><p>在 MarkDown 语法中，使用 <code>两个空格 + 回车</code> 换行  </p><p>空格 空格 + 回车</p><p>或者使用 <code>两个回车</code> 换行</p><p>回车回车</p><h3 id="标题"><a href="#标题" class="headerlink" title="标题"></a>标题</h3><hr><p>标题有两种方式</p><ol><li><h1 id="使用文字-一行-号，表示-1-级标题，文字-一行-减号，2-级标题；-一级标题"><a href="#使用文字-一行-号，表示-1-级标题，文字-一行-减号，2-级标题；-一级标题" class="headerlink" title="使用文字 + 一行 = 号，表示 1 级标题，文字 + 一行 --- 减号，2 级标题； 一级标题"></a>使用文字 + 一行 <code>=</code> 号，表示 1 级标题，文字 + 一行 <code>---</code> 减号，2 级标题；<br> 一级标题</h1><h2 id="二级标题"><a href="#二级标题" class="headerlink" title=" 二级标题"></a> 二级标题</h2></li><li><p>多个 <code>#</code> 号 + 文字</p><pre><code> # 标题 ## 标题 ### 标题 #### 标题 #### 标题</code></pre></li></ol><p>通常我们使用 <code>#</code> 号来标记标题等级，如下所示：</p><h1 id="Header-1"><a href="#Header-1" class="headerlink" title="Header 1"></a>Header 1</h1><h2 id="Header-2"><a href="#Header-2" class="headerlink" title="Header 2"></a>Header 2</h2><h3 id="Header-3"><a href="#Header-3" class="headerlink" title="Header 3"></a>Header 3</h3><h4 id="Header-4"><a href="#Header-4" class="headerlink" title="Header 4"></a>Header 4</h4><h5 id="Header-5"><a href="#Header-5" class="headerlink" title="Header 5"></a>Header 5</h5><h6 id="Header-6"><a href="#Header-6" class="headerlink" title="Header 6"></a>Header 6</h6><h3 id="文本样式"><a href="#文本样式" class="headerlink" title="文本样式"></a>文本样式</h3><hr><ul><li><strong>粗体</strong> <code>**</code> 粗体 <code>**</code></li><li><em>斜体</em> <code>*</code> 斜体 <code>*</code></li><li><del>删除线</del> <code>~~</code> 删除线 <code>~~</code></li><li>&#x3D;&#x3D;高亮&#x3D;&#x3D; <code>==</code> 高亮 <code>==</code></li><li>段落 段落与段落之间一定要空一行</li><li>水平线 <code>--</code> 两个减号表示实现， <code>---</code> 三个减号表示虚线</li></ul><h2 id="–"><a href="#–" class="headerlink" title="–"></a>–</h2><h3 id="图片"><a href="#图片" class="headerlink" title="图片"></a>图片</h3><hr><p>插入图片格式： <code>![图片说明](图片链接)</code></p><p>图片链接可以为本地连接，也可以为网络链接。</p><p>本地连接，需要在 <code>()</code> 小括号里面需要填写图片在本地的地址。</p><p>图片路径：</p><blockquote><p>&#x2F;images&#x2F;coverpic.png</p></blockquote><p><img src="/../../../../../images/coverpic.png" alt="本地图片链接"></p><p>如果是网络图片链接，小括号里面直接填写图片的网络链接即可。</p><p>例如：网络图片</p><p><img src="https://personal-blog.oss-cn-hangzhou.aliyuncs.com/img_nature.jpg" alt="网络图片"></p><h3 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h3><hr><p>引用内容使用右尖括号 <code>&gt;</code> + 文字，支持多级引用，使用多个右尖括号 <code>&gt;</code>，表示多级引用。</p><blockquote><p>这里是引用内容</p><blockquote><p>二级引用</p><blockquote><p>三级引用</p></blockquote></blockquote></blockquote><h3 id="插入代码"><a href="#插入代码" class="headerlink" title="插入代码"></a>插入代码</h3><hr><p>MarkDown 支持插入代码，使用三个上点号 ``` 开头，和三个上点号结尾 ```，代码放在中间，例如：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">System.out.println(<span class="string">&quot;MacDown&quot;</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;MarkDown&quot;</span>);</span><br></pre></td></tr></table></figure><h3 id="插入表格"><a href="#插入表格" class="headerlink" title="插入表格"></a>插入表格</h3><hr><p>MarkDown 插入表格，使用以下语法：<code>|列名|</code> <code>|:----:|</code> 水平排列模式。</p><p><code>| :--- |</code> 居左，<code>| :---: |</code> 居中， <code>| ---: |</code> 居右。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">| 列1 | 列2 | 列3 |</span><br><span class="line">|:--- |:---:|---:|</span><br><span class="line">| 居左 | 居中 | 居右 |</span><br></pre></td></tr></table></figure><table><thead><tr><th align="left">单元格1</th><th align="center">单元格2</th><th align="right">单元格3</th></tr></thead><tbody><tr><td align="left">居左</td><td align="center">居中</td><td align="right">居右</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> 其他 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MarkDown </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>泛型</title>
      <link href="/2020/11/15/Java/%E6%B3%9B%E5%9E%8B/"/>
      <url>/2020/11/15/Java/%E6%B3%9B%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<p>A：今天来聊聊一些基础吧，简单说说泛型。</p><p>B：泛型不是一直在用嘛，很简单的啊，一对 <code>&lt;&gt;</code> 就能指定泛型，然后使用。</p><p>A：那你先讲讲什么叫泛型吧？</p><p>B：Emmm…（一时语塞，虽然一直在用，但是一时语塞，组织不起来语言）。</p><p>A：概念不清，意识模糊，只是停留在会用阶段，却不知道本质。</p><p>B：（假装一时忘记了而已）</p><p>A：既然经常使用泛型，那么应该知道泛型擦除机制吧。</p><p>B：这个我知道的，很简单嘛，为了兼容 JDK5 以前的版本。</p><p>A：既然在编译时，会有泛型擦除机制，那么在编译打包后，例如：Gson 又是怎么能正确解析成指定的泛型类呢？按照前面所说，泛型擦除了啊。</p><p>B：Emmm… 彻底蒙圈</p><p><code>泛型</code>，作为一枚野生 Android 搬砖工，最常用的莫过于 <code>泛型</code>，在所有的架构中，<code>泛型</code> 是核心，所以说：<code>泛型</code> 是通往高阶的基础。哪怕你调用第三方框架再熟练，也只是个熟练的 API 调用者而已，出个问题就无法解决，只会甩锅给三方库，但是问题还是得不到解决。所以，在成长的路上，首先要彻底了解并掌握 <code>泛型</code>，只有这样，才能不至于在后期举步维艰。</p><h1 id="1、先了解一下泛型是什么"><a href="#1、先了解一下泛型是什么" class="headerlink" title="1、先了解一下泛型是什么"></a>1、先了解一下泛型是什么</h1><p>先看一下 <a href="https://bk.tw.lvfukeji.com/baike-%E6%B3%9B%E5%9E%8B">维基百科</a> 的定义：</p><blockquote><p>泛型的定义主要有以下两种：</p></blockquote><blockquote><ol><li>在程序编码中一些包含类型参数的类型，也就是说泛型的参数只可以代表類，不能代表个别对象。（这是当今常见的定义）</li></ol></blockquote><blockquote><ol start="2"><li>在程序编码中一些包含参数的类。其参数可以代表类或对象等等。（现在人们大多把这称作模板）</li></ol></blockquote><p>在下定义之前，再了解一下参数分类，一般情况下，参数分为以下两类：</p><ol><li>形式参数：输入是值；</li><li>类型参数：输入是类型；</li></ol><p>接下来，结合代码进行简单介绍分析（已经了解的可跳过）。</p><h2 id="1-1-形式参数"><a href="#1-1-形式参数" class="headerlink" title="1.1 形式参数"></a>1.1 形式参数</h2><p>在工作中，经常编写的就是方法，例如：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 其中，a、b 都是形式参数，传入的是已经构建好的对象（Java 一切皆对象）</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">add</span> <span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123; </span><br><span class="line"><span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>根据方法本质来说，需要使用到传入的对象的某个值来进行相应的加工处理，这就是形式参数，简称 <code>形参</code>；</p><h2 id="1-2-类型参数"><a href="#1-2-类型参数" class="headerlink" title="1.2 类型参数"></a>1.2 类型参数</h2><p>处理需要值以外，有时候还需要指定类型，例如：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br></pre></td></tr></table></figure><p>在 <code>&lt;&gt;</code> 中，有一个类型 <strong>String</strong>，注意，是 <strong>类型</strong> 哟，而不是对象，至于原因吗，好好想想…再想想，这个 <strong>String</strong> 你实例化了吗，现在能理解 <strong>对象</strong> 和 <strong>类型</strong> 的区别了吧，<code>&lt;String&gt;</code> 的目的就是为了告诉编译器，在这个 <code>List</code> 中，指定的是 <code>String</code> 类型的，只能对 <code>String</code> 类型的对象进行处理，不信的话你可以调用 <code>list.add(0)</code> 试试，看看会不会报错，至于原因，后续会讲。</p><p>由上可知，泛型是 <strong>类型化参数</strong>。</p><h1 id="2、为什么要使用泛型"><a href="#2、为什么要使用泛型" class="headerlink" title="2、为什么要使用泛型"></a>2、为什么要使用泛型</h1><ol><li>在编译期进行更强的类型检查；</li><li>消除类型转换；</li><li>能够实现通用算法；</li></ol><p>接下来，逐步进行解释：</p><h2 id="2-1-在编译期进行更强的类型检查"><a href="#2-1-在编译期进行更强的类型检查" class="headerlink" title="2.1 在编译期进行更强的类型检查"></a>2.1 在编译期进行更强的类型检查</h2><p>Talk is cheap, show me the code. 先上一段毒代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 一个用于存储 int 数据的集合</span></span><br><span class="line"><span class="type">List</span> <span class="variable">list</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">list.add(<span class="number">1</span>);</span><br><span class="line">list.add(<span class="number">2</span>);</span><br><span class="line">list.add(<span class="number">3</span>);</span><br><span class="line">list.add(<span class="string">&quot;4&quot;</span>); <span class="comment">// 失误操作</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; list.size(); i++) &#123;</span><br><span class="line"><span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> (<span class="type">int</span>) list.get(<span class="number">3</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;num is &quot;</span> + num);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于没有类型约束，编译器不会报错，但是，在运行时，程序会直接崩溃，并报 <code>ClassCastException</code>，这要是发生在线上，就是生产事故了。那么如何在编译器就能检测出这个错误呢，这就该 <code>泛型</code> 登场了，修改代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 一个用于存储 int 数据的集合</span></span><br><span class="line"><span class="type">List</span> <span class="variable">list</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;();</span><br><span class="line">list.add(<span class="number">1</span>);</span><br><span class="line">list.add(<span class="number">2</span>);</span><br><span class="line">list.add(<span class="number">3</span>);</span><br><span class="line">list.add(<span class="string">&quot;4&quot;</span>); <span class="comment">// 此次会直接报错，编译无法通过</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="variable">num4</span> <span class="operator">=</span> ist.get(<span class="number">3</span>); <span class="comment">// 同时，这里没有强转了</span></span><br></pre></td></tr></table></figure><p>在约定类型后， list 只能添加对应的类型，也就是示例代码中的 <code>Integer</code>，如果传入 <code>String</code>，是无法通过编译的，这样就将错误由 <strong>运行时错误</strong> 提前为 <strong>编译时错误</strong>，并且在多人合作时，也不用担心其他小伙伴添加错误的类型对象。</p><h2 id="2-2-消除类型转换"><a href="#2-2-消除类型转换" class="headerlink" title="2.2 消除类型转换"></a>2.2 消除类型转换</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">List</span> <span class="variable">list</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">list.add(<span class="number">1</span>);</span><br><span class="line"><span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> (<span class="type">int</span>) list.get(<span class="number">3</span>); <span class="comment">//由于 List 未指定类型，系统无法得知 get 后的类型，因此，需要进行强转</span></span><br><span class="line"></span><br><span class="line"><span class="type">List</span> <span class="variable">list</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;();</span><br><span class="line">list.add(<span class="number">1</span>);</span><br><span class="line"><span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> list.get(<span class="number">0</span>); <span class="comment">// 由于指定了类型 `Integer`，系统会推断出对应的类型，可以省去强转，也可避免强转成错误的类型，提高了代码的健壮性</span></span><br></pre></td></tr></table></figure><h2 id="2-3-能够实现通用算法"><a href="#2-3-能够实现通用算法" class="headerlink" title="2.3 能够实现通用算法"></a>2.3 能够实现通用算法</h2><p>没有泛型以前的 <code>add</code> 世界：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">double</span> <span class="title function_">add</span> <span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line"><span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="type">double</span> <span class="title function_">add</span> <span class="params">(<span class="type">float</span> a, <span class="type">float</span> b)</span> &#123;</span><br><span class="line"><span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="type">double</span> <span class="title function_">add</span> <span class="params">(<span class="type">double</span> a, <span class="type">double</span> b)</span> &#123;</span><br><span class="line"><span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="type">double</span> <span class="title function_">add</span> <span class="params">(<span class="type">long</span> a, <span class="type">long</span> b)</span> &#123;</span><br><span class="line"><span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="type">double</span> <span class="title function_">add</span> <span class="params">(<span class="type">byte</span> a, <span class="type">byte</span> b)</span> &#123;</span><br><span class="line"><span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="type">double</span> <span class="title function_">add</span> <span class="params">(<span class="type">short</span> a, <span class="type">short</span> b)</span> &#123;</span><br><span class="line"><span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 如果根据排列组合来写，方法数量只会呈指数级增长</span></span><br></pre></td></tr></table></figure><p>居然要写 6 个方法，才能实现兼容，使用泛型之后的世界：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;N <span class="keyword">extends</span> <span class="title class_">Number</span>&gt; <span class="type">double</span> <span class="title function_">add</span><span class="params">(N a, N b)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> a.doubleValue() + b.doubleValue();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于使用了泛型，方法数量减少为 1 个，实现了代码复用。因此，掌握好泛型，是通往高阶之路的基础。</p><h1 id="3、泛型分类"><a href="#3、泛型分类" class="headerlink" title="3、泛型分类"></a>3、泛型分类</h1><ol><li>泛型类</li><li>泛型接口</li><li>泛型方法</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 泛型类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Box</span>&lt;T&gt; &#123;</span><br><span class="line"><span class="keyword">public</span> T t;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 泛型接口</span></span><br><span class="line">pubclic <span class="keyword">interface</span> <span class="title class_">Box</span>&lt;T&gt;&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 泛型方法</span></span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="keyword">void</span> <span class="title function_">test</span><span class="params">(T t)</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="4、常用的类型参数名称"><a href="#4、常用的类型参数名称" class="headerlink" title="4、常用的类型参数名称"></a>4、常用的类型参数名称</h1><ol><li>E –&gt; Element</li><li>K –&gt; Key</li><li>N –&gt; Number</li><li>T –&gt; Type</li><li>V –&gt; Value</li><li>S、U、V etc –&gt; 2nd、3rd、4th types</li></ol><p>只是一些共识，代表指定什么意思，跟着用就对了，如果你想特立独行，那…也不是不可以。</p><h1 id="5、泛型扩展"><a href="#5、泛型扩展" class="headerlink" title="5、泛型扩展"></a>5、泛型扩展</h1><p>在很多需求中，泛型 <code>&lt;&gt;</code> 中的类型可能不是一个确定的类型，那么能不能不指定具体类型，比如某一个类的父类，以便后续扩展呢接下来，答案是肯定的，接下来，将介绍一下 <code>受限通配符</code> 和 <code>非受限通配符</code>，从而让泛型也具有可扩展性。</p><h2 id="5-1-继承"><a href="#5-1-继承" class="headerlink" title="5.1 继承"></a>5.1 继承</h2><h3 id="5-1-1-接口的继承"><a href="#5-1-1-接口的继承" class="headerlink" title="5.1.1 接口的继承"></a>5.1.1 接口的继承</h3><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">GenericInterface</span>&lt;<span class="type">T</span>&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 接口继承方式一</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">GenericChildInterface1</span>&lt;<span class="type">T</span>&gt; : <span class="type">GenericInterface</span>&lt;<span class="type">T</span>&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 接口继承方式二</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">GenericChildInterface2</span> : <span class="type">GenericInterface</span>&lt;<span class="type">String</span>&gt;</span><br></pre></td></tr></table></figure><p>比较简单，就不过多介绍了。</p><h3 id="5-1-2-类的继承"><a href="#5-1-2-类的继承" class="headerlink" title="5.1.2 类的继承"></a>5.1.2 类的继承</h3><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">open</span> <span class="keyword">class</span> <span class="title class_">GenericClass</span>&lt;<span class="type">T</span>&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 泛型继承方式一</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">GenericChildClass1</span>&lt;<span class="type">T</span>&gt; : <span class="type">GenericClass</span>&lt;<span class="type">T</span>&gt;()</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 泛型继承方式二</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">GenericChildClass2</span> : <span class="type">GenericClass</span>&lt;<span class="type">String</span>&gt;()</span><br></pre></td></tr></table></figure><p>也比较简单，看一眼即可。</p><h3 id="5-1-3-多继承"><a href="#5-1-3-多继承" class="headerlink" title="5.1.3 多继承"></a>5.1.3 多继承</h3><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">open</span> <span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line"><span class="keyword">open</span> <span class="keyword">class</span> <span class="title class_">B</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">C</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">D</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 错误写法</span></span><br><span class="line"><span class="comment"> * 原因：注意单继承，这里 A、B 都是 class，同时继承多个 class，违背单继承原则，无法编译通过</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MultipleGenericClass1</span>&lt;<span class="type">T : A, B, C, D</span>&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 错误写法</span></span><br><span class="line"><span class="comment"> * 原因：注意继承规则，如果存在 class，那么 class 一定要排在前面</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MultipleGenericClass2</span>&lt;<span class="type">T : C, A, D</span>&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 正确写法</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MultipleGenericClass3</span>&lt;<span class="type">T : A, C, D</span>&gt;</span><br></pre></td></tr></table></figure><p>看注释即可。</p><h2 id="5-2-通配符"><a href="#5-2-通配符" class="headerlink" title="5.2 通配符"></a>5.2 通配符</h2><h3 id="5-2-1-受上限控制的通配符"><a href="#5-2-1-受上限控制的通配符" class="headerlink" title="5.2.1 受上限控制的通配符"></a>5.2.1 受上限控制的通配符</h3><p>语法格式：**&lt;? extends XXX&gt;**</p><p>优点：扩大兼容的范围。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;Number&gt; list1; <span class="comment">// list1 只能匹配 Number 类型的数据</span></span><br><span class="line">List&lt;? exntends Number&gt; list2; <span class="comment">// list2 可以匹配 Number 类型的数据及其子类</span></span><br></pre></td></tr></table></figure><h3 id="5-2-2-受下限控制的通配符"><a href="#5-2-2-受下限控制的通配符" class="headerlink" title="5.2.2 受下限控制的通配符"></a>5.2.2 受下限控制的通配符</h3><p>语法格式：**&lt;? super XXX&gt;**</p><p>优点：扩大兼容的范围；可以建立泛型类、接口间的联系。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;Integer&gt; list1; <span class="comment">// list1 只能匹配 Integer 类型的数据</span></span><br><span class="line">List&lt;? <span class="built_in">super</span> Integer&gt; list2; <span class="comment">// list2 可以匹配 Integer 类型的数据及其祖类/接口</span></span><br></pre></td></tr></table></figure><h3 id="5-2-3-非受限的通配符"><a href="#5-2-3-非受限的通配符" class="headerlink" title="5.2.3 非受限的通配符"></a>5.2.3 非受限的通配符</h3><p>语法格式：**&lt;? &gt;**</p><p>关键使用场合：</p><ol><li>一个方法，而这方法的实现可以利用 Object 类中提供的功能时泛型类中的方法不依赖类型参数时如 List.size() 方法，它并不关心 List 中元素的具体类型；</li><li>List&lt;XXX&gt; 是 List&lt;?&gt; 的一个子类型理解 List&lt;Object&gt; 和 List&lt;?&gt; 的不同：差在 NULL 处理，前者不支持，而后者却可接受一个 null 入表；</li></ol><p>泛型类&#x2F;接口之间，没有任何关联，例如 <code>List&lt;Integer&gt;</code> 和 <code>List&lt;Number&gt;</code> 没有任何关联，不过可以使用通配符来建立联系。</p><p><strong>通配符只能在泛型方法中使用，泛型类、泛型接口无法使用。</strong></p><p><strong>通配符只能在泛型方法中使用，泛型类、泛型接口无法使用。</strong></p><p><strong>通配符只能在泛型方法中使用，泛型类、泛型接口无法使用。</strong></p><p>重要的情况说 3 遍。</p><h1 id="6、PESC-原则"><a href="#6、PESC-原则" class="headerlink" title="6、PESC 原则"></a>6、PESC 原则</h1><p>PESC 原则的好处：提升了 API 的灵活性。</p><h2 id="6-1-PE（Producer-extends）"><a href="#6-1-PE（Producer-extends）" class="headerlink" title="6.1 PE（Producer extends）"></a>6.1 PE（Producer extends）</h2><p>如果你只需要从集合中获得类型 T , 使用 &lt;? extends T&gt; 通配符。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">(List&lt;? extends Number&gt; list)</span> &#123;</span><br><span class="line">    list.add(<span class="number">0</span>); <span class="comment">// 错误， 此处 list 作为一个生产者，后续操作只能消费，不能继续生产</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="6-2-SC（Consumer-super）"><a href="#6-2-SC（Consumer-super）" class="headerlink" title="6.2 SC（Consumer super）"></a>6.2 SC（Consumer super）</h2><p>如果你只需要将类型T放到集合中, 使用 &lt;? super T&gt; 通配符。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">(List&lt;? <span class="built_in">super</span> Number&gt; list)</span> &#123;</span><br><span class="line">    list.add(<span class="number">0</span>); <span class="comment">// 错误， 此处 list 作为一个消费者，后续操作只能生产，不能继续消费</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然，如果你既想当 <code>生产者</code>，又想当 <code>消费者</code>，那么不使用通配符即可。</p><h1 id="7、类型擦除"><a href="#7、类型擦除" class="headerlink" title="7、类型擦除"></a>7、类型擦除</h1><p>在讲 <code>类型擦除</code> 之前，先来了解一下 <code>泛型</code> 历史。泛型是在 JDK5 才出现的，为了保证旧的 JDK 版本能正常运行，那么只能对 <code>泛型</code> 操刀了，将 <code>泛型</code> 处理成低版本能识别的信息，由此可见，Java&#x2F;Kotlin 中的 <code>泛型</code> 为 <strong>伪泛型</strong>。</p><p>那么，如何兼容呢？<code>类型擦除</code> 就是在该场景下诞生的。</p><p>擦除规则：</p><blockquote><p>编译器会把泛型类型中所有的类型参数替换为它们的上（下）限，如果没有对类型参数做出限制，那么就替换为 Object 类型。(因此，编译出的字节码仅仅包含了常规类，接口和方法。)</p></blockquote><blockquote><p>在必要时插入类型转换以保持类型安全。</p></blockquote><blockquote><p>生成桥方法以在扩展泛型时保持多态性。</p></blockquote><p>字节码如下，有兴趣的话可以研究研究：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 在子类，泛型设置为 Integer，那么 setT 的参数就变为 Integer， 但是基类却不知道这个情况</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">getT</span><span class="params">()</span>Ljava/lang/Integer;</span><br><span class="line"><span class="meta">@Lorg</span>/jetbrains/annotations/Nullable;() <span class="comment">// invisible</span></span><br><span class="line">L0</span><br><span class="line">LINENUMBER <span class="number">5</span> L0</span><br><span class="line">ALOAD <span class="number">0</span></span><br><span class="line">INVOKESPECIAL com/wd/kt/generic/Box.getT ()Ljava/lang/Object;</span><br><span class="line">CHECKCAST java/lang/Integer</span><br><span class="line">ARETURN</span><br><span class="line">L1</span><br><span class="line">LOCALVARIABLE <span class="built_in">this</span> Lcom/wd/kt/generic/IntegerBox; L0 L1 <span class="number">0</span></span><br><span class="line">MAXSTACK = <span class="number">1</span></span><br><span class="line">MAXLOCALS = <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 由于父类不知道子类的情况，为了不出现父类编译错误，因此有 bridge 方法，将子类与父类类型关联起来</span></span><br><span class="line"><span class="comment">// access flags 0x1041</span></span><br><span class="line"><span class="keyword">public</span> synthetic bridge <span class="title function_">getT</span><span class="params">()</span>Ljava/lang/Object;</span><br><span class="line">L0</span><br><span class="line">LINENUMBER <span class="number">3</span> L0</span><br><span class="line">ALOAD <span class="number">0</span></span><br><span class="line">INVOKEVIRTUAL com/wd/kt/generic/IntegerBox.getT ()Ljava/lang/Integer;</span><br><span class="line"><span class="type">ARETURN</span></span><br><span class="line"><span class="variable">MAXSTACK</span> <span class="operator">=</span> <span class="number">1</span></span><br><span class="line">MAXLOCALS = <span class="number">1</span></span><br></pre></td></tr></table></figure><h1 id="8、泛型中的约束和局限性"><a href="#8、泛型中的约束和局限性" class="headerlink" title="8、泛型中的约束和局限性"></a>8、泛型中的约束和局限性</h1><h2 id="8-1-不能实例化类型变量"><a href="#8-1-不能实例化类型变量" class="headerlink" title="8.1 不能实例化类型变量"></a>8.1 不能实例化类型变量</h2><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 错误</span></span><br><span class="line"><span class="comment"> * 原因：泛型中不能实例化类型变量</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">var</span> t:T = T()</span><br></pre></td></tr></table></figure><h2 id="8-2-静态域中不能引用类型变量"><a href="#8-2-静态域中不能引用类型变量" class="headerlink" title="8.2 静态域中不能引用类型变量"></a>8.2 静态域中不能引用类型变量</h2><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 错误</span></span><br><span class="line"><span class="comment"> * 原因：静态域中不能引用类型变量</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">var</span> t = T()</span><br></pre></td></tr></table></figure><h2 id="8-3-静态方法中不能引用类型变量"><a href="#8-3-静态方法中不能引用类型变量" class="headerlink" title="8.3 静态方法中不能引用类型变量"></a>8.3 静态方法中不能引用类型变量</h2><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 错误</span></span><br><span class="line"><span class="comment"> * 原因：静态方法中不能引用类型变量</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">test</span><span class="params">(t: <span class="type">T</span>)</span></span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 静态方法如果是泛型方法，那么可以正常使用</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> <span class="title">test</span><span class="params">(t: <span class="type">T</span>)</span></span> &#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="8-4-基础类型不能作为泛型实例化类型，包装类型可以"><a href="#8-4-基础类型不能作为泛型实例化类型，包装类型可以" class="headerlink" title="8.4 基础类型不能作为泛型实例化类型，包装类型可以"></a>8.4 基础类型不能作为泛型实例化类型，包装类型可以</h2><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> list = arrayListOf&lt;double&gt;() <span class="comment">// 错误写法，基础类型不能作为泛型实例化类型</span></span><br><span class="line"><span class="keyword">val</span> list = arrayListOf&lt;<span class="built_in">Double</span>&gt;() <span class="comment">// 正确写法，包装类型可以作为泛型实例化类型</span></span><br></pre></td></tr></table></figure><h2 id="8-5-泛型不能使用-instanceof-的"><a href="#8-5-泛型不能使用-instanceof-的" class="headerlink" title="8.5 泛型不能使用 instanceof 的"></a>8.5 泛型不能使用 instanceof 的</h2><p>语法层面规定的，究其原因就是泛型擦除机制，在编译器泛型就不存在了，所以 instanceof 无效。</p><h2 id="8-6-两个泛型类相同"><a href="#8-6-两个泛型类相同" class="headerlink" title="8.6 两个泛型类相同"></a>8.6 两个泛型类相同</h2><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> boxInt = Box&lt;<span class="built_in">Int</span>&gt;();</span><br><span class="line"><span class="keyword">val</span> boxString = Box&lt;String&gt;();</span><br><span class="line">System.<span class="keyword">out</span>.println(boxInt.<span class="keyword">class</span> == boxString.<span class="keyword">class</span>); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>因为泛型擦除机制，在泛型被擦除后，boxInt 与 boxString 的类型是相同的，都是 Box 类。</p><h2 id="8-7-泛型可以声明数组，但是不能初始化泛型数组"><a href="#8-7-泛型可以声明数组，但是不能初始化泛型数组" class="headerlink" title="8.7 泛型可以声明数组，但是不能初始化泛型数组"></a>8.7 泛型可以声明数组，但是不能初始化泛型数组</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Box&lt;Double&gt;[] boxs; <span class="comment">// 没有异常</span></span><br><span class="line">boxs = <span class="keyword">new</span> <span class="title class_">Box</span>&lt;Double&gt;[<span class="number">10</span>]; <span class="comment">// 错误，泛型数组不能初始化</span></span><br></pre></td></tr></table></figure><h2 id="8-8-泛型不能-extends-Exception-Throwable"><a href="#8-8-泛型不能-extends-Exception-Throwable" class="headerlink" title="8.8 泛型不能 extends Exception&#x2F;Throwable*&#x2F;"></a>8.8 泛型不能 extends Exception&#x2F;Throwable*&#x2F;</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;T <span class="keyword">extends</span> <span class="title class_">Throwable</span>&gt; <span class="keyword">void</span> <span class="title function_">test</span><span class="params">(T t)</span> &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">catch</span> (T t) &#123; <span class="comment">// 错误，不能捕捉异常对象</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 编写可以捕获异常代码</span></span><br><span class="line"><span class="keyword">public</span> &lt;T <span class="keyword">extends</span> <span class="title class_">Throwable</span>&gt; <span class="keyword">void</span> <span class="title function_">test</span><span class="params">(T t)</span> <span class="keyword">throws</span> T &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line"><span class="keyword">throw</span> t;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="8-9-Java-中-Arrays-不能使用泛型"><a href="#8-9-Java-中-Arrays-不能使用泛型" class="headerlink" title="8.9 Java 中 Arrays 不能使用泛型"></a>8.9 Java 中 Arrays 不能使用泛型</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 错误示例</span></span><br><span class="line"><span class="comment"> * 在 Java 中，数组不支持泛型</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">Arrays</span> <span class="variable">arrays</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Arrays</span>&lt;String&gt;();</span><br></pre></td></tr></table></figure><h2 id="8-10-Java-中-List-与-List-区别在哪"><a href="#8-10-Java-中-List-与-List-区别在哪" class="headerlink" title="8.10 Java 中 List 与 List &lt;?&gt; 区别在哪"></a>8.10 Java 中 List 与 List &lt;?&gt; 区别在哪</h2><p>List：原始类型，不是泛型，所以不涉及到类型检查；</p><p>List &lt;?&gt;: 泛型，涉及到类型检查；</p><h2 id="8-11-Java-中-List-与-List-的区别在哪"><a href="#8-11-Java-中-List-与-List-的区别在哪" class="headerlink" title="8.11 Java 中 List&lt;Object&gt; 与 List&lt;?&gt; 的区别在哪"></a>8.11 Java 中 List&lt;Object&gt; 与 List&lt;?&gt; 的区别在哪</h2><p>List&lt;?&gt;：是一个未知类型的 List，可以把 List&lt;String&gt;、List&lt;Integer&gt; 等赋值给 List&lt;?&gt;；</p><p>List&lt;Object&gt;：是任意类型的 List，却不能把 List&lt;String&gt;、List&lt;Integer&gt; 等赋值给 List&lt;Object&gt;；</p><h1 id="9、泛型区分"><a href="#9、泛型区分" class="headerlink" title="9、泛型区分"></a>9、泛型区分</h1><p>先定义一个泛型类。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestBox</span>&lt;T&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> T t;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">getT</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> t;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setT</span><span class="params">(T t)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.t = t;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 原始类型</span></span><br><span class="line">    <span class="type">TestBox</span> <span class="variable">box1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TestBox</span>();</span><br><span class="line">    <span class="comment">// signature Lcom/wd/generic/TestBox&lt;Ljava/lang/Object;&gt;;</span></span><br><span class="line">    <span class="comment">// declaration: box2 extends com.wd.generic.TestBox&lt;java.lang.Object&gt;</span></span><br><span class="line">    TestBox&lt;Object&gt; box2 = <span class="keyword">new</span> <span class="title class_">TestBox</span>&lt;&gt;();</span><br><span class="line">    <span class="comment">// signature Lcom/wd/generic/TestBox&lt;*&gt;;</span></span><br><span class="line">    <span class="comment">// declaration: box3 extends com.wd.generic.TestBox&lt;?&gt;</span></span><br><span class="line">    TestBox&lt;?&gt; box3 = <span class="keyword">new</span> <span class="title class_">TestBox</span>&lt;&gt;();</span><br><span class="line">    <span class="comment">// signature Lcom/wd/generic/TestBox&lt;TT;&gt;;</span></span><br><span class="line">    <span class="comment">// declaration: box4 extends com.wd.generic.TestBox&lt;T&gt;</span></span><br><span class="line">    TestBox&lt;T&gt; box4 = <span class="keyword">new</span> <span class="title class_">TestBox</span>&lt;&gt;();</span><br><span class="line">    <span class="comment">// signature Lcom/wd/generic/TestBox&lt;+TT;&gt;;</span></span><br><span class="line">    <span class="comment">// declaration: box5 extends com.wd.generic.TestBox&lt;? extends T&gt;</span></span><br><span class="line">    TestBox&lt;? <span class="keyword">extends</span> <span class="title class_">T</span>&gt; box5 = <span class="keyword">new</span> <span class="title class_">TestBox</span>&lt;&gt;();</span><br><span class="line">    <span class="comment">// signature Lcom/wd/generic/TestBox&lt;-TT;&gt;;</span></span><br><span class="line">    <span class="comment">// declaration: box6 extends com.wd.generic.TestBox&lt;? super T&gt;</span></span><br><span class="line">    TestBox&lt;? <span class="built_in">super</span> T&gt; box6 = <span class="keyword">new</span> <span class="title class_">TestBox</span>&lt;&gt;();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="10、泛型与反射"><a href="#10、泛型与反射" class="headerlink" title="10、泛型与反射"></a>10、泛型与反射</h1><p>前面我们讲到了泛型擦除，那么我们常用的 Gson、FastJson 等框架，又怎么能正确转换成我们需要的泛型呢？</p><p>其实，泛型虽然擦除了，从字节码我们可以看出还是保留了关键信息：</p><blockquote><p>signature: 指定了泛型对应的类型；</p><p>declaration：声明了原始代码信息；</p></blockquote><p>既然保留的有信息，那么在使用时，通过特殊手段获取到该信息，那么就能继续正常使用泛型了，加下来结合代码看看是如何实现的。</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> map = HashMap&lt;String, Number&gt;()</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> field = Test::<span class="keyword">class</span>.java.getDeclaredField(<span class="string">&quot;map&quot;</span>) <span class="comment">// 获取 field</span></span><br><span class="line">    <span class="keyword">val</span> paramType = field.genericType <span class="keyword">as</span> ParameterizedType <span class="comment">// 获取 ParameterizedType，ParameterizedType 中存储的有泛型信息</span></span><br><span class="line">    <span class="keyword">for</span> (item <span class="keyword">in</span> paramType.actualTypeArguments) &#123; <span class="comment">// 获取实际泛型信息，并打印</span></span><br><span class="line">        println(item.typeName)</span><br><span class="line">        <span class="comment">// 打印结果为：</span></span><br><span class="line">        <span class="comment">// java.lang.String</span></span><br><span class="line">        <span class="comment">// java.lang.Number</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由此可见，虽然泛型擦除了，但是并不妨碍运行期获取泛型实际类型信息，方法总是有的，研究一下或许就会有收获。</p>]]></content>
      
      
      <categories>
          
          <category> Kotlin </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Kotlin </tag>
            
            <tag> Android </tag>
            
            <tag> Java </tag>
            
            <tag> 泛型 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Coroutine 协程简单使用</title>
      <link href="/2020/11/03/Kotlin/Coroutine%20%E5%8D%8F%E7%A8%8B%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/"/>
      <url>/2020/11/03/Kotlin/Coroutine%20%E5%8D%8F%E7%A8%8B%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="1-协程是什么？"><a href="#1-协程是什么？" class="headerlink" title="1. 协程是什么？"></a>1. 协程是什么？</h1><p>在使用之前，需要了解什么是 <code>协程</code>，先看一下 <code>协程</code> 的定义：</p><blockquote><p>Coroutines are computer program components that generalize subroutines for non-preemptive multitasking, by allowing multiple entry points for suspending and resuming execution at certain locations. Coroutines are well-suited for implementing more familiar program components such as cooperative tasks, exceptions, event loops, iterators, infinite lists and pipes.</p></blockquote><p>中文翻译如下：</p><blockquote><p><code>协程</code>（英语：coroutine）是计算机程序的一类组件，推广了 <a href="https://bk.tw.lvfukeji.com/baike-%E5%8D%8F%E4%BD%9C%E5%BC%8F%E5%A4%9A%E4%BB%BB%E5%8A%A1">协作式多任务</a> 的 <a href="https://bk.tw.lvfukeji.com/baike-%E5%AD%90%E7%A8%8B%E5%BA%8F">子程序</a>，允许执行被挂起与被恢复。相对子例程而言，协程更为一般和灵活，但在实践中使用没有子例程那样广泛。协程更适合于用来实现彼此熟悉的程序组件，如 <a href="https://bk.tw.lvfukeji.com/baike-%E5%8D%8F%E4%BD%9C%E5%BC%8F%E5%A4%9A%E4%BB%BB%E5%8A%A1">协作式多任务</a>、<a href="https://bk.tw.lvfukeji.com/baike-%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86">异常处理</a>、<a href="https://bk.tw.lvfukeji.com/baike-%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF">事件循环</a>、<a href="https://bk.tw.lvfukeji.com/baike-%E8%BF%AD%E4%BB%A3%E5%99%A8">迭代器</a>、<a href="https://bk.tw.lvfukeji.com/baike-%E6%83%B0%E6%80%A7%E6%B1%82%E5%80%BC">无限列表</a> 和 <a href="https://bk.tw.lvfukeji.com/baike-%E7%AE%A1%E9%81%93_(%E8%BD%AF%E4%BB%B6)">管道</a>。</p></blockquote><pre><code>协程是一种在程序中处理并发任务的方案；也是这种方案的一个组件。在协程中，是没有并发、并行概念的。</code></pre><p><strong>在 kotlin for Android 中，kotlin 只是一个线程框架，线程所具有的并发、并行等问题，协程也会一个不落。究其原因在于在 Android 开发中 kotlin 需要编译成能被 JVM 识别的字节码，是基于 <code>线程</code> 的，所以不存在协程效率比线程高等情况，协程只是对线程的一个包装，是无法绕开线程的问题的。</strong></p><h1 id="2-协程怎么写？"><a href="#2-协程怎么写？" class="headerlink" title="2. 协程怎么写？"></a>2. 协程怎么写？</h1><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 使用 GlobalScope 作用域，通过 launch 开启一段协程</span></span><br><span class="line">GlobalScope.launch &#123;</span><br><span class="line">    printThreadInfo()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">printThreadInfo</span><span class="params">(prefix: <span class="type">String</span> = <span class="string">&quot;&quot;</span>)</span></span> &#123;</span><br><span class="line">    Log.i(<span class="string">&quot;CoroutineDemo&quot;</span>, <span class="string">&quot;<span class="subst">$&#123;if(prefix.isNullOrBlank()) <span class="string">&quot;&quot;</span> else <span class="string">&quot;<span class="variable">$prefix</span>, &quot;</span>&#125;</span>current thread is <span class="subst">$&#123;Thread.currentThread().name&#125;</span>&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用上述代码输出结果如下：</p><pre><code>current thread is DefaultDispatcher-worker-1</code></pre><p>通过 <code>launch</code> 即可开启一段协程，在 <code>launch</code> 中可以传入 <code>Dispatchers</code> 来指定线程，具体有一下 4 种类型：</p><ol><li>Default：默认调度器；</li><li>Main：主线程调度器；</li><li>Unconfined：未被明确配置的调度器；</li><li>IO：流调度器，一般 <code>IO 操作</code>、<code>网络请求</code> 等耗时操作；</li></ol><h1 id="3-串行场景模拟"><a href="#3-串行场景模拟" class="headerlink" title="3. 串行场景模拟"></a>3. 串行场景模拟</h1><p>假设：目前有 3 个网络请求方法，分别是：networkTest1、networkTest2、networkTest3，以及 3 个对应的 UI 更新，分别是：uiTest1、uiTest2、uiTest3。</p><pre><code>模拟网络请求以及更新 UIstep 1. 请求接口 1 --&gt; 更新 UI 1step 2. 请求接口 2 --&gt; 更新 UI 2step 3. 请求接口 3 --&gt; 更新 UI 3</code></pre><h2 id="3-1-普通写法："><a href="#3-1-普通写法：" class="headerlink" title="3.1 普通写法："></a>3.1 普通写法：</h2><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 线程写法</span></span><br><span class="line">thread &#123;</span><br><span class="line">    networkTest1()</span><br><span class="line">    activity?.runOnUiThread &#123;</span><br><span class="line">        uiTest1()</span><br><span class="line">        thread &#123;</span><br><span class="line">            networkTest2()</span><br><span class="line">            activity?.runOnUiThread &#123;</span><br><span class="line">                uiTest2()</span><br><span class="line">                thread &#123;</span><br><span class="line">                    networkTest3()</span><br><span class="line">                    activity?.runOnUiThread &#123;</span><br><span class="line">                        uiTest3()</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出信息为：</p><pre><code>networkTest1(), current thread is Thread-2uiTest1(), current thread is mainnetworkTest2(), current thread is Thread-3uiTest2(), current thread is mainnetworkTest3(), current thread is Thread-4uiTest3(), current thread is main</code></pre><p>死亡回调有木有？</p><h2 id="3-2-RxJava写法："><a href="#3-2-RxJava写法：" class="headerlink" title="3.2  RxJava写法："></a>3.2 <code> RxJava</code>写法：</h2><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">Observable.just(<span class="string">&quot;Test&quot;</span>)</span><br><span class="line">            .observeOn(Schedulers.io())</span><br><span class="line">            .doOnNext &#123; networkTestRx1() &#125;</span><br><span class="line">            .observeOn(AndroidSchedulers.mainThread())</span><br><span class="line">            .doOnNext &#123; uiTest1() &#125;</span><br><span class="line">            .observeOn(Schedulers.io())</span><br><span class="line">            .doOnNext &#123; networkTestRx2() &#125;</span><br><span class="line">            .observeOn(AndroidSchedulers.mainThread())</span><br><span class="line">            .doOnNext &#123; uiTest2() &#125;</span><br><span class="line">            .observeOn(Schedulers.io())</span><br><span class="line">            .doOnNext &#123; networkTestRx3() &#125;</span><br><span class="line">            .observeOn(AndroidSchedulers.mainThread())</span><br><span class="line">            .doOnNext &#123; uiTest3() &#125;</span><br><span class="line">            .subscribe()</span><br></pre></td></tr></table></figure><p>输出信息如下图所示：</p><pre><code>networkTestRx1(), current thread is RxCachedThreadScheduler-1uiTest1(), current thread is mainnetworkTestRx2(), current thread is RxCachedThreadScheduler-2uiTest2(), current thread is mainnetworkTestRx3(), current thread is RxCachedThreadScheduler-3uiTest3(), current thread is main</code></pre><p>由输出信息可见，<code>RxJava</code> 线程切换没有问题，完美的实现了需求。但是，为了实现线程切换，增加的 <strong>线程切换代码量</strong> 是 <strong>有效执行代码量</strong> 的一倍，相比于普通写法，代码量减少了不少，但是线程切换的代码占比较大，那么…还有没有优化空间呢？</p><h2 id="3-2-协程-写法："><a href="#3-2-协程-写法：" class="headerlink" title="3.2 协程 写法："></a>3.2 <code>协程</code> 写法：</h2><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">viewModel.viewModelScope.launch(Dispatchers.Main) &#123;</span><br><span class="line">    networkTests1()</span><br><span class="line">    uiTest1()</span><br><span class="line">    networkTests2()</span><br><span class="line">    uiTest2()</span><br><span class="line">    networkTests3()</span><br><span class="line">    uiTest3()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出信息为：</p><pre><code>networkTest1(), current thread is DefaultDispatcher-worker-1uiTest1(), current thread is mainnetworkTest2(), current thread is DefaultDispatcher-worker-3uiTest2(), current thread is mainnetworkTest3(), current thread is DefaultDispatcher-worker-1uiTest3(), current thread is main</code></pre><p>就这几行看似同步的代码，实现了异步任务、线程切换等问题，由此可见，<code>协程</code>比单纯使用线程方便很多。由日志信息可见，<code>DefaultDispatcher-worker-1</code> 与 <code>DefaultDispatcher-worker-3</code> 并不是同一个线程哟，所以说 <code>协程是单线程的说法是错误的</code>。</p><h1 id="4-并行场景模拟"><a href="#4-并行场景模拟" class="headerlink" title="4. 并行场景模拟"></a>4. 并行场景模拟</h1><h2 id="4-1-普通写法："><a href="#4-1-普通写法：" class="headerlink" title="4.1 普通写法："></a>4.1 普通写法：</h2><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">thread &#123;</span><br><span class="line">    networkTest1()</span><br><span class="line">    activity?.runOnUiThread &#123; uiTest1() &#125;</span><br><span class="line">&#125;</span><br><span class="line">thread &#123;</span><br><span class="line">    networkTest2()</span><br><span class="line">    activity?.runOnUiThread &#123; uiTest2() &#125;</span><br><span class="line">&#125;</span><br><span class="line">thread &#123;</span><br><span class="line">    networkTest3()</span><br><span class="line">    activity?.runOnUiThread &#123; uiTest3() &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>直接开启几个线程，更新 UI 时，还要切换回主线程。</p><h2 id="4-2-RxJava-写法"><a href="#4-2-RxJava-写法" class="headerlink" title="4.2 RxJava 写法"></a>4.2 RxJava 写法</h2><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">Single.zip(</span><br><span class="line">    RetrofitHelper.wanAPI.queryBannerRx(),</span><br><span class="line">    RetrofitHelper.wanAPI.queryChapterRx(),</span><br><span class="line">    &#123; banner, chapter -&gt; <span class="string">&quot;<span class="subst">$&#123;banner.data?.first()?.title&#125;</span> - <span class="subst">$&#123;chapter.data?.first()?.name&#125;</span>&quot;</span> &#125;</span><br><span class="line">).observeOn(AndroidSchedulers.mainThread()).subscribe &#123; combine -&gt; msg.value = combine &#125;</span><br></pre></td></tr></table></figure><p>这里实现两个真实并行网络请求，由代码可见，线程能通过 observeOn 自动切换，多个异步也能并行执行，相对于<code>普通写法</code>，代码可读性大大提高，也简洁不少。</p><h2 id="4-3-协程写法"><a href="#4-3-协程写法" class="headerlink" title="4.3 协程写法"></a>4.3 协程写法</h2><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">viewModelScope.launch(Dispatchers.Main) &#123;</span><br><span class="line">    <span class="keyword">val</span> banner = async &#123; RetrofitHelper.wanAPI.queryBannerKt().<span class="keyword">data</span> &#125;</span><br><span class="line">    <span class="keyword">val</span> chapter = async &#123; RetrofitHelper.wanAPI.queryChapterKt().<span class="keyword">data</span> &#125;</span><br><span class="line">    msg.value = <span class="string">&quot;<span class="subst">$&#123;banner.await()?.first()?.title&#125;</span> + <span class="subst">$&#123;chapter.await()?.first()?.name&#125;</span>&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>相比较于 RxJava，代码量更少，在通过 <code>launch</code> 开启线协程后，3 行代码对应 3 个需要的操作，代码更加简洁明了。</p><h1 id="5-总结"><a href="#5-总结" class="headerlink" title="5. 总结"></a>5. 总结</h1><p>协程是什么：协程是一个线程框架。</p><p>使用协程的优势：</p><ol><li>耗时代码可以自动分配到后台，任务执行完后也可以自动切回；</li><li>对比 thread，可以避免死亡回调的问题；</li><li>可以用看似同步的代码实现异步任务，使代码更简洁，提高可读性；</li></ol><p>最后，示例项目地址信息 <a href="https://github.com/WalkerDenial/KotlinStudy">示例代码</a>，欢迎交流学习，如果错误，请指正。</p>]]></content>
      
      
      <categories>
          
          <category> Kotlin </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 协程 </tag>
            
            <tag> Coroutine </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Android 中 Gradle 小技巧</title>
      <link href="/2020/11/01/Gradle/Android%20%E4%B8%AD%20Gradle%20%E5%B0%8F%E6%8A%80%E5%B7%A7/"/>
      <url>/2020/11/01/Gradle/Android%20%E4%B8%AD%20Gradle%20%E5%B0%8F%E6%8A%80%E5%B7%A7/</url>
      
        <content type="html"><![CDATA[<p>在安卓项目开发中，最常用的就是 gradle 配置，对于一个单一 module 来说，怎么配置其实影响不大。但是，如果存在多个 module，例如：</p><pre><code>├── app├── module1├── module2├── nodule3├── module4└── module5</code></pre><p>那么这其中就涉及到各个 module 中 gradle 依赖的管理，如果管理不到位，就会出现重复包、不同版本包，甚至冲突等问题，那么如何做到版本统一呢？</p><p>常用方式如下：</p><p>1、新建 config.gradle，在里面定义 ext 信息，示例代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ext.deps = [</span><br><span class="line">        kt    : [</span><br><span class="line">                core: <span class="string">&quot;org.jetbrains.kotlin:kotlin-stdlib:$kotlin_version&quot;</span></span><br><span class="line">        ],</span><br><span class="line">        andX  : [</span><br><span class="line">                core      : <span class="string">&#x27;androidx.core:core-ktx:1.2.0&#x27;</span>,</span><br><span class="line">                appcompat : <span class="string">&#x27;androidx.appcompat:appcompat:1.1.0&#x27;</span>,</span><br><span class="line">                constraint: <span class="string">&#x27;androidx.constraintlayout:constraintlayout:1.1.3&#x27;</span>,</span><br><span class="line">                livedata  : <span class="string">&#x27;androidx.lifecycle:lifecycle-livedata-ktx:2.2.0&#x27;</span>,</span><br><span class="line">                viewmodel : <span class="string">&#x27;androidx.lifecycle:lifecycle-viewmodel-ktx:2.2.0&#x27;</span></span><br><span class="line">        ],</span><br><span class="line">        google: [</span><br><span class="line">                material: <span class="string">&#x27;com.google.android.material:material:1.1.0&#x27;</span></span><br><span class="line">        ],</span><br><span class="line">        test  : [</span><br><span class="line">                junit   : <span class="string">&#x27;junit:junit:4.12&#x27;</span>,</span><br><span class="line">                ext     : <span class="string">&#x27;androidx.test.ext:junit:1.1.1&#x27;</span>,</span><br><span class="line">                espresso: <span class="string">&#x27;androidx.test.espresso:espresso-core:3.2.0&#x27;</span></span><br><span class="line">        ]</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>2、通过 <strong>apply from: “config.gradle”</strong> 引入，使用 <strong>deps.andX.core</strong> 引入，便可以做到引用同一处定义信息，避免版本错乱问题。</p><p>到这里看起来像是问题解决了，那么…又来了一个新问题，如下图所示：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">implementation &#x27;androidx.core:core-ktx:1.2.0&#x27;</span><br><span class="line">implementation &#x27;androidx.appcompat:appcompat:1.1.0&#x27;</span><br><span class="line">testImplementation &#x27;junit:junit:4.12&#x27;</span><br><span class="line">androidTestImplementation &#x27;androidx.test.ext:junit:1.1.1&#x27;</span><br><span class="line">androidTestImplementation &#x27;androidx.test.espresso:espresso-core:3.2.0&#x27;</span><br></pre></td></tr></table></figure><p>这几行代码有没有那么一丝丝的眼熟？应该、好像、大概、差不多、也许…每个 build.gradle 里面都要写一遍，哪怕引用 config.gradle 里面的同一配置，可是这几个重复的代码还是没有减少，那么…我们…能不能再优化一下呢，答案当然是肯定的啦。</p><p>3、在 <strong>config.gradle</strong> 中定义方法，在方法里面做引用聚合，这样就能减少重复代码了，show me code：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ext.baseDeps = &#123; handler -&gt;</span><br><span class="line">    handler.implementation deps.kt.core</span><br><span class="line"></span><br><span class="line">    handler.implementation deps.andX.core</span><br><span class="line">    handler.implementation deps.andX.appcompat</span><br><span class="line">    handler.implementation deps.andX.constraint</span><br><span class="line">    handler.implementation deps.andX.livedata</span><br><span class="line">    handler.implementation deps.andX.viewmodel</span><br><span class="line"></span><br><span class="line">    handler.testImplementation deps.test.junit</span><br><span class="line">    handler.androidTestImplementation deps.test.ext</span><br><span class="line">    handler.androidTestImplementation deps.test.espresso</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>相应的，<strong>build.gradle</strong> 里面的代码可以写成这样：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">    baseDeps(dependencies)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>就是这样，一行代码即可搞定公共基础依赖，就是这么简单。</p><p>总结：</p><pre><code>1. 配置 config.gradle 依赖组件/版本信息；2. 提取组合依赖为一个方法；3. 尽情一行代码调用吧；</code></pre><p>最后，示例项目地址信息 <a href="https://github.com/WalkerDenial/KotlinStudy">示例代码</a>，欢迎交流学习，如果错误，请指正。</p>]]></content>
      
      
      <categories>
          
          <category> Gradle </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 基础 </tag>
            
            <tag> Gradle </tag>
            
            <tag> Android </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Android 中 Gradle 调用过程</title>
      <link href="/2020/11/01/Gradle/Android%20%E4%B8%AD%20Gradle%20%E8%B0%83%E7%94%A8%E8%BF%87%E7%A8%8B/"/>
      <url>/2020/11/01/Gradle/Android%20%E4%B8%AD%20Gradle%20%E8%B0%83%E7%94%A8%E8%BF%87%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<p>在 Android 开发中，我们经常接触 gradle 文件，例如：settings.gradle、build.gradle 等等，那么新建一个项目，他们之间的先后顺序是什么呢？</p><p>What？为什么要知道这个呢，直接调用它不香吗？</p><p>香是香，<strong>但是</strong> 当你需要做一些配置的时候，比如资源配置、预处理等操作的时候，该添加到什么位置呢？只有搞清楚了调用流程，才能在正确的地方添加操作。</p><p><strong>接下来以一个新建项目为例：</strong></p><p>新建一个 Android 项目目录如下：</p><pre><code>├── app│   ├── libs│   ├── src│   ├── build.gradle│   └── proguard-rules.pro├── build├── gradle│   └── wrapper│       ├── gradle-wrapper.jar│       └── gradle-wrapper.properties├── config.gradle├── build.gradle├── gradle.properties├── gradlew├── gradlew.bat├── local.properties└── settings.gradle</code></pre><p>其中 <code>config.gradle</code> 是基础配置，统一管理依赖项，整个项目中，存在 <strong>4</strong> 个 gradle 文件，它们分别是：</p><ol><li>app&#x2F;build.gradle：对 app 模块所需配置信息进行管理；</li><li>config.gradle：对依赖配置版本信息进行统一管理；</li><li>build.gradle：项目根配置文件；</li><li>settings.gradle：配置、管理项目模块信息；</li></ol><p>对以上 4 个文件进行日志信息输出处理：</p><p><strong>app&#x2F;build.gradle</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">android &#123;</span><br><span class="line">    println(<span class="string">&quot;app --&gt; build.gradle --&gt; android&quot;</span>)</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    defaultConfig &#123;</span><br><span class="line">        println(<span class="string">&quot;app --&gt; build.gradle --&gt; defaultConfig&quot;</span>)</span><br><span class="line">        ...</span><br><span class="line">        println(<span class="string">&quot;app --&gt; build.gradle --&gt; defaultConfig out&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    buildTypes &#123;</span><br><span class="line">        println(<span class="string">&quot;app --&gt; build.gradle --&gt; buildTypes&quot;</span>)</span><br><span class="line">        debug &#123;</span><br><span class="line">            println(<span class="string">&quot;app --&gt; build.gradle --&gt; debug&quot;</span>)</span><br><span class="line">            println(<span class="string">&quot;app --&gt; build.gradle --&gt; debug out&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        release &#123;</span><br><span class="line">            println(<span class="string">&quot;app --&gt; build.gradle --&gt; release&quot;</span>)</span><br><span class="line">            ...</span><br><span class="line">            println(<span class="string">&quot;app --&gt; build.gradle --&gt; release out&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        println(<span class="string">&quot;app --&gt; build.gradle --&gt; buildTypes out&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    compileOptions &#123;</span><br><span class="line">        println(<span class="string">&quot;app --&gt; build.gradle --&gt; compileOptions&quot;</span>)</span><br><span class="line">        ...</span><br><span class="line">        println(<span class="string">&quot;app --&gt; build.gradle --&gt; compileOptions out&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    kotlinOptions &#123;</span><br><span class="line">        println(<span class="string">&quot;app --&gt; build.gradle --&gt; kotlinOptions&quot;</span>)</span><br><span class="line">        ...</span><br><span class="line">        println(<span class="string">&quot;app --&gt; build.gradle --&gt; kotlinOptions out&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    println(<span class="string">&quot;app --&gt; build.gradle --&gt; android out&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">dependencies &#123;</span><br><span class="line">    println(<span class="string">&quot;app --&gt; build.gradle --&gt; dependencies&quot;</span>)</span><br><span class="line">    ...</span><br><span class="line">    println(<span class="string">&quot;app --&gt; build.gradle --&gt; dependencies out&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>config.gradle</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">allprojects &#123;</span><br><span class="line">    println(<span class="string">&quot;config.gradle --&gt; allprojects&quot;</span>)</span><br><span class="line">    repositories &#123;</span><br><span class="line">        println(<span class="string">&quot;config.gradle --&gt; repositories&quot;</span>)</span><br><span class="line">        ...</span><br><span class="line">        println(<span class="string">&quot;config.gradle --&gt; repositories out&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    println(<span class="string">&quot;config.gradle --&gt; allprojects out&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">task <span class="title function_">clean</span><span class="params">(type: Delete)</span> &#123;</span><br><span class="line">    println(<span class="string">&quot;config.gradle --&gt; clean&quot;</span>)</span><br><span class="line">    ...</span><br><span class="line">    println(<span class="string">&quot;config.gradle --&gt; clean out&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ext.deps = [</span><br><span class="line">        ...</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p><strong>build.gradle</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">buildscript &#123;</span><br><span class="line">    println(<span class="string">&quot;build.gradle --&gt; buildscript&quot;</span>)</span><br><span class="line">    ...</span><br><span class="line">    repositories &#123;</span><br><span class="line">        println(<span class="string">&quot;build.gradle --&gt; repositories&quot;</span>)</span><br><span class="line">        ...</span><br><span class="line">        println(<span class="string">&quot;build.gradle --&gt; repositories out&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    dependencies &#123;</span><br><span class="line">        println(<span class="string">&quot;build.gradle --&gt; dependencies&quot;</span>)</span><br><span class="line">        ..</span><br><span class="line">        println(<span class="string">&quot;build.gradle --&gt; dependencies out&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    println(<span class="string">&quot;build.gradle --&gt; buildscript out&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>settings.gradle</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">println(<span class="string">&quot;settings.gradle --&gt; start&quot;</span>)</span><br><span class="line">...</span><br><span class="line">println(<span class="string">&quot;settings.gradle --&gt; end&quot;</span>)</span><br></pre></td></tr></table></figure><p>build 项目之后，日志输出信息如下：</p><pre><code>Starting Gradle Daemon...Gradle Daemon started in 953 mssettings.gradle --&gt; startsettings.gradle --&gt; end&gt; Configure project :build.gradle --&gt; buildscriptbuild.gradle --&gt; repositoriesbuild.gradle --&gt; repositories outbuild.gradle --&gt; dependenciesbuild.gradle --&gt; dependencies outbuild.gradle --&gt; buildscript outconfig.gradle --&gt; allprojectsconfig.gradle --&gt; repositoriesconfig.gradle --&gt; repositories outconfig.gradle --&gt; allprojects outconfig.gradle --&gt; allprojectsconfig.gradle --&gt; repositoriesconfig.gradle --&gt; repositories outconfig.gradle --&gt; allprojects outconfig.gradle --&gt; cleanconfig.gradle --&gt; clean out&gt; Configure project :appapp --&gt; build.gradle --&gt; androidapp --&gt; build.gradle --&gt; defaultConfigapp --&gt; build.gradle --&gt; defaultConfig outapp --&gt; build.gradle --&gt; buildTypesapp --&gt; build.gradle --&gt; debugapp --&gt; build.gradle --&gt; debug outapp --&gt; build.gradle --&gt; releaseapp --&gt; build.gradle --&gt; release outapp --&gt; build.gradle --&gt; buildTypes outapp --&gt; build.gradle --&gt; compileOptionsapp --&gt; build.gradle --&gt; compileOptions outapp --&gt; build.gradle --&gt; kotlinOptionsapp --&gt; build.gradle --&gt; kotlinOptions outapp --&gt; build.gradle --&gt; android outapp --&gt; build.gradle --&gt; dependenciesapp --&gt; build.gradle --&gt; dependencies out</code></pre><p>由此可知，执行顺序如下：<strong>settings.gradle</strong> –&gt; <strong>build.gradle</strong> –&gt; <strong>config.gradle</strong> –&gt; <strong>app&#x2F;build.gradle</strong> ，在配置 config 信息时，要注意其实效性在 build.gradle 之后，可以避免很多不必要的错误。</p><p>最后，项目地址信息 <a href="https://github.com/WalkerDenial/KotlinStudy">示例代码</a>，欢迎交流学习。</p>]]></content>
      
      
      <categories>
          
          <category> Gradle </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 基础 </tag>
            
            <tag> Gradle </tag>
            
            <tag> Android </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>网络应用</title>
      <link href="/2020/04/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%BA%94%E7%94%A8/"/>
      <url>/2020/04/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%BA%94%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h3 id="1-计算机网络应用体系结构"><a href="#1-计算机网络应用体系结构" class="headerlink" title="1. 计算机网络应用体系结构"></a>1. 计算机网络应用体系结构</h3><p>从体系结构角度进行划分：</p><table><thead><tr><th align="center">名称</th><th align="center">特征</th></tr></thead><tbody><tr><td align="center">客户&#x2F;服务器（C&#x2F;S）结构</td><td align="center">通信只在客户与服务器之间进行，客户与客户之间不进行直接通信</td></tr><tr><td align="center">纯 P2P（Peer to Peer）结构</td><td align="center">任何一个对等端既可以主动发起请求另一个对等端的服务，也可以被动地为其他对等端提供服务</td></tr><tr><td align="center">混合结构</td><td align="center">既有中心服务器的存在，又有对等端（客户）间的直接通信</td></tr></tbody></table><p><img src="https://personal-blog.oss-cn-hangzhou.aliyuncs.com/cs.jpeg" alt="C/S 结构网络应用示意图"></p><p><img src="https://personal-blog.oss-cn-hangzhou.aliyuncs.com/p2p.jpeg" alt="纯 P2P 结构网络应用示意图"></p><p><img src="https://personal-blog.oss-cn-hangzhou.aliyuncs.com/hunhe.jpeg" alt="混合结构网络应用示意图"></p><h3 id="2-网络应用通信基本原理"><a href="#2-网络应用通信基本原理" class="headerlink" title="2. 网络应用通信基本原理"></a>2. 网络应用通信基本原理</h3><blockquote><p>网络应用的本质是运行在不同主机上（当然也可以运行在同一主机上）的应用进程之间的通信。</p></blockquote><p><img src="https://personal-blog.oss-cn-hangzhou.aliyuncs.com/tongxin.jpeg" alt="网络应用通信基本原理"></p><p>应用层协议定义了应用进程间交换的报文类型、报文构成部分具体含义以及交换时序等内容，即语法、语义和史学等协议三要素内容。</p><p>无论是服务器进程还是客户进程，当其遵循应用层协议组织好应用层报文后，需要用过层间接口（如应用编程接口 API）将报文传递给相邻的传输层，请求传输层协议提供端到端传输服务。</p><h3 id="3-域名系统（DNS）"><a href="#3-域名系统（DNS）" class="headerlink" title="3. 域名系统（DNS）"></a>3. 域名系统（DNS）</h3><p>任何一个需要使用域名进行通信的网络应用，在应用通信之前首先需要请求 DNS 应用，将域名映射为 IP 地址。实现将域名映射为 IP 地址的过程，称为域名解析。</p><h4 id="3-1-层次化域名空间"><a href="#3-1-层次化域名空间" class="headerlink" title="3.1 层次化域名空间"></a>3.1 层次化域名空间</h4><p> DNS 为了实现域名的有效管理与高效查询，DNS 服务器按层次结构进行组织，并且该层次结构与域名的结构相对应。业务采用了层次树状结构的命名方法。</p><ol><li>国家顶级域名 mTLD：如 cn 表示中国，us 表示美国，uk 表示英国等；</li><li>通用顶级域名 gTLD：最早的顶级域名是 com（公司和企业）、net（网络服务机构）、org（非营利性组织）、edu（专用的教育机构）、gov（专用的政府部门）、mil（专用的军事部门）、int（国际组织）；</li><li>基础结构域名（infrastructure domain）：这种顶级域名只有一个，即 arpa，用于反向域名解析，因此又称为反向域名；</li></ol><h4 id="3-2-域名服务器"><a href="#3-2-域名服务器" class="headerlink" title="3.2 域名服务器"></a>3.2 域名服务器</h4><p>一个域名服务器所负责管辖的（或有权限的）范围叫做区（zone）。每一个区设置相应的权威域名服务器，用来保存该区中的所有主机的域名到 IP 地址的映射。DNS 服务器的管辖范围不是以「域」为单位，而是以「区」为单位。</p><p>域名服务器根据其主要保存的域名信息以及在域名解析过程中的作用等，可以分为：</p><ol><li>根域名服务器：每个根域名服务器都知道所有的顶级域名服务器的域名和 IP 地址；</li><li>顶级域名服务器：即 TLD 服务器，负责管理在该顶级域名服务器注册的所有二级域名；</li><li>权威域名服务器：负责一个区的域名服务器，保存该区中的所有主机的域名到 IP 地址的映射；</li><li>中间域名服务器：既不是根域名服务器，又不是顶级域名服务器，也不是权威域名服务器的域名服务器；</li></ol><h4 id="3-3-域名解析过程"><a href="#3-3-域名解析过程" class="headerlink" title="3.3 域名解析过程"></a>3.3 域名解析过程</h4><ol><li>递归解析</li><li>迭代解析</li></ol><p><img src="https://personal-blog.oss-cn-hangzhou.aliyuncs.com/dns_query.jpeg" alt="域名解析过程"></p><p>无论是递归解析还是迭代解析，在上述的查询过程中，只要本地域名服务器不能直接响应解析结果，则都需要从根域名服务器开始查询。</p><p>改进域名系统查询效率的策略和方案：</p><ol><li>域名服务器增加缓存机制</li><li>在本地域名服务器中存储顶级域名服务器信息</li></ol><h3 id="4-万维网应用"><a href="#4-万维网应用" class="headerlink" title="4. 万维网应用"></a>4. 万维网应用</h3><h4 id="4-1-万维网应用结构"><a href="#4-1-万维网应用结构" class="headerlink" title="4.1 万维网应用结构"></a>4.1 万维网应用结构</h4><p> 20 世纪 90 年代初，诞生了万维网（World Wide Web，WWW）应用，也称为 Web 应用。</p><p>Web 应用主要包括：Web 服务器、浏览器、超文本传输协议（HTTP）等部分。</p><h4 id="4-2-HTTP"><a href="#4-2-HTTP" class="headerlink" title="4.2 HTTP"></a>4.2 HTTP</h4><h5 id="4-2-1-HTTP-概述"><a href="#4-2-1-HTTP-概述" class="headerlink" title="4.2.1 HTTP 概述"></a>4.2.1 HTTP 概述</h5><p>HTTP 是 Web 应用的应用层协议，定义浏览器如何向 Web 服务器发送请求以及 Web 服务器如何向浏览器进行响应。</p><h5 id="4-2-2-HTTP-链接"><a href="#4-2-2-HTTP-链接" class="headerlink" title="4.2.2 HTTP 链接"></a>4.2.2 HTTP 链接</h5><p>HTTP 基于传输层的 TCP 传输报文。浏览器在向服务器发送请求之前，首先需要建立 TCP 链接，然后才能发送 HTTP 请求报文，并接收 HTTP 响应报文。根据 HTTP 在使用 TCP 链接的策略不同，可以分为 <strong>非持久连接的 HTTP</strong> 和 <strong>持久连接的 HTTP</strong>。</p><ol><li>非持久连接：指 HTTP 客户与 HTTP 服务器建立 TCP 链接后，通过该链接发送 HTTP 请求报文，接收 HTTP 响应报文，然后断开链接；</li><li>并行连接：通过并行连接加速或优化 HTTP 是比较典型的技术手段，目前几乎所有的浏览器都支持并行连接；</li><li>持久连接：根据使用时就连接传输多个对象的策略不同，持久连接又分为两种工作方式：非流水方式持久连接和流水方式持久连接；</li></ol><h5 id="4-2-3-HTTP-报文"><a href="#4-2-3-HTTP-报文" class="headerlink" title="4.2.3 HTTP 报文"></a>4.2.3 HTTP 报文</h5><p> HTTP 报文由 4 部分组成：</p><ol><li>起始行（start line）：与首部是行分隔的 ASCII 文本，每行由 CRLF（回车换行） 终止；</li><li>首部行（header lines）</li><li>空白行（blank line）：只有 CRLF；</li><li>实体主体（entity body）：可以是文本或二进制数据；</li></ol><p>HTTP 报文起始行和空白行不可缺少，首部行可以是零行或多行，实体主体则根据报文类型、功能等可有可无。</p><p>HTTP 报文可以分为两类：请求报文和响应报文。</p><h4 id="4-3-Cookie"><a href="#4-3-Cookie" class="headerlink" title="4.3 Cookie"></a>4.3 Cookie</h4><p>Cookie 中文名称为小型文本文件，指某些网站为了辨别用户身份、进行会话跟踪而存储在用户本地终端上的数据。</p><p>Cookie 技术主要包括 4 部分内容：</p><ol><li>HTTP 响应报文中的 Cookie 头行：Set-Cookie；</li><li>用户浏览器在本地存储、维护和管理的 Cookie 文件；</li><li>HTTP 请求报文中的 Cookie 头行：Cookie；</li><li>网站在后台数据库中存储、维护的 Cookie 信息，包括已分配给用户 ID、每个 ID 用户在本网站的访问特征等；</li></ol><p><img src="https://personal-blog.oss-cn-hangzhou.aliyuncs.com/cookie.jpeg" alt="基于 Cookie 实现用户跟踪"></p><h3 id="5-Internet-电子邮件"><a href="#5-Internet-电子邮件" class="headerlink" title="5. Internet 电子邮件"></a>5. Internet 电子邮件</h3><h4 id="5-1-电子邮件系统结构"><a href="#5-1-电子邮件系统结构" class="headerlink" title="5.1 电子邮件系统结构"></a>5.1 电子邮件系统结构</h4><p>电子邮件系统主要包括邮件服务器、简单邮件传输协议（SMTP）、用户代理和邮件读取协议等。</p><p><img src="https://personal-blog.oss-cn-hangzhou.aliyuncs.com/mail.jpeg" alt="电子邮件系统结构"></p><h4 id="5-2-SMTP"><a href="#5-2-SMTP" class="headerlink" title="5.2 SMTP"></a>5.2 SMTP</h4><p>SMTP 是 Internet 电子邮件中核心应用层协议，实现邮件服务器之间或用户代理到邮件服务器之间的邮件传输。SMTP 使用传输层 TCP 实现可靠数据传输，从发送方（客户端）向接收端（服务器端）发送邮件。</p><p>SMTP 通过 3 个阶段的应用层交互完成邮件的传输：</p><ol><li>握手阶段</li><li>邮件传输阶段</li><li>关闭阶段</li></ol><h4 id="5-3-电子邮件格式与-MIME"><a href="#5-3-电子邮件格式与-MIME" class="headerlink" title="5.3 电子邮件格式与 MIME"></a>5.3 电子邮件格式与 MIME</h4><p> 一份邮件包括首部、空白行、主体 3 部分。邮件内容首部包括一条或多条首部行，每条首部行包括一个关键字，后面加上冒号，冒号后面是首部值。邮件中常见的首部行包括以下内容：</p><ol><li>「To:」后面填入一个或多个收件人的电子邮件地址；<strong>（必须填写）</strong></li><li>「Subject:」是邮件的主题；</li><li>「Cc:」表示应给某某人发送一个邮件副本；</li><li>「From:」表示发信人的电子邮件地址；</li><li>「Date:」发信日期；</li><li>「Reply-To」是对方回信所用的地址；</li></ol><p>由于 SMTP 只能传输 7 位 ASCII 码文本内容，所以在传输非 7 位 ASCII 码文本内容时，必须依据一个标准将非 7 位 ASCII 码文本内容转换为 7 位 ASCII 码文本内容，然后再利用 SMTP 进行传输。解决这一问题的具体方案就是多用途互联网邮件扩展（Multipurpose Internet Mail Extensions，MIME）。MIME 已经广泛应用于互联网的邮件之中。</p><p>MIME 的基本思想不是改动或取代 SMTP，而是继续使用 RFC822 定义的邮件格式标准。但是，MIME 定义了将非 7 位 ASCII 码内容转换为 7 位 ASCII 码的编码规则，并在邮件首部增加 MIME 首部行，说明主体内容原本的数据类型以及采用的编码标准等。</p><p>MIME 主要包括 3 个部分：</p><ol><li>5 个 MIME 邮件首部字段，可包含在邮件首部中。这些字段提供了有关邮件主体的信息；<ul><li>MIME-Version：标识 MIME 的版本；</li><li>Content-Description：可读字符串，用于对邮件内容的概括性描述，以便收件人对邮件的初步判断；</li><li>Content-Id：邮件的唯一标识符；</li><li>Content-Transfer-Encoding：说明在传送时邮件主体是如何编码的，最简单的编码是 7 位的 ASCII 码，而每行不能超过 1000 个字符，MIME 对这种由 ASCII 码构成的邮件主体不进行任何转换；另一种编码称为 quoted-printable，这种编码方法适用于当所传送的数据中只有少量的非 ASCII 码；对于任意的二进制文件（例如，图像文件、可执行程序等），采用 base64 编码；</li><li>Content-Type：说明邮件主体内容的类型和格式，例如，文本、图像、视频等；MIME 标准规定 Content-Type 必须含有两个标识符，即文本类型（type）和子类型（subtype），中间用「&#x2F;」分开。</li></ul></li><li>定义了多种邮件内容的格式，对多媒体电子邮件的表示方法进行了标准化；</li><li>定义了邮件传送编码，可对任何内容格式进行转换，从而适合通过 SMTP 进行传送；</li></ol><h4 id="5-4-邮件读取协议"><a href="#5-4-邮件读取协议" class="headerlink" title="5.4 邮件读取协议"></a>5.4 邮件读取协议</h4><p>目前 Internet 邮件系统中比较流行的邮件读取协议有第三版的邮局协议（Post Office Protocol-Version 3，POP3）、互联网邮件访问协议（Internet Mail Access Protocol，IMAP）和 HTTP，其中 HTTP 被用作 Web Mail 系统中的邮件读取协议。</p><h3 id="6-FTP"><a href="#6-FTP" class="headerlink" title="6. FTP"></a>6. FTP</h3><p> 文件传送协议（File Transfer Protocol，FTP）是在互联网的两个主机间实现文件互传的网络应用，其应用层协议也称为 FTP。</p><p>FTP 应用使用两个「并行」的 TCP 链接：控制连接和数据链接。</p><h3 id="7-P2P-应用"><a href="#7-P2P-应用" class="headerlink" title="7. P2P 应用"></a>7. P2P 应用</h3><p>在 P2P 应用中，每个对等方既是数据的获取者（消费者）又是数据的提供者（服务器）。</p>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 网络应用 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机网络概述</title>
      <link href="/2020/04/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%A6%82%E8%BF%B0/"/>
      <url>/2020/04/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%A6%82%E8%BF%B0/</url>
      
        <content type="html"><![CDATA[<p>面试官：请讲一下计算机网络的原理，以及你对它的理解。</p><p>我：<img src="https://personal-blog.oss-cn-hangzhou.aliyuncs.com/expression_0.jpg"></p><p>作为一枚野生程序猿，通过网络进行数据交换已成家常便饭，最常接触的就是 HTTP、HTTPS、SOCKET，但是，平常只是使用而已，没有深入研究过，一到面试就卡壳。那么今天就来扒一扒 <strong>计算机网络原理</strong> 到底是什么。</p><h3 id="1-计算机网络指的是什么？"><a href="#1-计算机网络指的是什么？" class="headerlink" title="1. 计算机网络指的是什么？"></a>1. 计算机网络指的是什么？</h3><p>首先说明一下，这里的<strong>「计算机」</strong>并不是通常意义上的 <strong>个人计算机（PC）</strong>、<strong>笔记本电脑</strong> 或者 <strong>服务器计算机</strong>，而应该包括所有带有计算能力的只能计算设备，比如：智能手机、智能家电等等。因此，我们应将<strong>「计算机」</strong>理解为<strong>「计算机设备」</strong>。</p><p>先来扒一扒计算机历史，计算机诞生之初，每台计算机都只在「自己范围内处理信息」，如果需要在不同计算机之间交换、分享信息，就只能通过存储介质等进行。随着计算机技术的发展，越来越需要在计算机之间进行快速、大量的信息交换，于是人们便将 <strong>计算机技术</strong> 与 <strong>通信技术</strong> 进行完美结合，诞生了计算机网络。</p><p>从技术范畴来看：</p><blockquote><p>计算机网络是「计算机技术」与「通信技术」相互融合的产物。</p></blockquote><p>计算机网络并没有一个统一的精确定义，通常指的是：</p><blockquote><p>计算机网络是利用 <strong>通信设备</strong> 与 <strong>通信链路</strong> 或者 <strong>通信网络</strong>，互连 <strong>位置不同</strong>、<strong>功能自治</strong> 的计算机系统，并遵循一定的规则实现计算机系统之间的信息交换。</p></blockquote><p>更为简短、概括性的定义为：</p><blockquote><p>计算机网络是 <strong>互连</strong> 的、<strong>自治</strong> 的计算机的集合。</p><blockquote><p>互连：指利用通信链路连接相互独立的计算机系统。通信链路可以是双绞线、光纤、微波、通信卫星等。</p><p>自治：指互连的计算机系统彼此独立，不存在主从或者控制与被控制的关系。</p></blockquote></blockquote><h3 id="2-经常听说「协议」这个词，在计算机网络中它指的是什么呢？"><a href="#2-经常听说「协议」这个词，在计算机网络中它指的是什么呢？" class="headerlink" title="2. 经常听说「协议」这个词，在计算机网络中它指的是什么呢？"></a>2. 经常听说「协议」这个词，在计算机网络中它指的是什么呢？</h3><p>前面简单介绍了「计算机」和「通信设备」，如同道路交通系统一样，道路修建好了，路网也建立了，硬件基础建立完毕。但是，如果没有交通规则进行制约，道路系统将会变成一团乱麻，同理，网络系统中，也需要遵循一些规则和约定，来保证网络稳定、有序、高效的运行，这些规则或约定，就是网络协议。</p><blockquote><p>协议约定了实体之间交换的信息类型、信息各部分的含义、信息交换顺序以及收到特定信息或出现异常时应采取的行为。</p></blockquote><p>协议三要素：</p><ol><li>语法（syntax）：定义实体之间交换信息的格式与结构，或者定义实体（比如硬件设备）之间传输信号的电平等。</li><li>语义（semantics）：定义实体之间交换的信息中心需要发送（或包含）哪些控制信息，这些信息的具体含义，以及针对不同含义的控制信息，接收信息端应如何响应。另外，有的协议还需要进行差错检测，这类协议通常会在协议信息中附加差错编码等控制信息。语义还需要定义彼此采用何种差错编码，以及采取何种差错处理机制等。</li><li>时序（timing）：也称为同步，定义实体之间交换信息的顺序以及如何匹配或适应彼此的速度。</li></ol><h3 id="3-计算机网络的功能"><a href="#3-计算机网络的功能" class="headerlink" title="3. 计算机网络的功能"></a>3. 计算机网络的功能</h3><ol><li>硬件资源共享：例如打印机、存储资源等</li><li>软件资源共享：例如 SaaS 服务等</li><li>信息资源共享：例如新闻阅读、信息检索等</li></ol><h3 id="4-计算机网络的分类"><a href="#4-计算机网络的分类" class="headerlink" title="4. 计算机网络的分类"></a>4. 计算机网络的分类</h3><h4 id="4-1-按覆盖范围"><a href="#4-1-按覆盖范围" class="headerlink" title="4.1 按覆盖范围"></a>4.1 按覆盖范围</h4><table><thead><tr><th align="center">名称</th><th align="center">场景</th><th align="center">范围</th></tr></thead><tbody><tr><td align="center">个域网（PAN）</td><td align="center">穿戴设备、便携式移动设备等</td><td align="center">1~10m</td></tr><tr><td align="center">局域网（LAN）</td><td align="center">办公室、办公楼、厂区、校园等</td><td align="center">10m~1km</td></tr><tr><td align="center">城域网（MAN）</td><td align="center">覆盖一个城市范围</td><td align="center">5~50km</td></tr><tr><td align="center">广域网（WAN）</td><td align="center">跨越更大的地理空间</td><td align="center">几十~几千 km</td></tr></tbody></table><h4 id="4-2-按拓扑结构分类"><a href="#4-2-按拓扑结构分类" class="headerlink" title="4.2 按拓扑结构分类"></a>4.2 按拓扑结构分类</h4><p><img src="https://personal-blog.oss-cn-hangzhou.aliyuncs.com/topology.png" alt="常见拓扑结构示意图"></p><table><thead><tr><th align="center">名称</th><th align="left">描述</th><th align="left">总结</th></tr></thead><tbody><tr><td align="center">星型拓扑结构（图 a）</td><td align="left">包含一个中央节点，网络中的主机通过点对点通信链路与中央节点连接</td><td align="left">优点：易于监控与管理，故障诊断与隔离容易；<br/>缺点：中央节点是网络的瓶颈，一旦故障，全网瘫痪，网络规模受限于中央节点的端口数量；</td></tr><tr><td align="center">总线型拓扑结构（图 b）</td><td align="left">采用一条广播信道作为公共传输介质，称为总线，所有节点均与总线连接，节点间的通信均通过共享的总线进行</td><td align="left">优点：结构简单，所需电缆数量少，易于扩展；<br/>缺点：通信范围受限，故障诊断与隔离较困难，容易产生冲突；</td></tr><tr><td align="center">环形拓扑结构（图 c）</td><td align="left">利用通信链路将所有节点连接成一个闭合的环</td><td align="left">优点：所需电缆长度短，可以使用光纤，易于避免冲突；<br/>缺点：某节点故障容易引起全网瘫痪，新节点的加入或撤出过程比较麻烦，存在等待时间问题；</td></tr><tr><td align="center">网状拓扑结构（图 d）</td><td align="left">网络中的节点通过多条链路与不同的节点直接连接</td><td align="left">优点：可靠性高，一条过多条链路故障时，网络仍然可联通；<br/>缺点：网络结构复杂，造价成本高，选路协议复杂；</td></tr><tr><td align="center">树形拓扑结构（图 e）</td><td align="left">可以看做是总线型拓扑或星型拓扑网络的扩展</td><td align="left">优点：易于扩展，故障隔离容易；<br/>缺点：对根节点的可靠性要求高，一旦根节点故障，则可能导致网络大范围无法通信；</td></tr><tr><td align="center">混合型拓扑结构（图 f）</td><td align="left">由两种以上简单拓扑结构网混合连接而成的网络</td><td align="left">优点：易于扩展，可以构建不同规模网络，并可根据需要优选网络结构；<br/>缺点：网络结构复杂，管理与维护复杂；</td></tr></tbody></table><h3 id="5-计算机网络结构（简单了解一下就好）"><a href="#5-计算机网络结构（简单了解一下就好）" class="headerlink" title="5. 计算机网络结构（简单了解一下就好）"></a>5. 计算机网络结构（简单了解一下就好）</h3><ol><li><p>网络边缘</p></li><li><p>接入网络</p><blockquote><ol><li>电话拨号接入</li><li>非对称数字用户线路 ADSL</li><li>混合光纤同轴电缆 HFC 接入网络</li><li>局域网</li><li>移动接入网络</li></ol></blockquote></li><li><p>网络核心</p></li></ol><h3 id="6-数据交换技术"><a href="#6-数据交换技术" class="headerlink" title="6. 数据交换技术"></a>6. 数据交换技术</h3><ol><li>电路交换</li><li>报文交换</li><li>分组交换</li></ol><blockquote><p>分组交换是目前计算机网络广泛采用的技术。分组交换需要将待传输数据（即报文）分割成较小的数据块，每个数据块附加上地址、序号等控制信息构成数据分组（packet），每个分组独立传输到目的地，目的地将受到的分组重新组装，还原为报文。分组传输过程通常也采用存储—转发交换方式。</p></blockquote><p>分组交换优点：</p><ol><li>交换设备存储容量要求低</li><li>交换速度快</li><li>可靠传输效率高</li><li>更加公平</li></ol><h3 id="7-计算机网络性能"><a href="#7-计算机网络性能" class="headerlink" title="7. 计算机网络性能"></a>7. 计算机网络性能</h3><ol><li>速率与带宽：指网络单位时间内传送的数据量，用以描述网络传输数据的快慢，也称为数据传输速率或数据速率；</li><li>时延：指数据从网络中的一个节点（主机或交换设备等）到达另一节点所需要的时间；包括 <strong>节点处理时延（nodal processing delay）</strong>、<strong>排队时延（queueing delay）</strong>、<strong>传输时延（transmission delay）</strong> 和 <strong>传播时延（propagation delay）</strong>；</li><li>时延带宽积：指一段物理链路的传播时延与链路带宽的乘积；</li><li>丢包率：当网络拥塞特别严重时，新到达的分组甚至已无缓存空间暂存该分组，此时交换节点会丢弃分组，就会发生「丢包」现象；</li><li>吞吐量：表示在单位时间内源主机通过网络向目的主机实际送达的数据量；</li></ol><h3 id="8-计算机网络体系结构"><a href="#8-计算机网络体系结构" class="headerlink" title="8. 计算机网络体系结构"></a>8. 计算机网络体系结构</h3><h4 id="8-1-OSI-参考模型"><a href="#8-1-OSI-参考模型" class="headerlink" title="8.1 OSI 参考模型"></a>8.1 OSI 参考模型</h4><p><img src="https://personal-blog.oss-cn-hangzhou.aliyuncs.com/OSI.jpeg" alt="OSI 参考模型描述的数据封装和传输过程"></p><p>从上层往下层依次介绍：</p><blockquote><p>应用层：给用户提供网络服务，包括文件传送、电子邮件、P2P 应用等。应用层为用户提供了一个使用网络应用的「接口」；</p><p>表示层：</p><blockquote><ol><li>主要用于处理应用实体间交换数据的语法，目的是解决格式和数据表示的差别，从而为应用提供一个一致的数据格式，使字符、格式等有差异的设备之间相互通信；</li><li>实现文本压缩&#x2F;解压缩、数据加密&#x2F;解密、字符串彪马的转换等功能；</li></ol></blockquote><p>会话层：</p><blockquote><ol><li>在建立会话时核实双方身份是否有权参加会话；</li><li>确定双方支付通信费用；</li><li>双方在各种选择功能方面（如全双工还是半双工通信）取得一致；</li><li>在会话建立以后，需要对进程间的对话进行管理与控制；</li></ol></blockquote><p>传输层：主要功能包括复用&#x2F;分解（区分发送和接收主机上的进程），端到端的可靠数据传输、连接控制、流量控制和拥塞控制机制等</p><p>网络层：</p><blockquote><ol><li>数据转发与路由；</li><li>对进入交换网络的通信量加以控制，以避免通信量过大造成交换网络性能下降；</li><li>寻址功能，确保分组可以被正确传输到目的主机；</li></ol></blockquote><p>数据链路层：</p><blockquote><ol><li>实现在相邻节点之间数据可靠而有效的传输；</li><li>寻址，确保每一帧都能准确地传送到正确的接收方，接收方也有关知道发送方的地址；</li></ol></blockquote><p>物理层：主要功能是在传输介质上实现无结构比特流传输；</p></blockquote><p>参考模型高低层划分：</p><ul><li>网络底层：主要完成数据交换和数据传输。包含物理层、数据链路层、网络层；</li><li>衔接层：传输层；</li><li>网络高层：主要是完成信息处理服务的功能。包含会话层、表示层、应用层；</li></ul><p><strong>PS：实际应用的网络中几乎没有严格按照 OSI 参考模型构件的。OSI 参考模型的意义在于它是一种计算机网络的理论体系结构，是目前学习、讨论计算机网络的一种工具，能够从理论上很好地解释网络概念、层次与通信过程，是学习计算机网络必须学习和掌握的内容。</strong></p><h4 id="8-2-TCP-IP-参考模型"><a href="#8-2-TCP-IP-参考模型" class="headerlink" title="8.2 TCP&#x2F;IP 参考模型"></a>8.2 TCP&#x2F;IP 参考模型</h4><p><img src="https://personal-blog.oss-cn-hangzhou.aliyuncs.com/TCP_IP.jpeg" alt="TCP/IP 参考模型"></p><blockquote><ol><li><p>应用层：TCP&#x2F;IP 参考模型将 OSI 参考模型中会话层和表示层的功能合并到了应用层来实现；</p></li><li><p>传输层：主要包括面向连接、提供可靠数据流传输的传输控制协议 TCP 和无连接不提供可靠数据传输的用户数据报协议 UDP；</p></li><li><p>网络互连层：是整个参考模型的核心，主要解决把数据分组发往目的网络或主机的问题；（IP 是无连接不可靠网络协议）</p></li><li><p>网络接口层：实际上，TCP&#x2F;IP 参考模型没有真正描述这一层的实现，只是要求能够提供给其上层—网络互连层一个访问接口，以便在其上传递 IP 分组；</p></li></ol></blockquote><h4 id="8-3-五层参考模型"><a href="#8-3-五层参考模型" class="headerlink" title="8.3 五层参考模型"></a>8.3 五层参考模型</h4><p>对比 TCP&#x2F;IP 参考模型与 OSI 参考模型，TCP&#x2F;IP 参考模型缺少 OSI 参考模型中功能比较少的会话层与表示层，而 TCP&#x2F;IP 参考模型的网络接口层则相当于合并了 OSI 参考模型的数据链路层与物理层。结合这两个参考模型，可以提出综合理论需求与实际网络的五层参考模型，包括 <strong>物理层</strong>、<strong>数据链路层</strong>、<strong>网络层</strong>、<strong>传输层</strong> 与 <strong>应用层</strong>，各层功能基本与 OSI 参考模型对应。</p><p><img src="https://personal-blog.oss-cn-hangzhou.aliyuncs.com/five_layer.jpeg" alt="五层参考模型"></p>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
            <tag> 概述 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>物理层</title>
      <link href="/2018/01/10/%E8%87%AA%E5%AD%A6/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86/%E7%89%A9%E7%90%86%E5%B1%82/"/>
      <url>/2018/01/10/%E8%87%AA%E5%AD%A6/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86/%E7%89%A9%E7%90%86%E5%B1%82/</url>
      
        <content type="html"><![CDATA[<p>物理层位于 OSI 参考模型的最底层，它的主要功能室实现比特流的透明传输，为数据链路层提供数据传输服务。它直接面向实际承担数据传输的物理介质（即通信信道）。物理层的传输单位为比特（bit），即一个二进制位（「0」或「1」）。</p><p>物理层不是指具体的物理设备，也不是指信号传输的物理介质，而是指在物理介质之上为上一层（即数据链路层）提供一个传输原始比特流的物理连接。</p><h3 id="1-物理层接口协议"><a href="#1-物理层接口协议" class="headerlink" title="1. 物理层接口协议"></a>1. 物理层接口协议</h3><h4 id="1-1-物理层接口"><a href="#1-1-物理层接口" class="headerlink" title="1.1 物理层接口"></a>1.1 物理层接口</h4><p>物理层上的协议有时也称为接口。物理层协议规定了与建立、维持及断开物理信道有关的特性，这些特性包括机械的、电气的、功能性的和规程性的四个方面。这些特性确保物理层能通过物理信道在相邻网络节点之间正确地收、发比特流信息，即确保比特流能送上物理信道，并且能在另一端取下它。</p><p>ISO 对 OSI 模型的物理层所作的定义为：在物理信道实体之间合理地通过中间系统，为比特传输所需的物理连接的激活、保持和去除提供机械的、电气的、功能性和规程性的手段。比特流传输可以采用异步传输，也可以采用同步传输完成。</p><h4 id="1-2-物理层的功能和提供的服务"><a href="#1-2-物理层的功能和提供的服务" class="headerlink" title="1.2 物理层的功能和提供的服务"></a>1.2 物理层的功能和提供的服务</h4><p><strong>1. 机械特性</strong></p><p>DTE 与 DCE 之间通过多根导线相互联系。</p><p><strong>2. 电气特性</strong></p><p>DTE 与 DCE 之间有多根导线相连，这些导线中除了地线以外，其它信号线均有方向性。物理层的电气特性规定了这组导线的电气连接及有关电路的特性，一般包括：接收器和发送器电路特性的说明，表示信号状态的电压&#x2F;电流电平的识别、最大数据传输速率的说明，以及互连电缆相关的规范等。</p><p>DTE 与 DCE 接口的各根导线（也称电路）的电气连接方式有非平衡方式、采用差动接收器的非平衡方式和平衡方式三种。</p><p><strong>3. 信号的功能特性</strong></p><p>物理层的功能特性规定了接口信号的来源、作用以及其它信号之间的关系。接口信号线按功能一般可分为数据信号线、控制信号线、定时信号线和接地线等四类。信号线的名称可以采用数字、字母组合或英文缩写三种方式来命名。</p><p><strong>4. 规程特性</strong></p><p>物理层的规程特性规定了使用交换电路进行数据交换的控制步骤，这些控制步骤的应用使得比特流传输得以完成。</p><h4 id="1-3-物理层协议举例"><a href="#1-3-物理层协议举例" class="headerlink" title="1.3 物理层协议举例"></a>1.3 物理层协议举例</h4><ol><li>EIA RS - 232C 接口标准</li><li>EIA RS - 449 及 RS - 422 与 RS - 423 接口标准</li><li>100 系列和 200 系列接口标准</li><li>X.21 和 X.21 bis 建议</li></ol><h3 id="2-传输介质"><a href="#2-传输介质" class="headerlink" title="2. 传输介质"></a>2. 传输介质</h3><p>传输介质是通信网络中发送方和接收方之间的物理通路，计算机网络中采用的传输介质可分为有线和无线两大类。</p><p>传输介质的特性对网络数据通信质量有很大影响，这些特性是：</p><ol><li>物理特性。说明传输介质的特征。</li><li>传输特性。包括信号形式、调制技术、传输速率及频带宽度等内容。</li><li>连通性。采用点到点连接还是多点连接。</li><li>地理范围。网上各点间的最大距离。</li><li>抗干扰性。防止噪音、电磁干扰对数据传输影响的能力。</li><li>相对价格。以元件、安装和维护的价格为基础。</li></ol><h4 id="2-1-双绞线"><a href="#2-1-双绞线" class="headerlink" title="2.1 双绞线"></a>2.1 双绞线</h4><p>由螺旋状扭在一起的两根、四根或八根绝缘导线组成，线对扭在一起可以减少相互间的辐射电磁干扰。</p><h4 id="2-2-同轴电缆"><a href="#2-2-同轴电缆" class="headerlink" title="2.2 同轴电缆"></a>2.2 同轴电缆</h4><p>同轴电缆也像双绞线一样由一对导体组成，但它们是按「同轴」形式构成线对。</p><h4 id="2-3-光纤"><a href="#2-3-光纤" class="headerlink" title="2.3 光纤"></a>2.3 光纤</h4><p>光纤是光导纤维的简称，它由能传导光波的超细石英玻璃纤维外加保护层构成。多条光纤组成一束，就构成一条光缆。</p><h4 id="2-4-无线传输介质"><a href="#2-4-无线传输介质" class="headerlink" title="2.4 无线传输介质"></a>2.4 无线传输介质</h4><p>无线传输介质需要通过空间传输，不需要架设或铺埋电缆或光纤，目前常用的技术按照频率由低向高排列有：无线电波、微波、红外线和可见光。</p><h4 id="2-5-传输介质的选择"><a href="#2-5-传输介质的选择" class="headerlink" title="2.5 传输介质的选择"></a>2.5 传输介质的选择</h4><p>传输介质的选择取决于以下诸因素：网络拓扑的结构、实际需要的通信容量、可靠性要求、能承受的价格范围。</p><h3 id="3-数据通信技术"><a href="#3-数据通信技术" class="headerlink" title="3. 数据通信技术"></a>3. 数据通信技术</h3><h4 id="3-1-通信信道"><a href="#3-1-通信信道" class="headerlink" title="3.1 通信信道"></a>3.1 通信信道</h4><p>数据通信的任务是传输数据信息，希望达到传输速度快、出错率低、信息量大、可靠性高，并且既经济又便于使用维护。</p><p><strong>1. 数据传输速率</strong></p><p>所谓数据传输速率，是指每秒能传输的二进制信息位数，单位为位&#x2F;秒（Bits Per Second），记作 bps 或 b&#x2F;s，它可由下式确定：</p><p><strong>R &#x3D; (log<sub>2</sub>N)&#x2F;T (bps)</strong></p><p>式中 T 为一个数字脉冲信号的宽度（全款码情况）或重复周期（归零码情况），单位为秒。一个数字脉冲也成为一个码元，N 为一个码元所取的有效离散值个数，也称调制电平数，N 一般取 2 的整数次方值。</p><p><strong>2. 信道容量</strong></p><p>信道容量表征一个信道传输数据的能力，单位也用位&#x2F;秒（bps）。信道容量与数据传输速率的区别在于，前者表示信道的最大数据传输速率，是信道传输数据能力的极限，而后者则表示实际的数据传输速率。</p><p><strong>3. 误码率</strong></p><p>误码率是衡量数据通信系统在正常工作情况下的传输可靠性的指标，它定义为二进制数据位传输时出错的概率。设传输的二进制数据总数为 N 位，其中出错的位数为 N<sub>e</sub>，则误码率表示为：P<sub>e</sub>&#x3D;N<sub>e</sub>&#x2F;N</p><p><strong>4. 通信方式</strong></p><p>在计算机内部各部件之间、计算机与各种外部设备之间及计算机与计算机之间都是以通信的方式传递交换数据信息的。通信有两种基本方式，即串行方式和并行方式。通常情况下，并行方式用于近距离通信，串行方式用于距离较远的通信。在计算机网络中，串行通信方式更具有普遍意义。</p><h4 id="3-2-模拟数据通信和数字数据通信"><a href="#3-2-模拟数据通信和数字数据通信" class="headerlink" title="3.2 模拟数据通信和数字数据通信"></a>3.2 模拟数据通信和数字数据通信</h4><p>几个基本术语解释：</p><ol><li>数据。数据可定义为有意义的实体，它涉及事务存在形式。数据可分为模拟数据和数字数据两大类。模拟数据是在某个区间内连续变化的值，例如声音和视频都是幅度连续变化的波形，又如温度和压力也都是连续变化的值；数字数据是离散的值，例如文本信息和整数。</li><li>信号。信号是数据的电子或电磁编码。对应于模拟数据和数字数据，信号也可分为模拟信号和数字信号。模拟信号是随时间连续变化的电流、电压或电磁波，可以利用其某个参量（如幅度、频率或相位等）来表示要传输的数据；数字信号则是一系类离散的电脉冲，可以利用其某一瞬间的状态来表示要传输的数据。</li><li>信息。信息是数据的内容和解释。</li><li>信源。信源即通信过程中产生和发送信息的设备或计算机。</li><li>信宿。信宿即通信过程中接收和处理信息的设备或计算机。</li><li>信道。信道是信源和信宿之间的通信线路。</li></ol><h4 id="3-3-多路复用技术"><a href="#3-3-多路复用技术" class="headerlink" title="3.3 多路复用技术"></a>3.3 多路复用技术</h4><p>在数据通信系统或计算机网络系统中，传输介质的带宽或容量往往超过传输单一信号的需求，为了有效地利用通信线路，希望一个信道同时传输多路信号，这就是所谓的多路复用技术（Multiplexing）。采用多路复用技术能把多个信号组合起来在一条物理信道上进行传输，在远距离传输时可大大节省电缆的安装和维护费用。</p><p>频分多路复用 FDM（Frequency Division Multiplexing）和时分多路复用 TDM（Time Division Multiplexing） 是两种最常用的多路复用技术。</p><p>对于光纤信道，还是用频分多路复用的一个变种称为波分多路复用 WDM（Wavelength Division Multiplexing）。</p><h4 id="3-4-异步传输和同步传输"><a href="#3-4-异步传输和同步传输" class="headerlink" title="3.4 异步传输和同步传输"></a>3.4 异步传输和同步传输</h4><p><strong>1. 异步传输</strong></p><p>异步传输即前面介绍过的群同步传输。异步传输方式中，一次只传输一个字符（由5~8位数据组成）。每个字符用一位起始位引导、一位停止位结束。</p><p><strong>2. 同步传输</strong></p><p>同步传输时，为使接收方能判定数据块的开始和结束，还须在每个数据块的开始处和结束处各加一个帧头和一个帧尾，加有帧头、帧尾的数据称为一帧（Frame）。帧头和帧尾的特性取决于数据块是面向字符还是面向位的。</p><h3 id="4-数据编码"><a href="#4-数据编码" class="headerlink" title="4. 数据编码"></a>4. 数据编码</h3><p>除了模拟数据的模拟信号直接传输外，数字数据的模拟信号传输、数字数据和模拟数据的数字信号传输都需要进行某种形式的数据表示或者称数据编码。</p><h4 id="4-1-数据编码技术"><a href="#4-1-数据编码技术" class="headerlink" title="4.1 数据编码技术"></a>4.1 数据编码技术</h4><p><strong>1. 数字数据的数字信号编码</strong></p><p>数字信号可以直接采用基带传输，所谓基带就是指表示二进制比特序列的矩形脉冲信号所占的固有频带，称为基本频带（简称基带）。基带传输就是在线路中直接传送数字信号的电脉冲，这是一种最简单的传输方式，近距离通信的局域网都采用基带传输。</p><p><strong>2. 模拟数据的数字信号编码</strong></p><p>对模拟数据进行数字信号编码的最常用方法是脉码调制 PCM（Pulse Code Modulation），它常用于对声音信号进行编码。脉码调制是以采样定理为基础的，该定理从数学上证明：若对连续变化的模拟信号进行周期性采样，只要采样频率大于等于有效信号最高频率或其带宽的两倍，则采样值便可包含原始信号的全部信息，利用低通滤波器可以从这些采样中重新构造出原始信号。设原始信号的最高频率为 F<sub>max</sub>，采样频率为 F<sub>s</sub>，则采样定理可以下式表示：</p><p><strong>F<sub>s</sub>(&#x3D;1&#x2F;T<sub>s</sub>)≥2F<sub>max</sub> 或 F<sub>s</sub>≥2B<sub>s</sub></strong></p><p>式中 T<sub>s</sub> 为采样周期，B<sub>s</sub>(&#x3D;F<sub>max</sub> - F<sub>min</sub>) 为原始信号的带宽。</p><h4 id="4-2-调制解调器"><a href="#4-2-调制解调器" class="headerlink" title="4.2 调制解调器"></a>4.2 调制解调器</h4><p>传输线路存在三个主要的问题：衰减（Attenuation）、延迟畸变（Delay Distortion）和噪声（Noise）。衰减是指信号传播的过程中能量的损失。这种损失可以表示为每公里多少分贝。能量损失的数量跟频率有关。信号并非是一个简单的波形，而是傅里叶级数中的一些分量。每个分量被衰减的程度不同，因而导致了在接收方得到一个完全不同的傅里叶频谱。</p><p>更糟的是，不同的傅里叶分量在线路上的传播速度也不同。这种速度的差异会导致接收端信号的畸变。</p><ol><li>模拟用户线路的调制解调器</li><li>数字用户线路（Digital Subscriber Lines）</li></ol><h3 id="5-数据交换技术"><a href="#5-数据交换技术" class="headerlink" title="5. 数据交换技术"></a>5. 数据交换技术</h3><p>数据经编码后在通信线路上进行传输的最简单形式，是在两个互连的设备之间直接进行数据通信。</p><h4 id="5-1-电路交换（Circuit-Switching）"><a href="#5-1-电路交换（Circuit-Switching）" class="headerlink" title="5.1 电路交换（Circuit Switching）"></a>5.1 电路交换（Circuit Switching）</h4><p>电话交换网是使用电路交换技术的典型例子。采用电路交换技术进行数据传输期间，在源节点与目的节点之间有一条利用中间节点构成的专用物理连接线路，直到数据传输结束。如果两个相邻节点之间的信道容量很大时，这两个相邻节点之间可以复用多条线路。用电路交换技术完成数据传输要经历以下电路建立、数据传输、电路拆除三个过程。</p><p>电路交换方式的优点是数据传输可靠、迅速，数据不会丢失且保持原来的序列。缺点是在某些情况下，电路空闲时的信道容量被浪费；另外，当数据传输阶段的持续时间不长时，电路建立和拆除所用的时间就会得不偿失。因此，它适用于系统间要求高质量的大量数据传输的情况。这种通信方式的计费方法一般按照预定的带宽、距离和时间来计算。</p><h4 id="5-2-报文交换（Message-Switching）"><a href="#5-2-报文交换（Message-Switching）" class="headerlink" title="5.2 报文交换（Message Switching）"></a>5.2 报文交换（Message Switching）</h4><p>报文交换方式的数据传输单位是报文，报文就是站点一次性要发送的数据块，其长度不限且可变。报文交换不需要在两个站之间建立专用通路，传送方式采用「存储-转发」方式。</p><p>与电路交换比较，报文交换有如下有点：</p><ol><li>电路利用效率高。由于许多报文可以分时共享两节点之间的通道，所以对于同样的通信量来说，对电路的传输能力要求较低。</li><li>在电路交换网络上，当通信量变得很大时，就不能接受新的呼叫。而在报文交换网络上，通信量大时仍然可以接收报文，不过传送延迟会增加。</li><li>报文交换系统可以把一个报文发送到多个目的地，而电路交换网络很难做到这一点。</li><li>报文交换网络可以进行速度和代码的转换。因为每个站可以用它特有的数据传输率连接到其它节点，所以两个不同传输速率的站也可以相互连接；报文交换网络还能转换数据的格式（例如从 ASCII 码转换成 EBCDIC 码），这些特点在电路交换系统中往往很难做到。</li></ol><p>报文交换系统的主要缺点是：它不能满足实时或交互式的通信要求，报文经过网络的延迟时间长且不定。因此，这种方式不能用于语音连接，也不适合于交互式终端到计算机的连接。有时节点收到过多的数据而无空间存储或不能及时转发时，就不得不丢弃报文，而且发出的报文不按顺序到达目的地。其计费一般是根据通信的流量和时间来计算。报文交换也已不再使用。</p><h4 id="5-3-分组交换（Packet-Switching）"><a href="#5-3-分组交换（Packet-Switching）" class="headerlink" title="5.3 分组交换（Packet Switching）"></a>5.3 分组交换（Packet Switching）</h4><p>为了更好地利用信道容量，并降低节点中数据量的突发性，可以将报文交换改进为分组交换，即将一个报文分成若干个分组，每个分组的长度有一个上线，典型的最大长度是数千位。</p><p>有限长度的分组使每个节点所需要的存储能力降低了，分组可以存储在内存中，而不是硬盘上，提高了交换速度。分组交换适用于交互式通信，如终端与主机通信。分组交换的具体过程又可分为虚电路分组交换和数据报文分组交换两种。</p><h4 id="5-4-高速交换"><a href="#5-4-高速交换" class="headerlink" title="5.4 高速交换"></a>5.4 高速交换</h4><p>目前光交换技术发展主要有以下几种：</p><p><strong>1. 微电子机械系统（MEMS）的光交换机</strong></p><p>基于 MEMS 的光交换机在入口光纤和出口光纤之间使用微镜阵列，阵列中的镜元可以在光纤之间任意改变角度来改变光束传输方向，达到实时对光信号进行重新选路的目的。当一路波长光信号照到镜面时，镜面倾斜以便将其引导到某一特定出口光纤中，从而实现光路倒换的目的。</p><p><strong>2. 无交换式光路由器</strong></p><p>它使用具有波长发射和控制功能的奇偶啊换功能模块取代了传统的外围光开关交换网络。其关键模块是一种自由空间色差校正凹面光栅，通过它将入射光纤阵列中的波长信道进行发散后，再聚集到出射光纤阵列中相互独立的单路光纤上，就可实现 91 x 91 的波长路由器功能。</p><p><strong>3. 阵列波导光栅路由器</strong></p><p>构成阵列波导光栅的是许多长度按 L 线性递增（即各路光波的相位差恒定）的光臂，可实现波分复用与解复用以及静态波长路由功能，并具备双向传输的特性。</p><h4 id="5-5-交换技术的比较"><a href="#5-5-交换技术的比较" class="headerlink" title="5.5 交换技术的比较"></a>5.5 交换技术的比较</h4><p>不同的交换技术适用于不同的场合：对于交互式通信来说，报文交换肯定是不适合的；对于较轻和间歇式负载来说，电路交换是最合适的，可以通过电话拨号线路来实行通信；对于较重和持续的负载来说，使用租用的线路以电路交换方式实行通信是合适的；对于必须交换中等到大量数据的情况，可用分组交换方法。</p><p>下面简单小结一下三种交换技术的主要特点：</p><ol><li>电路交换。在数据传送开始之前必须先设置一条专用的通路。在线路释放之前，该通路由一对用户完全占用。对于触发式的通信，电路交换效率不高。</li><li>报文交换。报文从源点传送到目的地采用「存储-转发」的方式，在传送报文时，一个时刻仅占用一段通道。在交换节点中需要缓冲存储，报文需要排队，故报文交换不能满足实时通信的要求。</li><li>分组交换。交换方式和报文交换方式类似，但报文被分成分组传送，并规定了最大的分组长度。在数据报分组交换中，目的地需要重新组装报文；在虚电路分组交换中，数据传送之前必须通过虚呼叫设置一条虚电路。分组交换技术是计算机网络中使用最广泛的一种交换技术。</li></ol><p><strong><center>电路交换和分组交换的比较</center></strong></p><table><thead><tr><th align="left">项目</th><th align="left">电路交换</th><th align="left">分组交换</th></tr></thead><tbody><tr><td align="left">建立呼叫连接</td><td align="left">要求</td><td align="left">不要求</td></tr><tr><td align="left">专门的物理路径</td><td align="left">是</td><td align="left">否</td></tr><tr><td align="left">每个分组沿着同样的路由路径</td><td align="left">是</td><td align="left">否</td></tr><tr><td align="left">电文或分组按序到达</td><td align="left">是</td><td align="left">否</td></tr><tr><td align="left">一台交换机奔溃是否有严重影响</td><td align="left">是</td><td align="left">否</td></tr><tr><td align="left">可用带宽</td><td align="left">固定</td><td align="left">动态</td></tr><tr><td align="left">可能拥塞的时间点</td><td align="left">建立呼叫连接的时候</td><td align="left">每个分组传送的时候</td></tr><tr><td align="left">可能有浪费的带宽</td><td align="left">是</td><td align="left">否</td></tr><tr><td align="left">存储-转发传输机制</td><td align="left">否</td><td align="left">是</td></tr><tr><td align="left">透明性</td><td align="left">是</td><td align="left">否</td></tr><tr><td align="left">收费</td><td align="left">每分钟</td><td align="left">每个分组</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> 自学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络原理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机网络体系结构</title>
      <link href="/2018/01/03/%E8%87%AA%E5%AD%A6/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/"/>
      <url>/2018/01/03/%E8%87%AA%E5%AD%A6/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/</url>
      
        <content type="html"><![CDATA[<p>计算机网络体系结构是现代计算机网络的核心。</p><h3 id="1-网络的分层体系结构"><a href="#1-网络的分层体系结构" class="headerlink" title="1. 网络的分层体系结构"></a>1. 网络的分层体系结构</h3><h4 id="1-1-协议的要素"><a href="#1-1-协议的要素" class="headerlink" title="1.1 协议的要素"></a>1.1 协议的要素</h4><p>网络协议主要由下列三个要素组成：</p><ol><li>语义（Semantics）。涉及用于协调与差错处理的控制信息。</li><li>语法（Syntax）。涉及数据及控制信息的格式、编码及信号电平等。</li><li>定时（Timing）。涉及速度匹配和排序等。</li></ol><h4 id="1-2-分层体系结构"><a href="#1-2-分层体系结构" class="headerlink" title="1.2 分层体系结构"></a>1.2 分层体系结构</h4><p>计算机网络都采用层次化的体系结构。这种层次结构的要点可归纳如下：</p><ol><li>除了在物理介质上进行的是实通信之外，其余各对等实体间进行的都是虚通信</li><li>对等层的虚通信必须遵循该层的协议</li><li>n 层的虚通信是通过 n&#x2F;n-1 层间接口处 n-1 层提供的服务以及 n-1 层的通信（通常也是虚通信）来实现的</li></ol><p>层次结构的划分，一般要遵循以下原则：</p><ol><li>每层的功能应是明确的，并且是相互独立的。当某一层的具体实现方法更新时，只要保持上、下层的接口不变，便不会对邻层产生影响</li><li>层间接口必须清晰，跨越接口的信息量应尽可能少</li><li>层数应适中。若层数太少，则多种功能混杂在一层中，造成每一层的协议太复杂；若层数太多，则体系结构过于复杂，使描述和实现各层功能变得困难</li></ol><h3 id="2-OSI-RM-开放系统互联参考模型"><a href="#2-OSI-RM-开放系统互联参考模型" class="headerlink" title="2. OSI&#x2F;RM 开放系统互联参考模型"></a>2. OSI&#x2F;RM 开放系统互联参考模型</h3><h4 id="2-1-OSI-RM-简介"><a href="#2-1-OSI-RM-简介" class="headerlink" title="2.1 OSI&#x2F;RM 简介"></a>2.1 OSI&#x2F;RM 简介</h4><p>开放系统互连（Open System Interconnection）基本参考模型是由国际标准化组织（ISO）制定的标准化开放式计算机网络层次结构模型，又称 ISO’S OSI 参考模型。「开放」这个词表示能使任何两个遵守参考模型和有关标准的系统进行互连。</p><p>OSI 包括了体系结构、服务定义和协议规范三级抽象。OSI 的体系结构定义了一个七层模型，用以进行进程间的通信，并作为一个框架来协调各层标准的制定；OSI 的服务定义描述了各层所提供的服务，以及层与层之间的抽象接口和交互用的服务原语；OIS 各层的协议规范，精确地定义了应当发送何种控制信息及用何种过程来解释该控制信息。</p><h4 id="2-2-OSI-RM-的结构"><a href="#2-2-OSI-RM-的结构" class="headerlink" title="2.2 OSI&#x2F;RM 的结构"></a>2.2 OSI&#x2F;RM 的结构</h4><p>简而言之，OSI 参考模型将网络划分为七层，OSI 七层模型从下到上分别为物理层（Physical Layer，PH）、数据链路层（Data Link Layer，DL）、网络层（Network Layer，N）、传输层（也称运输层）（Transport Layer，T）、会话层（Session Layer，S）、表示层（Presentation Layer，P）和应用层（Application Layer，A）。</p><p>各层的功能：</p><ol><li>物理层定义了为建立、维护和拆除物理链路所需的机械的、电气的、功能的和规程的特性，其作用是使原始的数据比特流能在物理介质上传输。具体涉及接插件的规格，「0」、「1」信号的电平表示，收发双方的协调等内容</li><li>在数据链路层中，比特流被组织成数据链路协议数据单元（通常称为帧），并以其为单位进行传输，帧中包含地址、控制、数据及校验码等信息。数据链路层的主要作用是通过校验，确认和反馈重发等手段，将不可靠的物理链路改造成对网络层来说是无差错的数据链路。数据链路层还要协调收发双方的数据传输速率，即进行流量控制，以防止接收方因来不及处理发送方来的高速数据而导致缓冲器溢出及线路阻塞</li><li>在网络层中，数据以网络协议数据单元（通常称为分组）为单位进行传输。网络层关心的是通信子网的运行控制，主要解决如何使数据分组跨越通信子网从源传送到目的地的问题，这就需要在通信子网中进行路由选择。另外，为避免通信子网中出现过多的分组而造成网络阻塞，需要对流入的分组数量进行控制。当分组要跨越多个通信子网才能到达目的地时，还要解决网际互联的问题</li><li>传输层是第一个端-端，也即主机-主机的层次。传输层提供的端到端的透明数据传输服务，使高层用户不必关心通信子网的存在，由此用统一的数据原语书写的高层软件便可运行于任何通信子网上。传输层还要处理端到端的差错控制和流量控制问题</li><li>会话层是进程-进程的层次，其主要功能室组织和同步不同主机上各种进程间的通信（也称为对话）。会话层负责在两个会话层实体之间进行对话进行对话连接的建立和拆除。在半双工情况下，会话层提供一种数据权标来控制某一方何时有权发送数据。会话层还提供在数据流中插入同步点的机制，使得数据传输因网络故障而中断后，可以不必从头开始而仅重传最近一个同步点以后的数据</li><li>表示层为上层用户提供共同的数据或信息语法表示变换。为了让采用不同编码方法的计算机在通信中能相互理解数据的内容，可以采用抽象的标准方法来定义数据结构，并采用标准的编码表示形式。表示层管理这些抽象的数据结构，并将计算机内部的表示形式转换成网络通信中采用的标准表示形式。数据压缩&#x2F;恢复和加密&#x2F;解密也是表示层可提供的表示变换功能</li><li>应用层是开放系统互联环境的最高层。不用的应用层为特定类型的网络应用提供访问 OSI 环境的手段。网络环境下不同主机间的文件传送访问和管理（FTAM）、传送标准电子邮件的文电处理系统（MHS）、使不同类型的终端和主机通过网络交互访问的虚拟终端（VT）协议等都属于应用层的范畴</li></ol><h4 id="2-3-面向连接服务与无连接服务"><a href="#2-3-面向连接服务与无连接服务" class="headerlink" title="2.3 面向连接服务与无连接服务"></a>2.3 面向连接服务与无连接服务</h4><p><strong>1. 通信服务类型</strong></p><p>通信服务可以分为两大类：面向连接服务（Connection-oriented Services）和无连接服务（Connectionless Services）。</p><p>面向连接服务和电话系统的工作模式相类似。其特点是：数据传输过程前必须经过建立连接、维护连接和释放链接的3个过程；在数据传输过程中，各分组不需要携带目的节点的地址。</p><p>无连接服务与邮政系统的信件投递过程相类似。其特点是：每个分组都要携带完整的目的节点的地址，各分组在通信子网中是独立传送的，因此，无连接服务中的数据传输过程不需要进过建立连接、维护连接和释放连接的三个过程；由于无连接服务中发送的不同分组可能选择不同路径到达目的节点，先发送的不一定先到达，因此无连接服务中的目的节点接收到的数据分组可能出现混乱、重复与丢失的现象。但因其省去了建立连接的开销和许多保证机制，因此通信协议相对简单，效率较高。</p><p><strong>2. 确认和重传机制</strong></p><p>确认是指数据分组接收节点在收到每个分组后，要求向发送节点回送正确接收分组的确认信息。在规定时间内，如果发送节点没有接收到接收节点返回的确认信息，就认为该数据分组发送失败，发送节点重传该数据分组。</p><p><strong>3. 服务类型和服务质量</strong></p><p>在网络的各个层次的设计中，可以在面向连接与确认服务、面向连接与不确认服务、无连接与确认服务、无连接与不确认服务这 4 种情况中，根据不同的通信要求，决定选择不同的服务类型。</p><h3 id="3-TCP-IP-参考模型"><a href="#3-TCP-IP-参考模型" class="headerlink" title="3. TCP&#x2F;IP 参考模型"></a>3. TCP&#x2F;IP 参考模型</h3><h4 id="3-1-TCP-IP-简介"><a href="#3-1-TCP-IP-简介" class="headerlink" title="3.1 TCP&#x2F;IP 简介"></a>3.1 TCP&#x2F;IP 简介</h4><p>TCP&#x2F;IP 协议具有以下几个特点：</p><ol><li>开放的协议标准，可以免费使用，并且独立于特定的计算机硬件与操作系统</li><li>独立于特定的网络硬件，可以运行在局域网、广域网，更适用于互联网中</li><li>统一的网络地址分配方案，使得整个 TCP&#x2F;IP 设备在网中都具有唯一的地址</li><li>标准的高层协议，可以提供多种可靠的用户服务</li></ol><h4 id="3-2-TCP-IP-的体系结构"><a href="#3-2-TCP-IP-的体系结构" class="headerlink" title="3.2 TCP&#x2F;IP 的体系结构"></a>3.2 TCP&#x2F;IP 的体系结构</h4><p>协议分层模型包括两方面的内容：一是层次结构，二是各层功能的描述。</p><p>TCP&#x2F;IP 参考模型可以分为 4 个层次：应用层、传输层、互连层、主机-网络层。</p><p>TCP&#x2F;IP 是一组协议的代名词，它还包括许多别的协议，组成了 TCP&#x2F;IP 协议簇。一般来说，TCP 提供传输层服务，而 IP 提供网络层服务。</p><p>在 TCP&#x2F;IP 层次模型中，主机-网络层是 TCP&#x2F;IP 参考模型的最底层，是 TCP&#x2F;IP 的实现基础，它包括 TCP&#x2F;IP 赖以存在的各种通信网与 TCP&#x2F;IP 之间的接口和物理网络协议，这些通信网络包括多种广域网，以及各种局域网。</p><p>在互连层中，IP 为互联网协议（Internet Protocol）、ICMP 为互联网控制报文协议（Internet Control Message Protocol）、ARP 为地址转换协议（Address Resolution Protocol）、RARP 为反向地址转换协议（Reverse ARP）。互连层的主要功能主要由 IP 来提供。除了提供端到端的分组分发功能外，IP 还提供了很多扩充功能。</p><p>互连层的另一个重要服务是在互相独立的局域网上建立互联网络，即互联网。</p><p>在传输层，TCP 为传输控制协议、UDP 为用户数据报协议（User Datagram Protocol）。这一层主要功能是负责应用进程之间的端-端通信，它与 OSI 参考模型的传输层功能是相似的。TCP 提供可靠的字节流信道，UDP 提供不可靠的数据报传送信道。</p><p>在应用层中，SMTP 为简单邮件传送协议（Simple Mail Transfer Protocol）、DNS 为域名服务（Domain Name Service）、FTP 为文件传输协议（File Transfer Protocol）、TELNET 为远程终端访问协议。</p><h3 id="4-OSI-RM-与-TCP-IP-参考模型的比较"><a href="#4-OSI-RM-与-TCP-IP-参考模型的比较" class="headerlink" title="4. OSI&#x2F;RM 与 TCP&#x2F;IP 参考模型的比较"></a>4. OSI&#x2F;RM 与 TCP&#x2F;IP 参考模型的比较</h3><p> OSI 和 TCP&#x2F;IP 参考模型有很多共同之处，两者都以协议栈的概念为基础，并且协议栈中的协议彼此相互独立，而且两个模型中都采用了层次结构的概念，各个层的功能也大体相似。除了这些基本的相似之处意外，两个模型也有着许多不同的地方。</p><p>首先，OSI 模型有七层，而 TCP&#x2F;IP 只有四层，它们都有网络层（或者称为互联网层）、传输层和应用层，但其它的层并不相同。</p><p>其次，在于无连接的和面向连接的通信范围有所不同。OSI 模型的网络层同时支持无连接和面向连接的通信，但是传输层上只支持面向连接的通信。TCP&#x2F;IP 模型的网络层只有一种模式即无连接通信，但是在传输层上同时支持两种通信模式。</p><h4 id="4-1-OSI-模型和协议的缺点"><a href="#4-1-OSI-模型和协议的缺点" class="headerlink" title="4.1 OSI 模型和协议的缺点"></a>4.1 OSI 模型和协议的缺点</h4><ol><li>模型和协议自身的缺陷。会话层和表示层这两层几乎是空的，而另外的数据链路层和网络层包含内容太多，有很多的子层插入，每个子层都有不同的功能。OSI 模型以及相应的服务定义和协议都极其复杂，它们很难实现。</li><li>协议出现时机晚于 TCP&#x2F;IP 协议。</li></ol><h4 id="4-2-TCP-IP-模型和协议的缺点"><a href="#4-2-TCP-IP-模型和协议的缺点" class="headerlink" title="4.2 TCP&#x2F;IP 模型和协议的缺点"></a>4.2 TCP&#x2F;IP 模型和协议的缺点</h4><ol><li>没有清楚地区分哪些是规范、哪些是实现</li><li>主机-网络层并不是常规意义上的一层，它是定义了网络层与数据链路层的接口</li></ol>]]></content>
      
      
      <categories>
          
          <category> 自学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络原理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机网络概述</title>
      <link href="/2017/12/18/%E8%87%AA%E5%AD%A6/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%A6%82%E8%BF%B0/"/>
      <url>/2017/12/18/%E8%87%AA%E5%AD%A6/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%A6%82%E8%BF%B0/</url>
      
        <content type="html"><![CDATA[<h3 id="1-计算机网络的发展"><a href="#1-计算机网络的发展" class="headerlink" title="1. 计算机网络的发展"></a>1. 计算机网络的发展</h3><h4 id="1-1-计算机网络的产生和发展"><a href="#1-1-计算机网络的产生和发展" class="headerlink" title="1.1 计算机网络的产生和发展"></a>1.1 计算机网络的产生和发展</h4><p>追溯计算机网络的发展历史，它的演变可以概括为 <strong>面向终端的计算机网络</strong>、<strong>计算机-计算机网络</strong>、<strong>开放式标准化网络</strong> 以及 <strong>因特网广泛应用和高速网络技术发展</strong> 等四个阶段。</p><p><strong>1. 面向终端的计算机网络</strong></p><p>以单个计算机为中心的远程联机系统，构成面向终端的计算机网络。</p><p>所谓的联机系统，就是由一台中央主计算机连接大量的地理上处于分散位置的终端。</p><p>随着连接的终端数目的增多，为减轻承担数据处理的中心计算机的负载，在通信线路和中心计算机之间设置了一个前端处理器 FEP（Front End Processor）或通信控制器 CCU（Communication Control Unit），专门负责与终端 T 之间的通信控制，从而出现了数据处理和通信控制的分工，更好地发挥了中心计算机的数据处理能力。另外，在终端较集中的地区，设置集中器或多路复用器，它首先通过低速线路将附近群集的终端连至集中器或复用器，然后通过高速通信线路、实施数字数据和模拟信号之间转换的调制解调器（Modem）与远程中心计算机的前端处理机相连，从而提高了通信线路的利用率，节约了远程通信线路的投资。</p><p><strong>2. 计算机-计算机网络</strong></p><p>由若干个计算机互连的系统，开创了「计算机-计算机」的通信时代，并呈现出多处理中心的特点。</p><p><strong>3. 开放式标准化网络</strong></p><p>虽然已有大量各自研制的计算机网络正在运行和提供服务，但仍存在不少弊病，主要原因是这些各自研制的网络没有统一的网络体系结构，难以实现互连。这种自成体系的系统称为「封闭」系统。为此，人们迫切希望建立一系列的国际标准，渴望得到一个「开放」的系统。</p><p><strong>4. 因特网的广泛应用与高速网络技术的发展</strong></p><p>Internet 作为世界性的信息网络，正在对当今经济、文化、科学研究、教育与人类社会生活发挥着越来越重要的作用。宽带网络技术的发展为全球信息高速公路的建设提供了技术基础。</p><h4 id="1-2-三大网络介绍"><a href="#1-2-三大网络介绍" class="headerlink" title="1.2 三大网络介绍"></a>1.2 三大网络介绍</h4><p>当前，在我国通信、计算机信息产业以及广播电视领域中，实际运行并具有影响的有三大网络：即电信网络、广播电视网络以及计算机网络。</p><p><strong>1. 电信业务网</strong></p><p>电信业务网是以电话网为基础逐步发展起来的。电话系统由三个主要的部件构成：</p><ol><li>本地网络：使用双绞线进入家庭和业务部门，承载的是模拟信号；</li><li>干线：通过光纤将交换局连接起来，承载的是数字信号；</li><li>交换局：使电话呼叫从一条干线接入到另一条干线；</li></ol><p><strong>2. 广播电视网</strong></p><p>广播电视网主要是有线电视网（CATV），目前还是靠同轴电缆向用户传送电视节目，处于模拟水平阶段。</p><p><strong>3. 计算机网</strong></p><p>计算机网初期主要是局域网（LAN），广域网（WAN）是在 Internet 大规模发展后才进入平常家庭的，目前主要依赖于电信网，因此传输速率受到双绞线的限制。</p><h4 id="1-3-未来网络发展趋势"><a href="#1-3-未来网络发展趋势" class="headerlink" title="1.3 未来网络发展趋势"></a>1.3 未来网络发展趋势</h4><p><strong>1. 宽带网络</strong></p><p>宽带网络可分为 <strong>宽带骨干网</strong> 和 <strong>宽带接入网</strong> 两个部分。<strong>骨干网</strong> 又称为核心交换网，它是基于光纤通信系统的，能实现大范围（在城市之间和国家之间）的数据流传送。通常采用高速传输网络、高速交换设备（如大型 ATM 交换机和交换路由器）。接入网需要覆盖所有类型的用户。接入网技术可根据所使用的传输介质的不同分为光纤接入、铜线接入、光纤同轴电缆混合接入和无线接入等多种类型</p><p><strong>2. 全光网络</strong></p><p>全光网（All Optical Network，AON）是以光节点取代现有网络的电节点，并用光纤将光节点互联成网，采用光波完成信号的传输、交换等功能，克服了现有网络在传输和交换时的瓶颈，减少信息传输的拥塞、延迟，提高网络的吞吐量。</p><p><strong>3. 多媒体网络</strong></p><p>多媒体网络是指能够传输多媒体数据的通信网络。多媒体网络需要满足多媒体信息传输所需的交互性和实时性的要求。主要表现在：</p><ol><li>高传输带宽要求</li><li>不同类型的数据对传输要求也不同：语音数据的传输对实时性要求较强，而对通信的宽带要求则不高</li><li>对多媒体传输有连续性与实时性的要求</li><li>对多媒体传输有同步的要求：即要在传输过程中必须保持多媒体数据之间在时序上的同步约束关系。同步要求之一：是指单一时间相关媒体数据内各媒体元素之间的时间关系，如音频流的各个分组之间的连续等时性；同步要求之二：是指有时空约束关系的时间相关媒体，或时间相关媒体与时间无关媒体之间的时间关系。如必须保持声频与视频的同步</li><li>具有多方参与通信的特点</li></ol><p><strong>4. 移动网络</strong></p><p>移动计算是将计算机网络和移动通信技术结合起来，为用户提供移动的计算环境和新的计算模式，其作用是在任何时间都能及时、准确地为任何地理位置的用户提供服务。涉及的主要技术有：</p><ol><li>蜂窝式数字分组数据（Cellular Digital Packet Data，CDPD）通信平台：其特点是无线和可移动</li><li>无线局域网（Wireless LAN，WLAN）：以微波、激光、红外线等无线电波来部分或全部代替有线局域网中的同轴电缆、双绞线、光纤，实现移动计算网络中移动节点的物理层和数据链路层功能，构成无线局域网</li><li>Ad hoc 网络：Ad hoc 网络是一种由一组用户群构成，不需要基站，没有固定路由器的移动通信模式</li><li>无线应用协议 WAP（Wireless Application Protocol）是一个崭新的、开放的全球化的协议。它能让用户使用内置浏览器在移动电话的屏幕上访问 Internet，可以使用具备 WAP 功能的手机直接上网</li></ol><p><strong>5. 下一代网络</strong></p><p>下一代网络 NGN（Next Generation Network）是一个基于分组的核心网络（有别于先前的时分复用网络）。能够提供包括电信业务在内的多种业务，支持多种宽带能力和具有按需求的服务质量（QoS）进行传送的技术，实现与业务相关的功能与底层传送技术的独立。</p><p>ITU-T 和相关的标准组织都对 NGN 的基本特征进行了描述：</p><ul><li>控制功能从承载、呼叫&#x2F;会话、应用&#x2F;业务中分离</li><li>业务提供与网络分离，提供开放接口以及与传统网络的互通</li><li>利用基本的业务组成模块，提供广泛的业务和应用（包括实时、非实时、流媒体和多媒体业务），同一种业务具有统一的业务特性</li><li>具有端到端 QoS 保证能力和透明的传输能力</li><li>支持多种标识体系，并能将其解析为 IP 地址以用于 IP 网选路</li><li>具有通用移动性，支持固定与移动业务融合</li><li>业务功能独立于底层传送技术，允许用户自由地接入不同业务提供商</li><li>适应所有管制的要求，如应急通信、安全性和私密性等要求</li></ul><h3 id="2-计算机网络的基本概念"><a href="#2-计算机网络的基本概念" class="headerlink" title="2. 计算机网络的基本概念"></a>2. 计算机网络的基本概念</h3><h4 id="2-1-计算机网络的定义"><a href="#2-1-计算机网络的定义" class="headerlink" title="2.1 计算机网络的定义"></a>2.1 计算机网络的定义</h4><p>计算机网络是现代计算机技术与通信技术的相互渗透、密切合作的产物，是随着社会对信息共享和信息传递的日益增强的需求而发展起来的。所谓计算机网络，就是利用通信设备和线路将地理位置不同的、功能独立的多个计算机系统互联起来，以功能完善的网络软件（即网络通信协议、信息交换方式和网络操作系统等）实现网络中资源共享和信息传递的系统。</p><h4 id="2-2-计算机网络的组成"><a href="#2-2-计算机网络的组成" class="headerlink" title="2.2 计算机网络的组成"></a>2.2 计算机网络的组成</h4><p>一个计算机网络是由资源子网和通信子网构成的。资源子网负责信息处理，通信子网负责全网中的信息传递。</p><p>资源子网包括提供资源的主机 HOST 和请求资源的终端 T（Terminal），它们都是信息传输的源节点或宿节点，有时也统称为端节点。</p><p>通信网主要由网络节点和通信链路组成。网络节点也称为转接节点或中间节点，它们的作用是控制信息的传输和在端节点之间转发信息。根据不同的作用，网络节点可以是分组交换设备 PSE（Packet Switching Exchanger）、分组装配&#x2F;拆卸设备 PAD（Packet Assembler Disassembler）、集中器 C（Concentrator）、网络控制中心 NCC（Network Control Center）、网间连接器 G（Gateway）也称网关或它们的组合。</p><h4 id="2-3-计算机网络的功能与应用"><a href="#2-3-计算机网络的功能与应用" class="headerlink" title="2.3 计算机网络的功能与应用"></a>2.3 计算机网络的功能与应用</h4><p><strong>1. 计算机网络的功能</strong></p><p>计算机网络的实现，为用户构造分布式的网络计算环境提供了基础。它的功能主要表现在 <strong>硬件资源共享</strong>、<strong>软件资源共享</strong> 和 <strong>用户间信息交换</strong>。</p><p><strong>2. 计算机网络的应用</strong></p><ol><li>办公自动化 OA（Office Automation）</li><li>远程教育（Distance Education）</li><li>电子银行</li><li>证券及期货交易</li><li>校园网（Campus Network）</li><li>企业网络</li><li>智能大厦和结构化综合布线系统</li></ol><h3 id="3-计算机网络的分类"><a href="#3-计算机网络的分类" class="headerlink" title="3. 计算机网络的分类"></a>3. 计算机网络的分类</h3><h4 id="3-1-按拓扑类型分类"><a href="#3-1-按拓扑类型分类" class="headerlink" title="3.1 按拓扑类型分类"></a>3.1 按拓扑类型分类</h4><p>网络拓扑是指网络形状、或者是它在物理上的连通性。网络的拓扑结构主要有：星型拓扑、总线拓扑、环形拓扑、树形拓扑、混合型拓扑及网形拓扑。</p><p>拓扑结构的选择往往与传输介质的选择及介质访问控制方法的确定紧密相关。在选择网络拓扑结构时，应该考虑的主要因素有下列几点：</p><ol><li>可靠性</li><li>费用</li><li>灵活性</li><li>响应时间和吞吐量</li></ol><p>网络拓扑可以根据通信子网中通信信道类型分为两类：</p><ol><li>点-点线路通信子网的拓扑</li><li>广播信道通信子网的拓扑</li></ol><p>在采用 <strong>点-点线路</strong> 的通信子网中，每条物理线路连接一对节点。采用点-点线路的通信子网的基本拓扑结构有 4 种：星形、环形、树形、网状形。</p><p>在采用 <strong>广播信道的通信子网</strong> 中，一个公共的通信信道被多个网络节点共享。采用广播信道通信子网的基本拓扑主要有 4 种：总线形、树形、环形、无线通信与卫星通信型。</p><p><strong>1. 星形拓扑</strong></p><p><strong>星形拓扑</strong> 是由中央节点和通过点到点通信链路接到中央节点和各个站点组成，中央节点往往是一个集线器。中央节点执行集中式通信控制策略，因此中央节点相当复杂，而各个站点的通信处理负担都很小。</p><p>星形拓扑结构具有以下优点：</p><ol><li>控制简单</li><li>故障诊断和隔离容易</li><li>方便服务</li></ol><p>星形拓扑结构的缺点：</p><ol><li>电缆长度和安装工作量可观</li><li>中央节点的负担较重，形成「瓶颈」</li><li>各站点的分布处理能力较低</li></ol><p><strong>2. 总线拓扑</strong></p><p><strong>总线拓扑</strong> 结构采用一个广播信道作为传输介质，所有站点都通过相应的硬件接口直接连到这一公共传输介质上，该公共传输介质即称为总线。任何一个站发送的信号都沿着传输介质传播，而且能被所有其它站所接收。</p><p>因为所有站点共享一条公用的传输信息，所有一次只能由一个设备传输信号。通常采用分布式控制策略来确定哪个站点可以发送。</p><p>总线拓扑结构的优点：</p><ol><li>总线结构所需要的电缆数量少</li><li>总线结构简单，又是无源工作，有较高的可靠性</li><li>易于扩充，增加过减少用户比较方便</li></ol><p>总线拓扑结构的缺点：</p><ol><li>总线的传输距离有限，通信范围受到限制</li><li>故障诊断和隔离较困难</li><li>分布式协议不能保证信息的及时传送，不具有实时功能，大业务量降低了网络速度</li></ol><p><strong>3. 环形拓扑</strong></p><p><strong>环形拓扑</strong> 网络由站点和连接站点的链路组成一个闭合环。每个站点能够接收从一条链路传来的数据，并以同样的速率串行地把该数据沿环送到另一条链路上。这种链路可以是单向的，也可以是双向的。</p><p>环形拓扑的优点：</p><ol><li>电缆长度短</li><li>可使用光纤</li><li>所有计算机都能公平地访问网络的其它部分，网络性能稳定</li></ol><p>环形拓扑的缺点：</p><ol><li>节点的故障会引起全网故障</li><li>环节点的加入和撤出过程较复杂</li><li>环形拓扑结构的介质访问控制协议都采用令牌传递的方式，在负载很轻时，信道利用率相对来说就比较低</li></ol><p><strong>4. 树形拓扑</strong></p><p><strong>树形拓扑</strong> 可以看成是总线和星形拓扑的扩展，形状像一棵倒置的树，顶端是树根，树根以下带分支，每个分支还可以再带子分支。树根接收各站点发送的数据，然后再用广播发送到全网。</p><p>树形拓扑的优点：</p><ol><li>易于扩展</li><li>故障隔离较容易</li></ol><p>树形拓扑的缺点：</p><ol><li>各个节点对树根的依赖性太大，如果树根发生故障，则全网不能正常工作</li></ol><p><strong>5. 混合形拓扑</strong></p><p>将以上某两种单一拓扑结构混合起来，取两者的优点构成的拓扑称为 <strong>混合形拓扑结构</strong>。</p><p>混合形拓扑的优点：</p><ol><li>故障诊断和隔离较为方便</li><li>易于扩展</li><li>安装方便</li></ol><p>混合形拓扑的缺点：</p><ol><li>需要选用带智能的集中器</li><li>向星形拓扑结构一样，集中器到各个站点的电缆安装长度会增加</li></ol><p><strong>6. 网形拓扑</strong></p><p>这种结构在广域网中得到了广泛的应用，它的优点是不受瓶颈问题和失效问题的影响。</p><h4 id="3-2-按网络的交换方式分类"><a href="#3-2-按网络的交换方式分类" class="headerlink" title="3.2 按网络的交换方式分类"></a>3.2 按网络的交换方式分类</h4><p>按交换方式来分类，计算机网络可以分为 <strong>电路交换网</strong>、<strong>报文交换网</strong> 和 <strong>分组交换网</strong> 三种。</p><p><code>电路交换（Circuit Switching）</code> 方式类似于传统的电话交换方式，用户在开始通信前，必须申请建立一条从发送端到接收端的物理信道，并且在双方通信期间始终占用该信道。</p><p><code>报文交换（Message Switching）</code> 方式的数据单元是要发送的一个完整报文，其长度并无限制。</p><p><code>分组交换（Packet Switching）</code> 方式也称包交换方式。采用分组交换方式通信前，发送端先将数据划分为一个个等长的单位（即分组），这些分组逐个由各中间节点采用存储-转发方式进行传输，最终到达目的端。</p><h4 id="3-3-按网络的覆盖范围分类"><a href="#3-3-按网络的覆盖范围分类" class="headerlink" title="3.3 按网络的覆盖范围分类"></a>3.3 按网络的覆盖范围分类</h4><p>按地理分布范围来分类，计算机网络可以分为 <strong>广域网</strong>、<strong>局域网</strong> 和 <strong>城域网</strong> 三种。</p><h4 id="3-4-按网络传输技术分类"><a href="#3-4-按网络传输技术分类" class="headerlink" title="3.4 按网络传输技术分类"></a>3.4 按网络传输技术分类</h4><p>网络所采用的传输技术有两类：<strong>广播方式</strong> 和 <strong>点对点方式</strong>。因此，相应的计算机网络也可以分为两类：<strong>广播式网络（Broadcast Network）</strong> 和 <strong>点对点式网络（Point-to-Point Network）</strong>。</p><h3 id="4-计算机网络的标准化"><a href="#4-计算机网络的标准化" class="headerlink" title="4. 计算机网络的标准化"></a>4. 计算机网络的标准化</h3><h4 id="4-1-国际标准化组织（ISO）"><a href="#4-1-国际标准化组织（ISO）" class="headerlink" title="4.1 国际标准化组织（ISO）"></a>4.1 国际标准化组织（ISO）</h4><p>ISO 是一个自发的不缔约组织，由各技术委员会（TC）组成，其中的 TC97 技术委员会专门负责制定有关信息处理的标准。</p><h4 id="4-2-其它标准化机构"><a href="#4-2-其它标准化机构" class="headerlink" title="4.2 其它标准化机构"></a>4.2 其它标准化机构</h4><ol><li>国际电信联盟（ITU）</li><li>美国国家标准局（NBS）</li><li>美国国家标准学会（ANSI）</li><li>欧洲计算机制造商协会（ECMA）</li></ol><h4 id="4-3-Internet-的组织机构"><a href="#4-3-Internet-的组织机构" class="headerlink" title="4.3 Internet 的组织机构"></a>4.3 Internet 的组织机构</h4><p>因特网体系结构局 IAB（Internet Architecture Board）负责 Internet 策略和标准的最后仲裁。IAB 下设特别任务组（Task Force），其中最著名的是因特网工程特别任务组（Internet Engineering Task Force，IETF）。它为 Internet 工程和发展提供技术及其它支持。它的任务之一是简化现存的标准并开发一些新的标准，并向 Internet 工程指导小组（Internet Engineering Steering Group，IESG）推荐标准。</p><p>IETF 主要的工作领域：应用程序、Internet 服务管理、运行要求、路由、安全性、传输、用户服务与服务应用程序。</p>]]></content>
      
      
      <categories>
          
          <category> 自学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络原理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据库管理</title>
      <link href="/2017/11/28/%E8%87%AA%E5%AD%A6/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AE%A1%E7%90%86/"/>
      <url>/2017/11/28/%E8%87%AA%E5%AD%A6/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AE%A1%E7%90%86/</url>
      
        <content type="html"><![CDATA[<p>在 DBS 运行时，DBMS 要对 DB 进行监控，以保证整个系统的正常运转，防止数据意外丢失和不一致数据的产生。DBMS 对 DB 的监控，称为数据库的管理，有时也称为数据库的保护。对数据库的管理主要通过四个方面实现：数据库的恢复、并发控制、完整性控制和安全性控制。每一方面构成了 DBMS 的一个子系统。DBS 运行的最小逻辑工作单位是「事务」，所有对数据库的操作，都要以事务作为一个整体单位来执行或者撤销。</p><h3 id="1-事务"><a href="#1-事务" class="headerlink" title="1. 事务"></a>1. 事务</h3><h4 id="1-1-事务的定义"><a href="#1-1-事务的定义" class="headerlink" title="1.1 事务的定义"></a>1.1 事务的定义</h4><p><code>事务（Transaction）</code>是构成单一逻辑工作单元的操作集合，要么完整地执行，要么完全不执行。不论发生何种情况，DBS 必须保证事务能正确、完整地执行。</p><h4 id="1-2-事务的-ACID-性质"><a href="#1-2-事务的-ACID-性质" class="headerlink" title="1.2 事务的 ACID 性质"></a>1.2 事务的 ACID 性质</h4><p><strong>1. 原子性（Atomicity）</strong></p><p>一个事务对数据库的所有操作，是一个不可分割的工作单元。这些操作要么全部执行，要么什么也不做（就对 DB 的效果而言）。</p><p><strong>2. 一致性（Consistency）</strong></p><p>一个事务独立执行的结果，应保持数据库的一致性，即数据不会因事务的执行而遭受破坏。</p><p><strong>3. 隔离性（Isolation）</strong></p><p>在多个事务并发执行时，系统应保证与这些事务先后单独执行时的结果一样，此时称事务达到了隔离性的要求。也就是在多个事务并发执行时，保证执行结果是正确的，如果单用户环境一样。</p><p><strong>4. 持久性（Durability）</strong></p><p>一个事务一旦完成全部操作后，它对数据库的所有更新应永久地反映在数据库中，不会丢失。即使以后系统发生故障，也是如此。</p><h3 id="2-数据库的恢复"><a href="#2-数据库的恢复" class="headerlink" title="2. 数据库的恢复"></a>2. 数据库的恢复</h3><blockquote><p>系统能把数据库从被破坏、不正确的状态，恢复到最近一个正确的状态，DBMS 的这种能力称为数据库的可恢复性（Recovery）。</p></blockquote><h4 id="2-1-典型的恢复策略"><a href="#2-1-典型的恢复策略" class="headerlink" title="2.1 典型的恢复策略"></a>2.1 典型的恢复策略</h4><p><strong>（1）平时做好两件事：转储和建立日志</strong></p><ol><li>周期地（比如一天一次）对整个数据库进行拷贝，转储到另一个磁盘或磁带一类存储介质中</li><li>建立日志数据库。记录事务的开始、结束标志，记录事务对数据库的每一次插入、删除和修改前后的值，写到「日志」库中，以便有案可查。</li></ol><p><strong>（2）一旦发生数据库故障，分两种情况进行处理</strong></p><ol><li>如果数据库遇到灾难性故障，例如磁头脱落、磁盘损坏等，这时数据库已不能用了，就必须装入最近一次拷贝的数据库备份到新的磁盘，然后利用日志库执行「重做」（REDO）已提交的事务，把数据库恢复到故障前的状态</li><li>如果数据库未遭到物理性破坏，但破坏了数据库的一致性（某些数据不正确），此时不必去拷贝存档的数据库，只要利用日志库「撤销」（UNDO）所有不可靠的修改，再利用日志库执行「重做」（REDO）已提交的、但对数据库的更新可能还留在内存缓冲区的事务，就可以把数据库恢复到正确的状态。</li></ol><h4 id="2-2-故障类型和恢复方法"><a href="#2-2-故障类型和恢复方法" class="headerlink" title="2.2 故障类型和恢复方法"></a>2.2 故障类型和恢复方法</h4><p><strong>1. 事务故障</strong></p><p>事务故障又可分为两种：</p><ol><li>可以预期的事务故障，即在程序中可以预先估计到的错误，譬如存款余额透支，商品库存量达到最低量等，此时继续取款或发货就会出现问题。这种情况可以在事务的代码中加入判断和 ROLLBACK 语句。当事务执行到 ROLLBACK 语句时，由系统对事务进行回退操作，即执行 UNDO 操作</li><li>非预期的事务故障，即在程序中发生的未估计到的错误，譬如运算溢出、数据错误、并发事务发生死锁而被选中撤销该事务等。此时由系统直接对该事务执行 UNDO 处理</li></ol><p><strong>2. 系统故障</strong></p><p>引起系统停止运转随之要求重新启动的事件称为「系统故障」。</p><p>重新启动时，具体处理分两种情况考虑：</p><ul><li>对未完成事务作 UNDO 处理；</li><li>对已提交事务但更新还留在缓冲区的事务进行 REDO 处理；</li></ul><p><strong>3. 介质故障</strong></p><p>在发生介质故障和遭受病毒破坏时，磁盘上的物理数据库遭到毁灭性破坏。此时恢复的过程如下：</p><ol><li>重装最近转储的后备副本到新的磁盘，使数据库恢复到转储时的一致状态</li><li>在日志中找出最近转储以后所有已提交的事务</li><li>对这些已提交的事务进行 REDO 处理，将数据库恢复到故障前某一时刻的一致状态</li></ol><h4 id="2-3-检查点技术"><a href="#2-3-检查点技术" class="headerlink" title="2.3 检查点技术"></a>2.3 检查点技术</h4><p><strong>1. 检查点方法</strong></p><p>前面多次提到的 REDO（重做）和 UNDO（撤销）处理，实际上是采用检查点（Check-point）方法实现的，大多数 DBMS 产品都提供这种技术。</p><p><strong>2. 检查点方法的恢复算法</strong></p><ol><li>根据日志文件建立事务重做队列和事务撤销队列</li><li>对重做队列中的事务进行 REDO 处理，对撤销队列中的事务进行 UNDO 处理</li></ol><h3 id="3-数据库的并发控制"><a href="#3-数据库的并发控制" class="headerlink" title="3. 数据库的并发控制"></a>3. 数据库的并发控制</h3><h4 id="3-1-并发操作带来的三个问题"><a href="#3-1-并发操作带来的三个问题" class="headerlink" title="3.1 并发操作带来的三个问题"></a>3.1 并发操作带来的三个问题</h4><p>在多用户共享系统中，许多事务可能同时对同一数据进行操作（「并发操作」），此时可能会破坏数据库的完整性。这里的「并发」（Concurrent）是指在单处理机（一个 CPU）上，利用分时方法实行多个事务同时做。</p><p>数据库的并发操作通常会带来三个问题：丢失更新问题、读脏数据问题、不可重复读问题。</p><p>在数据库技术中，把未提交的随后被撤销的数据称为「脏数据」。</p><h4 id="3-2-封锁技术"><a href="#3-2-封锁技术" class="headerlink" title="3.2 封锁技术"></a>3.2 封锁技术</h4><blockquote><p>锁（Lock）是一个与数据项相关的变量，对可能应用于该数据项上的操作而言，锁描述了该数据项的状态。</p></blockquote><p>通常在数据库中每个数据项都有一个锁。锁的作用是使并发事务对数据库中数据项的访问能够同步。封锁技术中主要有两种封锁：排他型封锁（Exclusive Lock）和共享型封锁（Shared Lock）。</p><p><strong>1. 排他型封锁（X 锁）</strong></p><blockquote><p>如果事务 T 对某个数据 R（可以是数据项、记录、数据集乃至整个数据库）实现了 X 锁，那么在 T 对数据 R 解除封锁之前，不允许其他事务 T 再对该数据加任何类型的锁。这种锁称为「X 锁」。</p></blockquote><p>使用 X 锁的操作有两个：</p><ul><li>申请 X 锁操作「XFIND R」：表示事务对数据 R 申请加 X 锁，若成功，则可以读或写数据 R；如果不成功，那么这个事务将进入等待队列，一直到获准 X 锁，事务才能继续做下去。</li><li>解除 X 锁操作「XRELEASE R」：表示事务要解除对数据 R 的 X 锁。</li></ul><p><strong>2. 共享型封锁（S 锁）</strong></p><blockquote><p>如果事务 T 对某数据加上 S 锁后，仍允许其他事务再对该数据加 S 锁，但在对该数据的所有 S 锁都解除之前决不允许任何事务对该数据加 X 锁。</p></blockquote><p>使用 S 锁的操作有三个：</p><ul><li>申请 S 锁操作「SFIND R」：表示事务对数据 R 申请加 S 锁，若成功，则可以读数据 R，但不可以写数据 R；如果不成功，那么这个事务将进入等待队列，一直到获准 S 锁，事务才能继续做下去。</li><li>升级和写操作「UPDX R」：表示事务要把对数据 R 的 S 锁升级为 X 锁，若成功则更新数据 R，否则这个事务进入等待队列。</li><li>解除 S 锁操作「SRELEASE R」：表示事务要解除对数据 R 的 S 锁。</li></ul><p><strong>3. 封锁的相容矩阵</strong></p><p><img src="http://personal-blog.oss-cn-hangzhou.aliyuncs.com/db_lock_type.png" alt="封锁类型的相容矩阵"></p><p><strong>4. 封锁的粒度</strong></p><p>X 锁和 S 锁都是加在某一个数据对象上的。封锁的对象可以是逻辑单元，也可以是物理单元。</p><blockquote><p>封锁对象的大小称为封锁的粒度（Granularity）。</p></blockquote><p>封锁粒度与系统的并发度和并发控制的开销密切相关。封锁的粒度越大，并发度也就越小，但同时系统的开销也就越小；相反，封锁的粒度越小，并发度越高，但系统开销也就越大。</p><p>因此，在一个系统中同时存在不同大小的封锁单元供不同的事务选择使用是比较理想的。而选择封锁粒度时必须同时考虑封锁机构和并发度两个因素，对系统开销与并发度进行权衡，以求得最优的效果。一般说来，需要处理大量元组的用户事务可以以关系为封锁单元；而对于一个处理少量元组的用户事务，可以以元组为封锁单位以提高并发度。</p><p><strong>5. 封锁协议</strong></p><p>利用封锁技术，可以避免并发操作引起的各种错误，但有可能产生其他三个问题：活锁，饿死和死锁。</p><p><img src="http://personal-blog.oss-cn-hangzhou.aliyuncs.com/db_lock_aggreement.png" alt="封锁协议的内容和优缺点"></p><h4 id="3-3-并发操作的调度"><a href="#3-3-并发操作的调度" class="headerlink" title="3.3 并发操作的调度"></a>3.3 并发操作的调度</h4><p><strong>1. 事务的调度、串行调度和并发调度</strong></p><blockquote><p>事务的执行次序称为「调度」。如果多个事务一次执行，则称为事务的串行调度（Serial Schedule）。如果利用分时的方法，同时处理多个事务，则称为事务的并发调度（Concurrent Schedule）。</p></blockquote><p><strong>2. 可串行化概念</strong></p><blockquote><p>每个事务中，语句的先后顺序在各种调度中始终保持一致。在这个前提下，如果一个并发调度的执行结果与某一串行调度的执行结果等价，那么，这个并发调度称为「可串行化的调度」，否则是不可串行化的调度。</p></blockquote><h4 id="3-4-SQL-对并发处理的支持"><a href="#3-4-SQL-对并发处理的支持" class="headerlink" title="3.4 SQL 对并发处理的支持"></a>3.4 SQL 对并发处理的支持</h4><p>SQL2 对事务的 <code>存取模式（Access Mode）</code> 和 <code>隔离级别（Isolation Level）</code> 做了具体规定，并提供语句让用户使用，以控制事务的并发执行。</p><p><strong>1. 事务的存取模式</strong></p><p>SQL2 允许事务有两种模式：</p><ol><li>READ ONLY（只读型）：事务对数据库的操作只能是读操作。定义这个模式后，表示随后的事务均是只读型。</li><li>READ WRITE（读写型）：事务对数据库的操作可以是读操作，也可以是写操作。定义这个模式后，表示随后的事务均是读写型。在程序开始时默认这种模式。</li></ol><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SET</span> TRANSACTION READ <span class="keyword">ONLY</span></span><br><span class="line"><span class="keyword">SET</span> TRANSACTION READ WRITE</span><br></pre></td></tr></table></figure><p><strong>2. 事务的隔离级别</strong></p><p>SQL2 提供事务的四种隔离级别让用户选择。这四个级别从高到低如下所述：</p><ol><li>SERIALIZABLE（可串行化）：允许事务与其他事务并发执行，但系统必须保证并发度是可串行化的，不致发生错误。在程序开始时默认这个级别。</li><li>REPEATABLE READ（可重复读）：只允许事务读已提交的数据，并且在两次读同一数据时不允许其他事务修改此数据。</li><li>READ COMMITTED（读提交数据）：允许事务读已提交的数据，但不要求「可重复读」。</li><li>READ UNCOMMITTED（可以读未提交的数据）：允许事务读已提交或未提交的数据。</li></ol><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SET</span> TRANSACTION ISOLATION LEVEL SERIALIZABLE</span><br><span class="line"><span class="keyword">SET</span> TRANSACTION ISOLATION LEVEL REPEATABLE READ</span><br><span class="line"><span class="keyword">SET</span> TRANSACTION ISOLATION LEVEL READ COMMITTED</span><br><span class="line"><span class="keyword">SET</span> TRANSACTION ISOLATION LEVEL READ UNCOMMITTED</span><br></pre></td></tr></table></figure><h3 id="4-数据库的完整性"><a href="#4-数据库的完整性" class="headerlink" title="4. 数据库的完整性"></a>4. 数据库的完整性</h3><h4 id="4-1-完整性子系统"><a href="#4-1-完整性子系统" class="headerlink" title="4.1 完整性子系统"></a>4.1 完整性子系统</h4><blockquote><p>数据库中完整性（Integrity）一词是指数据的正确性（Correctness）、有效性（Validity）和相容性（Consistency），防止错误的数据进入数据库。</p></blockquote><p>DBMS 中执行完整性检查的子系统称为「完整性子系统」。完整性子系统的主要功能有两点：</p><ol><li>监督事务的执行，并测试是否违反完整性规则；</li><li>若有违反现象，则采取恰当的操作，譬如拒绝操作、报告违反情况、改正错误等方法来处理。</li></ol><h4 id="4-2-SQL-中的完整性约束"><a href="#4-2-SQL-中的完整性约束" class="headerlink" title="4.2 SQL 中的完整性约束"></a>4.2 SQL 中的完整性约束</h4><p>SQL 中把完整性约束分成三大类：<code>域约束</code>、<code>基本表约束</code> 和 <code>断言</code>。</p><p><strong>1. 域约束</strong></p><p>SQL 可以用「CREATE DOMAIN」语句定义新的域，并且还可出现 CHECK 字句。</p><p><strong>2. 基本表约束</strong></p><p>SQL 的基本表约束主要有三种形式：候选键定义、外键定义和「检查约束」定义。这些定义都可以再前面加「CONSTRAINT&lt;约束名&gt;」，由此为新约束起个名字。</p><p><strong>3. 断言</strong></p><p>如果完整性的约束牵涉面较广，与多个关系有关，或者与聚合操作有关，那么 SQL2 提供「断言」（Assertions）机制让用户书写完整性约束。断言可以像关系一样，用 CREATE 语句定义，其句法如下：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CHECK</span> ASSERTION <span class="operator">&lt;</span>断言名<span class="operator">&gt;</span> <span class="keyword">CHECK</span> (<span class="operator">&lt;</span>条件<span class="operator">&gt;</span>)</span><br></pre></td></tr></table></figure><p>撤销断言的句法是：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">DROP</span> ASSERTION <span class="operator">&lt;</span>断言名<span class="operator">&gt;</span></span><br></pre></td></tr></table></figure><h4 id="4-3-SQL3-的触发器"><a href="#4-3-SQL3-的触发器" class="headerlink" title="4.3 SQL3 的触发器"></a>4.3 SQL3 的触发器</h4><blockquote><p>触发器（Trigger）是一个能由系统自动执行对数据库修改的语句。触发器有时也称为主动规则（Active Rule）或事件—条件—动作规则（Event-Condition-Action Rule，ECA 规则）。</p></blockquote><p>一个触发器由三个部分组成：</p><ol><li>事件。事件是指对数据库的插入、删除、修改等操作。触发器在这些事件发生时，将开始工作。</li><li>条件。触发器将测试条件是否成立。如果条件成立，就执行相应的动作，否则什么也不做。</li><li>动作。如果触发器测试满足预定的条件，那么，就由 DBMS 执行这些动作（即对数据库的操作）。这些动作能使触发事件不发生，即撤销事件，例如删除一插入的元组等。这些动作也可以是一系列对数据库的操作，甚至可以是与触发事件本身无关的其他操作。</li></ol><p><strong>触发器结构的组成</strong></p><p><em><strong>（1）动作时间</strong></em></p><p>触发器的动作时间定义了何时想要执行触发器动作。在 SQL 标准中规定可以是 BEFORE 或 AFTER。</p><ol><li>BEFORE：在触发事件进行以前，测试 WHEN 条件是否满足。若满足则先执行动作部分的操作，然后再执行触发事件的操作（此时可不管 WHEN 条件是否满足）。</li><li>AFTER：在触发事件完成以后，测试 WHEN 条件是否满足，若满足则执行动作部分的操作。</li><li>（在 Oracle 系统中才有）INSTEAD OF：在触发事件发生时。只要满足 WHEN 条件，就执行动作部分的操作，而触发事件的操作不再执行。</li></ol><p><em><strong>（2）触发事件</strong></em></p><p>触发事件定义了激活触发器的 SQL 数据更新语句的类别。触发事件有三类：UPDATE、DELETE 和 INSERT。只有在 UPDATE 时，允许后面跟「OF &lt;属性表&gt;」短语。在其他两种弄情况时，是对整个元组的操作，不允许后面跟「OF &lt;属性表&gt;」短语。</p><p><em><strong>（3）目标表（ON 短语）</strong></em></p><p>当目标表的数据被更新（插入、删除、修改）时，将激活触发器。</p><p><em><strong>（4）旧值和新值的别名表（REFERENCES 子句）</strong></em></p><p>如果触发事件是 UPDATE，那么，应该用「OLD AS」和「NEW AS」子句定义修改前后的元组变量。如果是 DELETE，那么只要用「OLD AS」子句定义元组变量。如果是 INSERT，那么，只要用「NEW AS」子句定义元组变量。</p><p><em><strong>（5）触发动作</strong></em></p><p>触发动作定义了当触发器被激活时想要它执行的 SQL 语句，有三个部分：动作间隔尺寸，动作时间条件和动作体。</p><p><code>动作间隔尺寸</code> 用 FOR EACH 子句定义，有两种形式：FOR EACH ROW 和 FOR EACH STATEMENT。前者对每一个修改的元组都要检查一次，而后者对 SQL 语句的执行结果去检查。前一种形式的触发器称为「元组级触发器」，后一种形式的触发器称为「语句级触发器」。</p><p><code>动作时间条件</code> 用 WHEN 子句定义，它可以是任意的条件表达式。当触发器被激活时，如果条件是 true，则执行动作体的 SQL 语句，否则不执行。</p><p><code>动作体</code> 定义了触发动作本身：当触发器被激活时想要 DBMS 执行的 SQL 语句。动作体若举一个 SQL 语句，直接写上即可；若是一系列的 SQL 语句，则用分号定界，再使用 BEGIN ATOMIC …… END 限定。</p><h3 id="5-数据库的安全性"><a href="#5-数据库的安全性" class="headerlink" title="5. 数据库的安全性"></a>5. 数据库的安全性</h3><h4 id="5-1-安全性问题"><a href="#5-1-安全性问题" class="headerlink" title="5.1 安全性问题"></a>5.1 安全性问题</h4><p><strong>1. 数据库安全性的定义</strong></p><blockquote><p>数据库的安全性（Security）是指保护数据库，防止不合法的使用，以免数据的泄密、更改或破坏。</p></blockquote><p><strong>安全性</strong> 是保护数据以防止非法用户故意造成的破坏；而 <strong>完整性</strong> 是保护数据以防止合法用户无意中造成的破坏。也就是安全性确保用户被限制在做其想做的事情；而完整性确保用户所做的事情是正确的。</p><p><strong>2. 安全性界别</strong></p><ol><li>环境级：计算机系统的机房和设备应加以保护，防止有人进行物理破坏。</li><li>职员级：工作人员应清正廉洁，正确授予用户访问数据库的权限。</li><li>OS 级：应防止未经授权的用户从 OS 处着手访问数据库。</li><li>网络级：由于大多数 DBS 都允许用户通过网络进行远程访问，因此，网络软件内部的安全性是很重要的。</li><li>DBS 级：DBS 的职责是检查用户的身份是否合法及使用数据库的权限是否正确。</li></ol><p><strong>3. 权限问题</strong></p><blockquote><p>用户（或应用程序）使用数据库的方式称为「权限」（Authorization）。</p></blockquote><p>权限有两种：访问数据的权限和修改数据库结构的权限。</p><p><em><strong>（1）访问数据的权限有四个：</strong></em></p><ol><li>读（Read）权限：允许用户读数据，但不能修改数据。</li><li>插入（Insert）权限：允许用户插入新的数据，但不能修改数据。</li><li>修改（Update）权限：允许用户修改数据，但不能删除数据。</li><li>删除（Delete）权限：允许用户删除数据。</li></ol><p><em><strong>（2）修改数据库模式的权限也有四个：</strong></em></p><ol><li>索引（Index）权限：允许用户创建和删除索引。</li><li>资源（Resource）权限：允许用户创建新的关系。</li><li>修改（Alteration）权限：允许用户在关系结构中加入或删除属性。</li><li>撤销（Drop）权限：允许用户撤销关系。</li></ol><h4 id="5-2-SQL-中的安全性机制"><a href="#5-2-SQL-中的安全性机制" class="headerlink" title="5.2 SQL 中的安全性机制"></a>5.2 SQL 中的安全性机制</h4><p>SQL 中有四个机制提供了安全性：视图（View）、权限（Authorization）、角色（Role）和审计（Audit）。</p><p><strong>1. 视图</strong></p><p>视图是从一个或多个基本表导出的表。但视图仅是一个定义，视图本身没有数据，不占磁盘空间。视图一经定义就可以和基本表一样被查询，也可以用来定义新的视图，但更新（插、删、改）操作将有一定的限制。</p><p>视图机制使系统具有三个优点：数据安全性、逻辑数据独立性和操作简便性。</p><p><strong>2. 权限</strong></p><p>DBMS 的授权子系统允许有特定存取权限的用户有选择地和动态地把这些权限授予其他用户。</p><p><strong>3. 角色</strong></p><blockquote><p>在 SQL 中，用户（User）是实际的人或是访问数据库的应用程序。而角色（Role）是一组具有相同权限的用户，实际上角色是属于目录一级的概念。</p></blockquote><p><strong>4. 审计</strong></p><blockquote><p>用于安全性目的的数据库日志，称为审计追踪（Audit Trail）。</p></blockquote><h4 id="5-3-常用的安全性措施"><a href="#5-3-常用的安全性措施" class="headerlink" title="5.3 常用的安全性措施"></a>5.3 常用的安全性措施</h4><ol><li>强制存取控制（Mandatory Access Control）</li><li>统计数据库的安全性</li><li>自然环境的安全性</li></ol>]]></content>
      
      
      <categories>
          
          <category> 自学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据库系统原理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SQL 语言</title>
      <link href="/2017/11/24/%E8%87%AA%E5%AD%A6/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/SQL%20%E8%AF%AD%E8%A8%80/"/>
      <url>/2017/11/24/%E8%87%AA%E5%AD%A6/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/SQL%20%E8%AF%AD%E8%A8%80/</url>
      
        <content type="html"><![CDATA[<h3 id="1-SQL-简介"><a href="#1-SQL-简介" class="headerlink" title="1. SQL 简介"></a>1. SQL 简介</h3><h4 id="1-1-SQL-数据库的体系结构"><a href="#1-1-SQL-数据库的体系结构" class="headerlink" title="1.1 SQL 数据库的体系结构"></a>1.1 SQL 数据库的体系结构</h4><p>在 SQL 中，关系模式称为「基本表」（Base Table），存储结构称为「存储文件」（Stored File），子模式称为视图（View），元组称为「行」（Row），属性称为「列」（Column）。</p><p>SQL 数据库的体系结构要点如下：</p><ol><li>一个 SQL 模式（Schema）是表和约束的集合</li><li>一个表由行集构成，一行是列的序列，每列对应一个数据项</li><li>表有三种类型：基本表、视图和导出表。基本表是实际存储在数据库中的表，视图是由若干基本表或其他视图构成的表的定义，而导出表是执行了查询是产生的表</li><li>一个基本表可以跨一个或多个存储文件，一个存储文件也可以存放一个或多个基本表。每个存储文件与外部存储器上一个物理文件对应</li><li>用户可以用 SQL 语句对基本表和视图进行查询等操作</li><li>SQL 用户可以是应用程序，也可以是终端用户</li></ol><h4 id="1-2-SQL-的组成"><a href="#1-2-SQL-的组成" class="headerlink" title="1.2 SQL 的组成"></a>1.2 SQL 的组成</h4><p>核心 SQL 主要有四个部分：</p><ol><li>数据定义语言，即 SQL DDL，用户定义 SQL 模式、基本表、视图、索引等结构</li><li>数据操纵语言，即 SQL DML。数据操纵分成数据查询和数据更新两类。而数据更新又分为插入、删除和修改三种操作</li><li>嵌入式 SQL 语言的使用规定</li><li>数据控制语言，即 SQL DCL，这一部分包括对基本表和视图的授权、完整性规则的描述、事务控制等内容</li></ol><h4 id="1-3-SQL-的特点"><a href="#1-3-SQL-的特点" class="headerlink" title="1.3 SQL 的特点"></a>1.3 SQL 的特点</h4><ol><li>SQL 具有十分灵活和强大的查询功能，其 SELECT 语句能完成相当复杂的查询操作，包括各种关系代数操作、统计、排序等操作</li><li>SQL 不是一个应用开发语言，它只提供对数据库的操作功能，不能完成屏幕控制、菜单管理、报表生成等功能。但 SQL 既可作为交互式语言独立适用，也可作为子语言嵌入在主语言中适用，成为应用开发语言的一部分</li><li>SQL 是国际标准语言，有利于各种数据库之间交换数据，有利于程序的移植，有利于实现高度的数据独立性，有利于实现标准化</li><li>SQL 词汇不多，完成核心功能只用了 9 个英语动词，它的语法结构接近英语，因此容易学习和使用</li></ol><h3 id="2-SQL-的数据定义"><a href="#2-SQL-的数据定义" class="headerlink" title="2. SQL 的数据定义"></a>2. SQL 的数据定义</h3><h4 id="2-1-SQL-模式的创建和撤销"><a href="#2-1-SQL-模式的创建和撤销" class="headerlink" title="2.1 SQL 模式的创建和撤销"></a>2.1 SQL 模式的创建和撤销</h4><p><strong>1. SQL 模式的创建</strong></p><p>在 SQL 中，一个 SQL 模式定义为基本表的集合。一个 SQL 模式由模式名和模式拥有者的用户名或账户来确定，并包含模式中每一个元素（基本表、视图、索引等）的定义。</p><p>SQL 模式的创建可用 CREATE SCHEMA 语句定义，其基本句法如下：</p><blockquote><p>CREATE SCHEMA &lt;模式名&gt; AUTHORIZATION &lt;用户名&gt;</p></blockquote><p><strong>2. SQL 模式的撤销</strong></p><p>DROP 语句的句法如下：</p><blockquote><p>DROP SCHEMA &lt;模式名&gt; [CASCADE | RESTRICT]</p></blockquote><p>其方式有两种：</p><blockquote><p>CASCADE（级联式）方式：执行 DROP 语句时，把 SQL 模式及其下属的基本表、视图、索引等所有元素全部撤销。</p><p>RESTRICT（约束式）方式：执行 DROP 语句时，只有当 SQL 模式中没有任何下属元素时，才能撤销 SQL 模式，否则拒绝执行 DROP 语句。</p></blockquote><h3 id="3-存储过程与-SQL-PSM"><a href="#3-存储过程与-SQL-PSM" class="headerlink" title="3. 存储过程与 SQL&#x2F;PSM"></a>3. 存储过程与 SQL&#x2F;PSM</h3><p> 使用存储过程具有以下优点：</p><ol><li>提高运行速度</li><li>增强了 SQL 的功能和灵活性</li><li>可以降低网络的通信量</li><li>减轻了程序编写的工作量</li><li>间接实现安全控制功能</li></ol>]]></content>
      
      
      <categories>
          
          <category> 自学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据库系统原理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关系运算</title>
      <link href="/2017/11/24/%E8%87%AA%E5%AD%A6/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/%E5%85%B3%E7%B3%BB%E8%BF%90%E7%AE%97/"/>
      <url>/2017/11/24/%E8%87%AA%E5%AD%A6/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/%E5%85%B3%E7%B3%BB%E8%BF%90%E7%AE%97/</url>
      
        <content type="html"><![CDATA[<p>关系模型有三个重要组成部分：<strong>数据结构</strong>，<strong>数据操纵</strong>，<strong>数据完整性规则</strong>。</p><p><code>数据结构</code>：数据库中全部数据及其相互联系都被组织成「关系」（二维表格）的形式。关系模式基本的数据结构是关系。</p><p><code>数据操纵</code>：关系模型提供一组完备的高级关系运算，以支持对数据库的各种操作。关系运算分成 <strong>关系代数</strong> 和 <strong>关系演算</strong> 两类。</p><p><code>数据完整性规则</code>：数据库中数据必须满足实体完整性，参照完整性和用户定义的完整性等三类完整性规则。</p><p>关系查询语言根据其理论基础的不同分成两类：</p><ol><li><code>关系代数语言</code>：查询操作是以集合操作为基础的运算。</li><li><code>关系演算语言</code>：查询操作是以谓词演算为基础的运算。</li></ol><h3 id="1-关系代数"><a href="#1-关系代数" class="headerlink" title="1. 关系代数"></a>1. 关系代数</h3><h4 id="1-1-关系代数的五个基本操作"><a href="#1-1-关系代数的五个基本操作" class="headerlink" title="1.1 关系代数的五个基本操作"></a>1.1 关系代数的五个基本操作</h4><p><code>关系代数</code> 是以关系为运算对象的一组高级运算的集合。由于关系定义为属性个数相同的元组的集合，因此集合代数的操作就可以引入到关系代数中。关系代数中的操作可以分为两类：</p><ul><li>传统的集合操作：并、差、交、笛卡尔积（乘法），笛卡尔积的逆运算（除法）。</li><li>扩充的关系操作：对关系进行垂直分割（投影）、水平分割（选择）、关系的结合（连接、自然连接）等。</li></ul><h4 id="1-2-关系代数的四个组合操作"><a href="#1-2-关系代数的四个组合操作" class="headerlink" title="1.2 关系代数的四个组合操作"></a>1.2 关系代数的四个组合操作</h4><ol><li>交（Intersection）</li><li>连接（Join）</li><li>自然连接（Natural join）</li><li>除法（Division）</li></ol><h4 id="1-3-关系代数的两个扩充操作"><a href="#1-3-关系代数的两个扩充操作" class="headerlink" title="1.3 关系代数的两个扩充操作"></a>1.3 关系代数的两个扩充操作</h4><ol><li>外连接（Outer Join）</li><li>外部并（Outer Union）</li></ol><h3 id="2-关系演算"><a href="#2-关系演算" class="headerlink" title="2. 关系演算"></a>2. 关系演算</h3><p><strong>关系演算</strong> 又可分为 <strong>元组关系演算</strong> 和 <strong>域关系演算</strong>，前者以元组为变量，后者以属性（域）为变量，分别简称为 <strong>元组演算</strong>和 <strong>域演算</strong>。</p><h4 id="2-1-元组关系演算"><a href="#2-1-元组关系演算" class="headerlink" title="2.1 元组关系演算"></a>2.1 元组关系演算</h4><p>在元组关系演算（Tuple Relational Calculus）中，元组关系演算表达式简称为元组表达式，其一般形式为：{t|P(t)}。</p><h4 id="2-2-域关系演算"><a href="#2-2-域关系演算" class="headerlink" title="2.2 域关系演算"></a>2.2 域关系演算</h4><ol><li>域关系演算表达式</li><li>元组表达式到域表达式的转换</li></ol><h4 id="2-3-关系运算的安全约束和等价性"><a href="#2-3-关系运算的安全约束和等价性" class="headerlink" title="2.3 关系运算的安全约束和等价性"></a>2.3 关系运算的安全约束和等价性</h4><ol><li>关系运算的安全性</li><li>关系运算的等价性</li></ol>]]></content>
      
      
      <categories>
          
          <category> 自学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据库系统原理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关系模式设计理论</title>
      <link href="/2017/11/20/%E8%87%AA%E5%AD%A6/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/%E5%85%B3%E7%B3%BB%E6%A8%A1%E5%BC%8F%E8%AE%BE%E8%AE%A1%E7%90%86%E8%AE%BA/"/>
      <url>/2017/11/20/%E8%87%AA%E5%AD%A6/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/%E5%85%B3%E7%B3%BB%E6%A8%A1%E5%BC%8F%E8%AE%BE%E8%AE%A1%E7%90%86%E8%AE%BA/</url>
      
        <content type="html"><![CDATA[<h3 id="1-关系模式的设计准则"><a href="#1-关系模式的设计准则" class="headerlink" title="1. 关系模式的设计准则"></a>1. 关系模式的设计准则</h3><h4 id="1-1-关系模式的冗余和异常问题"><a href="#1-1-关系模式的冗余和异常问题" class="headerlink" title="1.1 关系模式的冗余和异常问题"></a>1.1 关系模式的冗余和异常问题</h4><p><code>数据冗余</code> 是指同一个数据在系统中多次重复出现。</p><h4 id="1-2-关系模式的非形式化设计准则"><a href="#1-2-关系模式的非形式化设计准则" class="headerlink" title="1.2 关系模式的非形式化设计准则"></a>1.2 关系模式的非形式化设计准则</h4><ol><li>关系模式的设计应尽可能只包含有直接联系的属性，不要包含有间接联系的属性。也就是，每个关系模式应只对应于一个实体类型或一个联系类型；</li><li>关系模式的设计应尽可能使得相应关系中不出现插入、删除和修改等操作异常现象。如果出现任何异常，则要清楚地加以说明，并确保更新数据库的程序正确操作；</li><li>关系模式的设计应尽可能使得相应关系中避免放置经常为空值的属性；</li><li>关系模式设计应尽可能使得关系的等值连接在主键和外键的属性上进行，并且保证连接以后不会生成额外的元组；</li></ol><h3 id="2-函数依赖"><a href="#2-函数依赖" class="headerlink" title="2. 函数依赖"></a>2. 函数依赖</h3><p>在数据依赖中，函数依赖是最基本、最重要的一种依赖。实际上，它是关键码概念的推广。</p><h4 id="2-1-函数依赖的定义"><a href="#2-1-函数依赖的定义" class="headerlink" title="2.1 函数依赖的定义"></a>2.1 函数依赖的定义</h4><blockquote><p>设有关系模式 R（U），X 和 Y 是属性集 U 的子集，函数依赖（functional dependency，简记为 FD）是形式 X → Y 的一个命题，只要 r 是 R 的当前关系，对 r 中任意两个元组 t 和 s，都有 t[X] &#x3D; s[X] 蕴涵 t[Y] &#x3D; s[Y]，那么称 FD X → Y 在关系模式 R（U）中成立。</p></blockquote><h4 id="2-2-FD-的逻辑蕴涵"><a href="#2-2-FD-的逻辑蕴涵" class="headerlink" title="2.2 FD 的逻辑蕴涵"></a>2.2 FD 的逻辑蕴涵</h4><blockquote><p>设 F 是在关系模式 R 上成立的函数依赖的集合，X→Y 是一个函数依赖。</p><p>设 F 是函数依赖集，被 F 逻辑蕴涵的函数依赖全体构成的集合，称为函数依赖集 F 的闭包（Closure），记为 F<sup>+</sup>。即 F<sup>+</sup> &#x3D; { X→Y | F |&#x3D; X→Y }</p></blockquote><h4 id="2-3-FD-的推理规则"><a href="#2-3-FD-的推理规则" class="headerlink" title="2.3 FD 的推理规则"></a>2.3 FD 的推理规则</h4><p>设 U 是关系模式 R 的属性集，F 是 R 上成立的只涉及到 U 中属性的函数依赖集。FD 的推理规则如下：</p><ol><li>自反性（Reflexivity）：若 Y∈X∈U，则 X→Y 在 R 上成立</li><li>增广性（Augmentation）：若 X→Y 在 R 上成立，且 Z∈U，则 XZ→YZ 在 R 上成立</li><li>传递性（Transitivity）：若 X→Y 和 Y→Z 在 R 上成立，则 X→Z 在 R 上成立</li><li>合并性（Union）：{ X→Y，X→Z } |&#x3D;X→YZ</li><li>分解性（Decomposition）：{ X→Y，Z∈Y } |&#x3D;X→Z</li><li>伪传递性：{ X→Y，WY→Z } |&#x3D;WX→Z</li><li>复合性（Composition）：{ X→Y，W→Z } |&#x3D;XW→YZ</li><li>通用一致性（Gernal Unification Theorem）：{ X→Y，W→Z } |&#x3D;X∪（W-Y）→YZ</li></ol><h4 id="2-4-FD-和关键码的联系"><a href="#2-4-FD-和关键码的联系" class="headerlink" title="2.4 FD 和关键码的联系"></a>2.4 FD 和关键码的联系</h4><p>设关系模式 R 的属性集是 U，X 是 U 的一个子集。如果 X→U 在 R 上成立，那么称 X 是 R 的一个超键。如果 X→U 在 R 上成立，但对于 X 的任一真子集 X<sub>1</sub> 都有 X<sub>1</sub>→U 不成立，那么称 X 是 R 上的一个候选键。</p><h4 id="2-5-属性集的闭包"><a href="#2-5-属性集的闭包" class="headerlink" title="2.5 属性集的闭包"></a>2.5 属性集的闭包</h4><blockquote><p>设 F 是属性集 U 上的 FD 集，X 是 U 的子集，那么（相对于 F）属性集 X 的闭包用 X<sup>+</sup> 表示，它是一个从 F 集使用 FD 推理规则推出的所有满足 X→A 的属性 A 的集合：X<sup>+</sup> &#x3D; { 属性 A | F|&#x3D;X→A }</p><p>X→Y 能用 FD 推理规则推出的充分必要条件是 Y∈X<sup>+</sup>。</p></blockquote><h4 id="2-6-FD-集的最小依赖集"><a href="#2-6-FD-集的最小依赖集" class="headerlink" title="2.6 FD 集的最小依赖集"></a>2.6 FD 集的最小依赖集</h4><blockquote><p>如果关系模式 R（U）上的两个函数依赖集 F 和 G，有 F<sup>+</sup>&#x3D;G<sup>+</sup>，则称 F 和 G 是等价的函数依赖集。</p><p>如果函数依赖集 G 满足下列三个条件，则称 G 是最小依赖集：</p><ol><li>G 中每个 FD 的右边都是单属性；</li><li>G 中没有冗余的 F，即 G 中不存在这样的函数依赖 X→Y，使得 G - {X→Y} 与 G 等价；</li><li>G 中每个 FD 的左边没有冗余的属性，即 G 中不存在这样的函数依赖 X→Y，X 有真子集 W 使得 G - {X→Y}∪{W→Y} 与 G 等价；</li></ol></blockquote><h3 id="3-关系模式的分解特性"><a href="#3-关系模式的分解特性" class="headerlink" title="3. 关系模式的分解特性"></a>3. 关系模式的分解特性</h3><h4 id="3-1-模式分解的优缺点"><a href="#3-1-模式分解的优缺点" class="headerlink" title="3.1 模式分解的优缺点"></a>3.1 模式分解的优缺点</h4><p><strong>优点</strong></p><ol><li>模式分解能消除数据冗余和操作异常现象</li><li>在分解了的数据库中可以存储悬挂元组，存储泛关系中无法存储的信息</li></ol><p><strong>缺点</strong></p><ol><li>分解以后，检索操作需要做笛卡尔积或连接操作，这将付出时间代价</li><li>在有泛关系假设时，对数据库中关系进行自然连接时，可能产生寄生元组，即损失了信息。在无泛关系假设时，由于数据库中可能存在悬挂元组，就有可能不存在泛关系</li></ol><h3 id="4-范式"><a href="#4-范式" class="headerlink" title="4. 范式"></a>4. 范式</h3><h4 id="4-1-第一范式（1NF）"><a href="#4-1-第一范式（1NF）" class="headerlink" title="4.1 第一范式（1NF）"></a>4.1 第一范式（1NF）</h4><blockquote><p>如果关系模式 R 的每个关系 r 的属性值都是不可分的原子值，那么称 R 是第一范式（First Normal Form，简记为 1NF）的模式。</p></blockquote><h4 id="4-2-第二范式（2NF）"><a href="#4-2-第二范式（2NF）" class="headerlink" title="4.2 第二范式（2NF）"></a>4.2 第二范式（2NF）</h4><blockquote><p>对于 FD W→A，如果存在 X∈W 有 X→A 成立，那么称 W→A 是局部依赖（A 局部依赖于 W）；否则称 W→A 是完全依赖。完全依赖也称为「左部不可约依赖」。</p><p>如果 A 是关系模式 R 的候选键的属性，那么称 A 是 R 的主属性；否则称 A 是 R 的非主属性。</p><p>如果关系模式 R 是1NF，且每个非主属性完全函数依赖于候选键，那么称 R 是第二范式（2NF）的模式。如果数据库模式中每个关系模式都是 2NF，则称数据库模式为 2NF 的数据库模式。</p></blockquote><h4 id="4-3-第三范式（3NF）"><a href="#4-3-第三范式（3NF）" class="headerlink" title="4.3 第三范式（3NF）"></a>4.3 第三范式（3NF）</h4><blockquote><p>如果关系模式 R 是1NF，且每个非主属性都不传递依赖于 R 的候选键，那么称 R 是第三范式（3NF）的模式。如果数据库模式中每个关系模式都是 3NF，则称其为 3NF 的数据库模式。</p><p>设 F 是关系模式 R 的 FD 集，如果对 F 中每个非平凡的 FD X→Y，都有 X 是 R 的超键，或者 Y 的每个属性都是主属性，那么称 R 是 3NF 的模式。</p></blockquote><h4 id="4-4-BCNF"><a href="#4-4-BCNF" class="headerlink" title="4.4 BCNF"></a>4.4 BCNF</h4><blockquote><p>如果关系模式 R 是 1NF，且每个属性都不传递依赖于 R 的候选键，那么称 R 是 BCNF 的模式。如果数据库模式中每个关系模式都是 BCNF，则称为 BCNF 的数据库模式。</p><p>设 F 是关系模式 R 的 FD 集，如果对 F 中每个非平凡的 FD X→Y，都有 X 是 R 的超键，那么称 R 是 BCNF 的模式。</p></blockquote><h3 id="5-多值依赖和第四范式"><a href="#5-多值依赖和第四范式" class="headerlink" title="5. 多值依赖和第四范式"></a>5. 多值依赖和第四范式</h3><h4 id="5-1-多值依赖"><a href="#5-1-多值依赖" class="headerlink" title="5.1 多值依赖"></a>5.1 多值依赖</h4><blockquote><p>设 U 是关系模式 R 的属性集，X 和 Y 是 U 的子集，Z&#x3D;R-X-Y，小写的 xyz 表示属性集 XYZ 的值。对于 R 的关系 r，在 r 中存在元组（x，y<sub>1</sub>，z<sub>1</sub>）和（x，y<sub>2</sub>，z<sub>2</sub>）时，就也存在元组（x，y<sub>2</sub>，z<sub>1</sub>）和（x，y<sub>1</sub>，z<sub>2</sub>），那么称多值依赖（Multivalued Dependency，简记为 MVD）X→→Y 在模式 R 上成立。</p></blockquote><h4 id="5-2-第四范式（4NF）"><a href="#5-2-第四范式（4NF）" class="headerlink" title="5.2 第四范式（4NF）"></a>5.2 第四范式（4NF）</h4><blockquote><p>设 D 施关系模式 R 上成立的 FD 和 MVD 集合。如果 D 中每个非平凡的 MVD X→→Y 的左部都是 R 的超键，那么称 R 是 4NF 的模式。</p><p>是 4NF 的模式肯定是 BCNF 模式。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 自学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据库系统原理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据库设计和 ER 模型</title>
      <link href="/2017/11/13/%E8%87%AA%E5%AD%A6/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AE%BE%E8%AE%A1%E5%92%8C%20ER%20%E6%A8%A1%E5%9E%8B/"/>
      <url>/2017/11/13/%E8%87%AA%E5%AD%A6/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AE%BE%E8%AE%A1%E5%92%8C%20ER%20%E6%A8%A1%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<h3 id="1-数据库系统生存期"><a href="#1-数据库系统生存期" class="headerlink" title="1. 数据库系统生存期"></a>1. 数据库系统生存期</h3><p>我们把数据库应用系统从开始规划、设计、实现、维护到最后被新的系统取代而停止使用的整个期间，称为数据库系统生存期。</p><p>这个生存期一般可划分成下面七个阶段：<strong>规划</strong>、<strong>需求分析</strong>、<strong>概念设计</strong>、<strong>逻辑设计</strong>、<strong>物理设计</strong>、<strong>实现</strong>、<strong>运行维护</strong>。</p><h4 id="1-1-规划阶段"><a href="#1-1-规划阶段" class="headerlink" title="1.1 规划阶段"></a>1.1 规划阶段</h4><p>规划阶段具体可分成三个步骤：</p><ol><li>系统调查。对应用单位作全面的调查。发现其存在的主要问题，并画出组织层次图，以了解企业的组织机构；</li><li>可行性分析。从技术、经济、效益、法律等诸方面对建立数据库的可行性进行分析；然后写出可行性分析报告；组织专家进行讨论其可行性；</li><li>确定数据库系统的总目标，并对应用单位的工作流程进行优化和制定项目开发计划。在得到决策部门批准后，就正式进入数据库系统的开发工作；</li></ol><h4 id="1-2-需求分析阶段"><a href="#1-2-需求分析阶段" class="headerlink" title="1.2 需求分析阶段"></a>1.2 需求分析阶段</h4><p><strong>1. 分析用户活动，产生业务流程图</strong></p><p>了解用户的业务活动和职能，搞清其处理流程（即业务流程）。</p><p><strong>2. 确定系统范围，产生系统关联图</strong></p><p>这一步是确定系统的边界，在和用户经过充分讨论的基础上，确定计算机所能进行的数据处理的范围，确定哪些工作由人工完成，哪些工作由计算机系统完成，即确定人机界面。</p><p><strong>3. 分析用户活动涉及的数据，产生数据流图</strong></p><p>深入分析用户的业务处理，以数据流图形式表示出数据的流向和对数据所进行的加工。</p><p><code>数据流图（Data Flow Diagram，简记为 DFD）</code> 是从「数据」和「对数据的加工」两方面表达数据处理系统工作过程的一种图形表示法，具有 <strong>直观</strong>、<strong>易于被用户和软件人员</strong> 双方都能理解的一种表达系统功能的描述方式。</p><p><strong>4. 分析系统数据，产生数据字典</strong></p><p>数据字典是对数据描述的集中管理，它的功能室存储和检索各种数据描述（称为元数据 Metadata）。</p><p>数据字典中通常包括 <strong>数据项</strong>、<strong>数据结构</strong>、<strong>数据流</strong>、<strong>数据存储</strong> 和 <strong>过程处理</strong> 5个部分。</p><h4 id="1-3-概念设计阶段"><a href="#1-3-概念设计阶段" class="headerlink" title="1.3 概念设计阶段"></a>1.3 概念设计阶段</h4><p>概念设计的目标是产生反映用户单位信息需求的数据库概念结构，即 <code>概念模型</code>，概念模型是独立于计算机硬件结构，独立于支持数据库的 DBMS。</p><p><strong>1. 概念设计的重要性</strong></p><p><strong>2. 概念设计的主要步骤</strong></p><ol><li>进行数据抽象，设计局部概念模型；</li><li>将局部概念模型综合成全局概念模型；</li><li>评审；</li></ol><h4 id="1-4-逻辑设计阶段"><a href="#1-4-逻辑设计阶段" class="headerlink" title="1.4 逻辑设计阶段"></a>1.4 逻辑设计阶段</h4><ol><li>把概念模型转换成逻辑模型；</li><li>设计外模型；</li><li>设计应用程序与数据库的接口；</li><li>评价模型；</li><li>修正模型；</li></ol><h4 id="1-5-物理设计阶段"><a href="#1-5-物理设计阶段" class="headerlink" title="1.5 物理设计阶段"></a>1.5 物理设计阶段</h4><ol><li>存储记录结构设计：包括记录的组成、数据项的类型、长度，以及逻辑记录到存储记录的映射；</li><li>确定数据存放位置：可以把经常同时被访问的数据组合在一起，「记录聚簇（Cluster）」技术能满足这个要求；</li><li>存取方法的设计：存取路径分为主存取路径与辅存取路径，前者用于主键检索，后者用于辅助键检索；</li><li>完整性和安全性考虑：设计者应在完整性、安全性、有效性和效率方面进行分析，做出权衡；</li><li>程序设计：在逻辑数据库结构确定后，应用程序设计就应当随之开始；</li></ol><h4 id="1-6-数据库的实现"><a href="#1-6-数据库的实现" class="headerlink" title="1.6 数据库的实现"></a>1.6 数据库的实现</h4><ul><li>用 DDL 定义数据库结构</li><li>组织数据入库</li><li>编制与调试应用程序</li><li>数据库试运行</li></ul><h4 id="1-7-数据库的运行与维护"><a href="#1-7-数据库的运行与维护" class="headerlink" title="1.7 数据库的运行与维护"></a>1.7 数据库的运行与维护</h4><ol><li>数据库的转储与恢复</li><li>数据库安全性、完整性控制</li><li>数据库性能的监督、分析和改进</li><li>数据库的重组织和重构造</li></ol><h3 id="2-ER-模型的基本概念"><a href="#2-ER-模型的基本概念" class="headerlink" title="2. ER 模型的基本概念"></a>2. ER 模型的基本概念</h3><h4 id="2-1-ER-模型的基本元素"><a href="#2-1-ER-模型的基本元素" class="headerlink" title="2.1 ER 模型的基本元素"></a>2.1 ER 模型的基本元素</h4><p>ER 模型的基本元素是：实体、联系和属性。</p><p><code>实体（Entity）</code> 是一个数据对象，指应用中可以区别的客观存在的事务。</p><p><code>联系（Relationship）</code> 表示一个或多个实体之间的关联关系。</p><p><code>属性（Attribute）</code> 实体的某一个特性。</p><h4 id="2-2-属性的分类"><a href="#2-2-属性的分类" class="headerlink" title="2.2 属性的分类"></a>2.2 属性的分类</h4><p><strong>1. 简单属性和符合属性</strong></p><p><code>简单属性</code> 是不可再分割的属性。</p><p><code>符合属性</code> 是可再分解为其他属性的属性（即属性可嵌套）。</p><p><strong>2. 单值属性和多值属性</strong></p><p><code>单值属性</code> 指的是同一实体的属性只能取一个值。</p><p><code>多值属性</code> 指同一实体的某些属性可能取多个值。</p><p><strong>3. 存储属性和派生属性</strong></p><p><code>存储属性</code> 指的是需要存储值的属性。</p><p><code>派生属性</code> 指的是可从其他属性值推导出值的属性。<strong>派生属性</strong> 的值不必存储在数据库内。</p><p><strong>4. 允许为空值的属性</strong></p><p>当实体在某个属性上没有值时应使用空值（Null Value）。</p><h4 id="2-3-联系的设计"><a href="#2-3-联系的设计" class="headerlink" title="2.3 联系的设计"></a>2.3 联系的设计</h4><p><strong>1. 联系的元素</strong></p><p>一个联系涉及到的实体集个数，称为该联系的 <strong>元数</strong> 或 <strong>度数（Degree）</strong>。</p><p><strong>2. 联系类型的约束</strong></p><p>联系类型的约束限制了参与联系的实体的数目。有两类联系约束：<strong>基数约束</strong> 和 <strong>参与约束</strong>。</p><h4 id="2-4-ER-模型的操作"><a href="#2-4-ER-模型的操作" class="headerlink" title="2.4 ER 模型的操作"></a>2.4 ER 模型的操作</h4><p>在数据库设计过程中，常常要对 ER 图进行种种变化。这种变化称为 ER 模型的操作，包括 <strong>实体类型</strong>、<strong>联系类型</strong> 和 <strong>属性的分裂、合并、增删</strong> 等等。</p><h4 id="2-5-采用-ER-模型的数据库概念设计步骤"><a href="#2-5-采用-ER-模型的数据库概念设计步骤" class="headerlink" title="2.5 采用 ER 模型的数据库概念设计步骤"></a>2.5 采用 ER 模型的数据库概念设计步骤</h4><p><strong>1. 设计局部 ER 模型</strong></p><ul><li>确定局部结构范围</li><li>定义实体</li><li>定义联系</li><li>分配属性</li></ul><p><strong>2. 设计全局 ER 模型</strong></p><ul><li>确定公共实体类型</li><li>合并局部 ER 模型</li><li>消除冲突</li></ul><p><strong>3. 全局 ER 模型的优化</strong></p><ul><li>合并实体类型</li><li>消除冗余属性</li><li>消除冗余联系</li></ul><h3 id="3-关系模型的基本概念"><a href="#3-关系模型的基本概念" class="headerlink" title="3. 关系模型的基本概念"></a>3. 关系模型的基本概念</h3><h4 id="3-1-关系模型的基本术语"><a href="#3-1-关系模型的基本术语" class="headerlink" title="3.1 关系模型的基本术语"></a>3.1 关系模型的基本术语</h4><p>用二维表格表示实体集，用关键码表示实体之间联系的数据模型称为关系模型（Relationship Model）。</p><p>关系中属性的个数称为「元数」（Arity），元组个数称为「基数」（Cardinality）。</p><h4 id="3-2-关系的定义和性质"><a href="#3-2-关系的定义和性质" class="headerlink" title="3.2 关系的定义和性质"></a>3.2 关系的定义和性质</h4><p>在关系模型中，对关系作了下列规范性限制：</p><ol><li>关系中每一个属性值都是不可分解的；</li><li>关系中不允许出现重复元组（即不允许出现相同的元组）；</li><li>由于关系是一个集合，因此不考虑元组间的顺序，即没有行序；</li><li>元组中的属性在理论上也是无序的，但使用时按习惯考虑列的顺序；</li></ol><h4 id="3-3-三类完整性规则"><a href="#3-3-三类完整性规则" class="headerlink" title="3.3 三类完整性规则"></a>3.3 三类完整性规则</h4><p><strong>1. 实体完整性规则（Entity Integrity Rule）</strong></p><p>这条规则要求关系中元组在组成主键的属性上不能有空值。如果出现空值，那么主键值就起不了唯一标识元组的作用。</p><p><strong>2. 参照完整性规则（Reference Integrity Rule）</strong></p><p><strong>3. 用户定义的完整性规则</strong></p><h3 id="4-ER-模型到关系模型的转换"><a href="#4-ER-模型到关系模型的转换" class="headerlink" title="4. ER 模型到关系模型的转换"></a>4. ER 模型到关系模型的转换</h3><h4 id="4-1-ER-图转换成关系模式集的算法"><a href="#4-1-ER-图转换成关系模式集的算法" class="headerlink" title="4.1 ER 图转换成关系模式集的算法"></a>4.1 ER 图转换成关系模式集的算法</h4><ol><li>步骤 1（实体类型的转换）：将每个实体类型转换成一个关系模式，实体的属性即为关系模式的属性，实体标识符即为关系模式的键</li><li>步骤 2（联系类型的转换）：根据不同的情况做不同的处理</li></ol><h4 id="4-2-采用-ER-模型的逻辑设计步骤"><a href="#4-2-采用-ER-模型的逻辑设计步骤" class="headerlink" title="4.2 采用 ER 模型的逻辑设计步骤"></a>4.2 采用 ER 模型的逻辑设计步骤</h4><ol><li>导出初始关系模式集</li><li>规范化处理</li><li>模式评价</li><li>模式修正</li><li>设计子模式</li></ol>]]></content>
      
      
      <categories>
          
          <category> 自学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据库系统原理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据库系统基本概念</title>
      <link href="/2017/11/07/%E8%87%AA%E5%AD%A6/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/"/>
      <url>/2017/11/07/%E8%87%AA%E5%AD%A6/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/</url>
      
        <content type="html"><![CDATA[<h3 id="1-数据管理技术的发展"><a href="#1-数据管理技术的发展" class="headerlink" title="1. 数据管理技术的发展"></a>1. 数据管理技术的发展</h3><h4 id="1-1-人工管理阶段"><a href="#1-1-人工管理阶段" class="headerlink" title="1.1 人工管理阶段"></a>1.1 人工管理阶段</h4><p><strong>特点:</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. 数据不保存在计算机内；</span><br><span class="line">2. 没有专用的软件对数据进行管理；</span><br><span class="line">3. 只有程序 (Program) 的概念，没有文件 (File) 的概念；</span><br><span class="line">4. 数据库面向程序；</span><br></pre></td></tr></table></figure><h4 id="1-2-文件系统阶段"><a href="#1-2-文件系统阶段" class="headerlink" title="1.2 文件系统阶段"></a>1.2 文件系统阶段</h4><p><strong>特点:</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. 数据以「文件」形式可长期保存在外部存储器的磁盘上；</span><br><span class="line">2. 数据的逻辑结构与物理结构有了区别，但比较简单；</span><br><span class="line">3. 文件组织已多样化；</span><br><span class="line">4. 数据不再属于某个特定的程序，可以重复使用，即数据面向应用；</span><br><span class="line">5. 对数据的操作以记录为单位；</span><br></pre></td></tr></table></figure><p><strong>缺陷:</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. 数据冗余（Redundancy）；</span><br><span class="line">2. 数据不一致（Inconsistency）；</span><br><span class="line">3. 数据联系弱（Poor Data Relationship）；</span><br></pre></td></tr></table></figure><h4 id="1-3-数据库阶段"><a href="#1-3-数据库阶段" class="headerlink" title="1.3 数据库阶段"></a>1.3 数据库阶段</h4><p><strong>特点:</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. 采用数据模型表示复杂的数据结构；</span><br><span class="line">2. 有较高的数据独立性；</span><br><span class="line">3. 数据库系统为用户提供了方便的用户接口；</span><br><span class="line">4. 数据库系统提供以下四方面的数据控制功能：</span><br><span class="line">① 数据库的恢复：在数据库被破坏或数据不可靠时，系统有能力把数据库恢复到最近某个正确状态；</span><br><span class="line">② 数据库的并发控制：对程序的并发操作加以控制，防止数据库被破坏，杜绝提供给用户不正确的数据；</span><br><span class="line">③ 数据的完整性：保证数据库中数据始终是正确的；</span><br><span class="line">④ 数据安全性：保证数据的安全，防止数据丢失或被窃取、破坏；</span><br><span class="line">5. 增加了系统的灵活性：对数据的操作不一定以记录为单位，可以以数据项为单位；</span><br></pre></td></tr></table></figure><h4 id="1-4-高级数据库阶段"><a href="#1-4-高级数据库阶段" class="headerlink" title="1.4 高级数据库阶段"></a>1.4 高级数据库阶段</h4><p>主要标识是 20 世纪 80 年代的 <code>分布式数据库系统</code>、90 年代的 <code>对象数据库系统</code> 以及 21 世纪的 <code>Web 数据库系统</code>。</p><h3 id="2-数据库描述"><a href="#2-数据库描述" class="headerlink" title="2. 数据库描述"></a>2. 数据库描述</h3><h4 id="2-1-概念设计中的数据描述"><a href="#2-1-概念设计中的数据描述" class="headerlink" title="2.1 概念设计中的数据描述"></a>2.1 概念设计中的数据描述</h4><ol><li>实体（Entity）：客观存在，可以相互区别的事务称为实体；</li><li>实体集（Entity Set）：性质相同的同类实体的集合，称为实体集；</li><li>属性（Attribute）：实体有很多特性，每一个特性称为属性；</li><li>实体标识符（Identifier）：能唯一标识实体的属性或属性集，称为实体标识符；</li></ol><h4 id="2-2-逻辑设计中的数据描述"><a href="#2-2-逻辑设计中的数据描述" class="headerlink" title="2.2 逻辑设计中的数据描述"></a>2.2 逻辑设计中的数据描述</h4><ol><li>字段（Field）：标记实体属性的命名单位称为字段，或数据项；</li><li>记录（Record）：字段的有序集合称为记录；</li><li>文件（File）：同一类记录的集合称为文件；</li><li>关键码（Key）：能唯一标识文件中每个记录的字段或字段集，称为记录的关键码（简称为键）；</li></ol><p><strong>术语的对应关系</strong></p><table><thead><tr><th align="left">概念设计</th><th align="center"></th><th align="right">逻辑设计</th></tr></thead><tbody><tr><td align="left">实体</td><td align="center">·····</td><td align="right">记录</td></tr><tr><td align="left">属性</td><td align="center">·····</td><td align="right">字段（数据项）</td></tr><tr><td align="left">实体集</td><td align="center">·····</td><td align="right">文件</td></tr><tr><td align="left">实体标识符</td><td align="center">·····</td><td align="right">关键码</td></tr></tbody></table><p>在数据库技术中，每个概念都有 <strong>类型（type）</strong> 和 <strong>值（value）</strong> 之区分。<strong>类型</strong> 是概念的内涵，而 <strong>值</strong> 是概念的外延。</p><p>数据描述有两种形式：<strong>物理数据描述</strong> 和 <strong>逻辑数据描述</strong>。</p><p><code>物理数据描述</code> 是指数据在存储设备上的存储方式的描述，物理数据是实际存放在存储设备上的数据。例如，物理联系、物理结构、物理文件、物理记录等术语，都是用来描述存储数据的细节。</p><p><code>逻辑数据描述</code> 是指程序员或用户用以操作的数据形式的描述，是抽象的概念化数据。例如，逻辑联系、逻辑结构、逻辑文件、逻辑记录等术语，都是用户观点的数据描述。</p><h4 id="2-3-物理设计中的数据描述"><a href="#2-3-物理设计中的数据描述" class="headerlink" title="2.3 物理设计中的数据描述"></a>2.3 物理设计中的数据描述</h4><p><strong>1. 物理存储介质层次</strong></p><p>根据访问数据的速度、成本和可靠性，计算机系统的存储介质可分为以下六类：</p><ol><li>高速缓冲存储器（Cache）：Cache 是访问速度最快，也是最昂贵的存储器，其容量小，由 CPU 直接管理；</li><li>主存储器（Main Memory）：又称为内存。机器指令可以直接对内存中的数据进行修改。但致命的一点是，在掉电或者系统崩溃时，内存数据立即全部丢失。它由操作系统管理；</li><li>快擦写存储器（Flash Memory）：又称为「电可擦可编程只读存储器」（即 EEP-ROM），简称为「快闪存」。快闪存在掉电后仍能保持数据部丢失，其操作速度略低于内存；</li><li>磁盘存储器（Magnetic Disk）：磁盘是目前最流行的外部存储器。能长时间地练级存储数据，并能直接读取数据，所以又称为「直接存取存储器」；</li><li>光存储器（Optical Storage）：目前流行的光存储器是「光盘存储器」（CD - ROM、CD - RW、DVD - RW 等）。数据以光的形式存储在盘里，然后用一个激光器去读；</li><li>磁带（Tape Storage）：磁带用于存储拷贝的数据或归档的数据；</li></ol><p><img src="http://personal-blog.oss-cn-hangzhou.aliyuncs.com/db_stroage.png" alt="存储介质层次"></p><p><strong>2. 物理存储中的数据描述</strong></p><ol><li>位（Bit，比特）：一个二进制位称为「位」。一位只能取 0 或 1 两个状态；</li><li>字节（Byte，简记为 B）：8 个比特称为一个字节，可以存放一个字符所对应的 ASCII 码；</li><li>字（Word）：若干个字节组成一个字。一个字所含的二进制位的位数称为字长。各种计算机的字长是不一样的，例如有 8 位、16 位、24 位、32 位等；</li><li>块（Block）：又称为物理块或物理记录。块是内存和外存交换信息的最小单位，每块的大小，通常为 2<sup>10</sup> ~ 2<sup>14</sup> 字节。内、外存信息交换是由操作系统的文件系统管理的；</li><li>桶（Bucket）：外存的逻辑单位，一个桶可以包含一个物理块或多个在空间上不一定连续的物理块；</li><li>卷（Volume）：一个输入输出设备所能装载的全部有用信息，称为「卷」。例如磁带机的一盘磁带就是一卷，磁带的一个盘组也是一卷；</li></ol><h4 id="2-4-数据联系的描述"><a href="#2-4-数据联系的描述" class="headerlink" title="2.4 数据联系的描述"></a>2.4 数据联系的描述</h4><p><code>联系（Relationship）</code>是实体之间的相互关系。与一个联系有关的实体集个数，称为联系的元数。</p><p>二元联系有以下三种类型：</p><ol><li>一对一联系</li><li>一对多联系</li><li>多对多联系</li></ol><h3 id="3-数据抽象的级别"><a href="#3-数据抽象的级别" class="headerlink" title="3. 数据抽象的级别"></a>3. 数据抽象的级别</h3><h4 id="3-1-数据抽象的过程"><a href="#3-1-数据抽象的过程" class="headerlink" title="3.1 数据抽象的过程"></a>3.1 数据抽象的过程</h4><p>根据数据抽象的级别定义了四种模型：概念数据模型、逻辑数据模型、外部数据模型和内部数据模型。</p><blockquote><p>表达用户需求观点的数据全局逻辑结构的模型，称为「概念模型」。</p></blockquote><blockquote><p>表达计算机实现观点的 DB 全局逻辑结构的模型，称为「逻辑模型」。</p></blockquote><blockquote><p>表达用户使用观点的 DB 局部逻辑结构的模型，称为「外部模型」。</p></blockquote><blockquote><p>表达 DB 物理结构的模型，称为「内部模型」。</p></blockquote><p><img src="http://personal-blog.oss-cn-hangzhou.aliyuncs.com/db_model_describe.png" alt="四种模型之间的相互关系"></p><p>数据抽象过程，也就是数据库设计的过程，具体步骤如下：</p><blockquote><p>第一步：根据用户需求，设计数据库的概念模型，这是一个「综合」过程；</p><p>第二步：根据转换规则，把概念模型转换成数据库的逻辑模型，这是一个「转换」的过程；</p><p>第三步：根据用户的业务特点，设计不同的外部模型，给程序员使用。也就是应用程序使用的是数据库的外部模型。外部模型与逻辑模型之间的对应性称为映像；</p><p>第四步：数据库实现时，要根据逻辑模型设计其内部模型。内部模型与逻辑模型之间的对应性称为映像；</p></blockquote><p>一般，上述第一步称为 DB 的概念设计，第二、三步称为 DB 的逻辑设计，第四步称为 DB 的物理设计。</p><h4 id="3-2-概念模型"><a href="#3-2-概念模型" class="headerlink" title="3.2 概念模型"></a>3.2 概念模型</h4><p>这四种模型中，概念模型的抽象级别最高。其特点如下所述：</p><ol><li>概念模型表达了数据的整体逻辑结构，它是系统用户对整个应用项目涉及的数据的全面描述；</li><li>概念模型是从用户需求的观点出发，对数据建模；</li><li>概念模型独立于硬件和软件；</li><li>概念模型是数据库设计人员与用户之间进行交流的工具；</li></ol><h4 id="3-3-逻辑模型"><a href="#3-3-逻辑模型" class="headerlink" title="3.3 逻辑模型"></a>3.3 逻辑模型</h4><p>逻辑模型具有下列特点：</p><ol><li>逻辑模型表达了 DB 的整体逻辑结构，但它是设计人员对整个应用项目数据库的全面描述；</li><li>逻辑模型是从数据库实现的观点出发，对数据建模；</li><li>逻辑模型独立于硬件，但依赖于软件（DDMS）；</li><li>逻辑模型是数据库设计人员与应用程序员之间进行交流的工具</li></ol><p>逻辑模型主要有 <code>层次</code>、<code>网状</code> 和 <code>关系</code> 模型等三种。</p><p><strong>1. 层次模型（Hierarchical Model）</strong></p><p>用树型（层次）结构表示实体类型及实体间联系的数据模型称为 <code>层次模型</code>。树种的节点是记录类型，每个非根节点有且只有一个父节点。上一层记录类型和下一层记录类型之间的联系是 1:N 联系。</p><p>层次模型的 <strong>特点</strong> 是记录之间的联系通过指针来实现，查询效率高。</p><p>层次模型的 <strong>缺点</strong>：</p><ol><li>只能表示 1:N 联系；</li><li>由于层次顺序的严格和复杂，引起数据的查询和更新操作很复杂，因此应用程序的编写也比较复杂；</li></ol><p><strong>2. 网状模型（Network Model）</strong></p><p> 用有向图结构表示实体类型及实体间联系的数据模型称为 <code>网状模型</code>。</p><p>网状模型的 <strong>特点</strong> 是记录之间的联系通过指针实现，M:N 联系也容易实现（一个 M:N 联系可拆成两个 1:N 联系），查询效率较高。</p><p><strong>缺点</strong>：数据结构复杂和编程复杂。</p><p><strong>3. 关系模型（Relational Model）</strong></p><p><code>关系模型（Relational Model）</code> 的主要特征是用二维表格表达实体集。</p><p><strong>三种逻辑数据模型的比较</strong></p><table><thead><tr><th align="left"></th><th align="left">层次模型</th><th align="left">网状模型</th><th align="left">关系模型</th></tr></thead><tbody><tr><td align="left"><strong>数据结构</strong></td><td align="left">复杂（树结构）</td><td align="left">复杂（有向图结构）</td><td align="left">简单（二维表）</td></tr><tr><td align="left"><strong>数据联系</strong></td><td align="left">通过指针</td><td align="left">通过指针</td><td align="left">通过表间的公共属性</td></tr><tr><td align="left"><strong>查询语言</strong></td><td align="left">过程性语言</td><td align="left">过程性语言</td><td align="left">非过程性语言</td></tr><tr><td align="left"><strong>典型产品</strong></td><td align="left">IMS</td><td align="left">IDMS、TOTAL</td><td align="left">Oracle、Sybase</td></tr></tbody></table><h4 id="3-4-外部模型"><a href="#3-4-外部模型" class="headerlink" title="3.4 外部模型"></a>3.4 外部模型</h4><p>外部模型具有如下 <strong>特点</strong>：</p><ol><li>外部模型是逻辑模型的一个逻辑子集；</li><li>外部模型独立于硬件，依赖于软件；</li><li>外部模型反映了用户使用数据库的观点；</li></ol><p>外部模型 <strong>优点</strong>：</p><ol><li>简化了用户的观点；</li><li>有助于数据库的安全性保护；</li><li>外部模型是对概念模型的支持；</li></ol><h4 id="3-5-内部模型"><a href="#3-5-内部模型" class="headerlink" title="3.5 内部模型"></a>3.5 内部模型</h4><p><code>内部模型</code> 又称为物理模型，是数据库最低层的抽象，它描述数据在磁盘或磁带上的存储方式（文件的结构）、存取设备（外存的空间分配）和存取方法（主索引和辅助索引）。</p><h4 id="3-6-三层模式和两级映像"><a href="#3-6-三层模式和两级映像" class="headerlink" title="3.6 三层模式和两级映像"></a>3.6 三层模式和两级映像</h4><p><strong>1. 三层模式体系结构</strong></p><p>在用户（或应用程序）到数据库之间，DB 的数据结构有三个层次：<strong>外部模型</strong>、<strong>逻辑模型</strong> 和 <strong>内部模型</strong>。这三个层次要用 DB 的数据定义语言（Data Definition Language，简记为 DDL）定义，定义以后的内容称为「模式」（Schema），即外模式、逻辑模式和内模式。这三种模式的形式定义如下：</p><ol><li><code>外模式</code> 是用户与数据库系统的接口，是用户用到的那部分数据的描述。外模式由若干个外部记录类型组成；</li><li><code>逻辑模式</code> 是数据库中全部数据的整体逻辑结构的描述。它由若干个逻辑记录类型组成，还包含记录间联系、数据的完整性安全性等要求；</li><li><code>内模式</code> 是数据库在物理存储方面的描述，定义所有内部记录类型、索引和文件的组织方式，以及数据控制方面的细节；</li></ol><p>三层模式体系结构具有以下 <strong>特点</strong>：</p><ol><li>用户使用 DB 的数据操纵语言（Data Manipulation Language，简记为 DML）语句对数据库进行操作，实际上是对外模式的外部记录进行操作；</li><li>逻辑模式必须不涉及到存储结构、访问技术等细节；</li><li>内模式并不涉及到物理设备的约束；</li></ol><p><strong>2. 两级映像</strong></p><p>三层模式之间存在着两级映像：</p><ol><li>外模式&#x2F;逻辑模式映像存在于外模式和逻辑模式之间，用于定义外模式和逻辑模式之间的对应性。这个映像一般是放在外模式中描述的；</li><li>逻辑模式&#x2F;内模式映像存在于逻辑模式和内模式之间，用于定义逻辑模式和内模式之间的对应性。这个映像一般是放在内模式中描述的；</li></ol><h4 id="3-7-高度的数据独立性"><a href="#3-7-高度的数据独立性" class="headerlink" title="3.7 高度的数据独立性"></a>3.7 高度的数据独立性</h4><p><code>数据独立性（Data Independence）</code> 是指应用程序和数据库的数据结构之间相互独立，不受影响。</p><p>数据独立性分成 <strong>物理数据独立性</strong> 和 <strong>逻辑数据独立性</strong> 两个级别。</p><p><strong>1. 物理数据独立性</strong></p><p>如果数据库的内模式要修改，即数据库的物理结构有所变化，那么只要对逻辑模式&#x2F;内模式映像（即「对应性」）作相应的修改，可以使逻辑模式尽可能保持不变。</p><p><strong>2. 逻辑数据独立性</strong><br>如果数据库的逻辑模式要修改，譬如增加记录类型或增加数据项，那么只要对外模式&#x2F;逻辑模式映像作相应的修改，可以使外模式和应用程序尽可能保持不变。这样，我们称数据库达到了逻辑数据独立性（简称逻辑独立性）。</p><h3 id="4-数据库管理系统（DBMS）"><a href="#4-数据库管理系统（DBMS）" class="headerlink" title="4. 数据库管理系统（DBMS）"></a>4. 数据库管理系统（DBMS）</h3><h4 id="4-1-DBMS-的工作模式如下："><a href="#4-1-DBMS-的工作模式如下：" class="headerlink" title="4.1 DBMS 的工作模式如下："></a>4.1 DBMS 的工作模式如下：</h4><ol><li>接受应用程序的数据请求和处理请求；</li><li>将用户的数据请求（高级指令）转换成复杂的机器代码（低层指令）；</li><li>实现对数据库的操作；</li><li>从对数据库的操作中接受查询结果；</li><li>对查询结果进行处理（格式转换）；</li><li>将处理结果返回给用户；</li></ol><h4 id="4-2-DBMS-的主要功能"><a href="#4-2-DBMS-的主要功能" class="headerlink" title="4.2 DBMS 的主要功能"></a>4.2 DBMS 的主要功能</h4><p><strong>1. 数据库的定义功能</strong></p><p> DBMS 提供 DDL 定义数据库的三级结构、两级映像，定义数据的完整性约束、保密限制等约束。因此，在 DBMS 中应包括 DDL 的编译程序。</p><p><strong>2. 数据库的操纵功能</strong></p><p> DBMS 提供 DML 实现对数据的操作。基本的数据操作有两类：检索（查询）和更新（包括插入、删除、更新）。因此，在 DBMS 中应包括 DML 的编译程序或解释程序。</p><p><strong>3. 数据库的保护功能</strong></p><ol><li>数据库的恢复；</li><li>数据库的并发控制；</li><li>数据完整性控制；</li><li>数据安全性控制；</li></ol><p><strong>4. 数据库的维护功能</strong></p><p>这一部分包括数据库的数据载入、转换、转储，数据库的改组以及性能监控等功能。这些功能分别由各个使用程序（Utilities）完成。</p><p><strong>5. 数据字典</strong></p><p>数据库系统中存放三级结构定义的数据库称为 <code>数据字典（Data Dictionary，DD）</code>。对数据库的操作都要通过都要通过 DD 才能实现。DD 中还存放数据库运行时的统计信息，例如记录个数、访问次数等。管理 DD 的子系统称为「DD 系统」。</p><h3 id="5-数据库系统（DBS）"><a href="#5-数据库系统（DBS）" class="headerlink" title="5. 数据库系统（DBS）"></a>5. 数据库系统（DBS）</h3><h4 id="5-1-DBS-的组成"><a href="#5-1-DBS-的组成" class="headerlink" title="5.1 DBS 的组成"></a>5.1 DBS 的组成</h4><p> DBS 是采用了数据库技术的计算机系统。</p><p>DBS 是一个实际可运行的，按照数据库方法存储、维护和向应用系统提供数据支持的系统，它是 <code>数据库</code>、<code>硬件</code>、<code>软件</code>和 <code>数据库管理员</code> 的集合体。</p><p>DBA 的主要职责有以下六点：</p><ol><li>定义模式</li><li>定义内模式</li><li>与用户联络。包括定义外模式、应用程序的设计、提供技术培训等专业服务</li><li>定义安全性规则，对用户访问数据库的授权</li><li>定义完整性的规则，监督数据库的运行</li><li>数据库的转储和恢复工作</li></ol><h4 id="5-2-DBS-的全局结构"><a href="#5-2-DBS-的全局结构" class="headerlink" title="5.2 DBS 的全局结构"></a>5.2 DBS 的全局结构</h4><p><strong>1. 数据库用户</strong></p><ol><li>DBA：DBA 负责三级结构的定义和修改，以及访问授权、日常维护等工作。DBA 和 DBMS 之间的界面是数据库模式；</li><li>专业用户：指数据库设计中的上层人士（例如系统分析员）；</li><li>应用程序员：指使用主语言和 DML 语言编写应用程序的计算机工作者；</li><li>终端用户：指应用程序的非计算机人员；</li></ol><p><strong>2. DBMS 的查询处理器</strong></p><ol><li>DDL 解释器：解释 DDL 语句，并将这些定义登录在数据字典中；</li><li>DML 编译器：对 DML 语句进行优化，并转换成查询求值引擎能执行的低层指令；</li><li>嵌入式 DML 的预编译器：把嵌入在主语言中的 DML 语句处理成规范的过程调用形式；</li><li>查询求值引擎：执行由 DML 编译器编译器产生的低层指令；</li></ol><p><strong>3. DBMS 的存储管理器</strong></p><ol><li>权限和完整性管理器：测试应用程序对数据库的修改是否满足完整性约束，检查用户访问数据的合法性；</li><li>事务管理器：DBS 的逻辑工作单元称为事务（Transaction），事务由对 DB 的操作序列组成。事务管理器用于确保 DB 一致性（正确性）状态，保证并发操作正确执行；</li><li>文件管理器：负责磁盘空间的合理分配，管理吴丽文件的存储结构和存取方式</li><li>缓冲区管理器：为应用程序开辟 DB 的系统缓冲区，负责将从磁盘中读出的数据送入内存的缓冲区；</li></ol><p><strong>4. 磁盘存储器中的数据结构</strong></p><ol><li>数据文件：存储数据库管理的用户数据自身。数据库在磁盘上的基本组织形式是文件，这样可以充分利用 OS 管理外存的功能；</li><li>数据字典：存储三级结构的描述（一般称为元数据 Metadata）；</li><li>索引：为提高查询速度而设置的逻辑排序手段；</li><li>统计数据：存储 DBS 运行时统计分析的数据。查询处理器可使用这些信息更有效地进行查询处理；</li><li>日志：存储 DBS 运行时对 DB 的操作情况，以备以后查阅数据库的使用情况及数据库恢复时使用；</li></ol><h4 id="5-3-DBS-的效益"><a href="#5-3-DBS-的效益" class="headerlink" title="5.3 DBS 的效益"></a>5.3 DBS 的效益</h4><ol><li>灵活性。数据库容易扩充，以适应用户新的要求；也容易移植，以适应新的硬件环境和更大的数据容量；</li><li>简易型。由于精心设计的数据库能模拟用户单位的运转情况，并提供用户单位详细的数据资料，因此能使管理部门和使用部门方便地运用和理解数据库；</li><li>面向用户。由于数据库能反映用户单位的实际运转情况，因此基本上能满足用户的要求，为用户的信息系统和信息化奠定了基础；</li><li>有效的数据控制。对数据实现集中控制能保证所有用户在同样的数据上操作，而且数据对所有部门具有相同的语义。数据的冗余减少到最小程度，消除了数据的不一致性；</li><li>加快应用系统的开发速度。系统分析员和程序员可以集中精力于应用的逻辑方面，而不必关心物理设计和文件设计的细节，后援和恢复问题均由系统来保证。由于 DML 命令功能强，因此编写应用程序较方便，进一步提高了程序员的生产效率；</li><li>维护方便。数据独立性使得修改数据库结构时尽量不影响已有的应用程序，使得程序维护的工作量大为减少；</li><li>标准化。数据库方法能促进整个用户单位乃至全社会的数据一致性和使用的标准化工作；</li></ol>]]></content>
      
      
      <categories>
          
          <category> 自学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据库系统原理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Proxy</title>
      <link href="/2017/08/03/ES6/Proxy/"/>
      <url>/2017/08/03/ES6/Proxy/</url>
      
        <content type="html"><![CDATA[<h3 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h3><p><strong>Proxy</strong> 用于修改某些操作的默认行为，等同于在语言层面做出修改，所以属于一种「元编程」（meta programming），即对编程语言进行编程。</p><p>Proxy 可以理解成，在目标对象之前架设一层「拦截」，外界对该对象的访问，都必须先通过这层拦截，因此提供了一种机制，可以对外界的访问进行过滤和改写。Proxy 这个词的原意是代理，用在这里表示由它来「代理」某些操作，可以译为「代理器」。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = <span class="keyword">new</span> <span class="title class_">Proxy</span>(&#123;&#125;, &#123;</span><br><span class="line">  <span class="attr">get</span>: <span class="keyword">function</span> (<span class="params">target, key, receiver</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`getting <span class="subst">$&#123;key&#125;</span>!`</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Reflect</span>.<span class="title function_">get</span>(target, key, receiver);</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">set</span>: <span class="keyword">function</span> (<span class="params">target, key, value, receiver</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`setting <span class="subst">$&#123;key&#125;</span>!`</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Reflect</span>.<span class="title function_">set</span>(target, key, value, receiver);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>上面代码对一个空对象架设了一层拦截，重定义了属性的读取（<code>get</code>）和设置（<code>set</code>）行为。这里暂时先不解释具体的语法，只看运行结果。对设置了拦截行为的对象 <code>obj</code>，去读写它的属性，就会得到下面的结果。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">obj.<span class="property">count</span> = <span class="number">1</span></span><br><span class="line"><span class="comment">//  setting count!</span></span><br><span class="line">++obj.<span class="property">count</span></span><br><span class="line"><span class="comment">//  getting count!</span></span><br><span class="line"><span class="comment">//  setting count!</span></span><br><span class="line"><span class="comment">//  2</span></span><br></pre></td></tr></table></figure><p>上面代码说明，Proxy 实际上重载（overload）了点运算符，即用自己的定义覆盖了语言的原始定义。</p><p>ES6 原生提供 Proxy 构造函数，用来生成 Proxy 实例。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> proxy = <span class="keyword">new</span> <span class="title class_">Proxy</span>(target, handler);</span><br></pre></td></tr></table></figure><p><code>Proxy</code> 对象的所有用法，都是上面这种形式，不同的只是 <code>handler</code> 参数的写法。其中，<code>new Proxy()</code> 表示生成一个 <code>Proxy</code> 实例，<code>target</code> 参数表示所要拦截的目标对象，<code>handler</code> 参数也是一个对象，用来定制拦截行为。</p><p>下面是另一个拦截读取属性行为的例子。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> proxy = <span class="keyword">new</span> <span class="title class_">Proxy</span>(&#123;&#125;, &#123;</span><br><span class="line">  <span class="attr">get</span>: <span class="keyword">function</span>(<span class="params">target, property</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">35</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">proxy.<span class="property">time</span> <span class="comment">// 35</span></span><br><span class="line">proxy.<span class="property">name</span> <span class="comment">// 35</span></span><br><span class="line">proxy.<span class="property">title</span> <span class="comment">// 35</span></span><br></pre></td></tr></table></figure><h3 id="2-Proxy-实例的方法"><a href="#2-Proxy-实例的方法" class="headerlink" title="2. Proxy 实例的方法"></a>2. Proxy 实例的方法</h3><h4 id="2-1-get"><a href="#2-1-get" class="headerlink" title="2.1 get()"></a>2.1 get()</h4><p><code>get</code> 方法用于拦截某个属性的读取操作。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;张三&quot;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> proxy = <span class="keyword">new</span> <span class="title class_">Proxy</span>(person, &#123;</span><br><span class="line">  <span class="attr">get</span>: <span class="keyword">function</span>(<span class="params">target, property</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (property <span class="keyword">in</span> target) &#123;</span><br><span class="line">      <span class="keyword">return</span> target[property];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ReferenceError</span>(<span class="string">&quot;Property \&quot;&quot;</span> + property + <span class="string">&quot;\&quot; does not exist.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">proxy.<span class="property">name</span> <span class="comment">// &quot;张三&quot;</span></span><br><span class="line">proxy.<span class="property">age</span> <span class="comment">// 抛出一个错误</span></span><br></pre></td></tr></table></figure><p>上面代码表示，如果访问目标对象不存在的属性，会抛出一个错误。如果没有这个拦截函数，访问不存在的属性，只会返回 <code>undefined</code>。</p><p><code>get</code> 方法可以继承。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> proto = <span class="keyword">new</span> <span class="title class_">Proxy</span>(&#123;&#125;, &#123;</span><br><span class="line">  <span class="title function_">get</span>(<span class="params">target, propertyKey, receiver</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;GET &#x27;</span>+propertyKey);</span><br><span class="line">    <span class="keyword">return</span> target[propertyKey];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> obj = <span class="title class_">Object</span>.<span class="title function_">create</span>(proto);</span><br><span class="line">obj.<span class="property">xxx</span> <span class="comment">// &quot;GET xxx&quot;</span></span><br></pre></td></tr></table></figure><p>上面代码中，拦截操作定义在 <code>Prototype</code> 对象上面，所以如果读取 <code>obj</code> 对象继承的属性时，拦截会生效。</p><p>下面的例子使用 <code>get</code> 拦截，实现数组读取负数的索引。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">createArray</span>(<span class="params">...elements</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> handler = &#123;</span><br><span class="line">    <span class="title function_">get</span>(<span class="params">target, propKey, receiver</span>) &#123;</span><br><span class="line">      <span class="keyword">let</span> index = <span class="title class_">Number</span>(propKey);</span><br><span class="line">      <span class="keyword">if</span> (index &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        propKey = <span class="title class_">String</span>(target.<span class="property">length</span> + index);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="title class_">Reflect</span>.<span class="title function_">get</span>(target, propKey, receiver);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> target = [];</span><br><span class="line">  target.<span class="title function_">push</span>(...elements);</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Proxy</span>(target, handler);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> arr = <span class="title function_">createArray</span>(<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>);</span><br><span class="line">arr[-<span class="number">1</span>] <span class="comment">// c</span></span><br></pre></td></tr></table></figure><p>上面代码中，数组的位置参数是 <code>-1</code>，就会输出数组的倒数最后一个成员。</p><h4 id="2-2-set"><a href="#2-2-set" class="headerlink" title="2.2 set()"></a>2.2 set()</h4><p><code>set</code> 方法用来拦截某个属性的赋值操作。</p><p>假定 <code>Person</code> 对象有一个 <code>age</code> 属性，该属性应该是一个不大于 <code>200</code> 的整数，那么可以使用 <code>Proxy</code> 保证 <code>age</code> 的属性值符合要求。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> validator = &#123;</span><br><span class="line">  <span class="attr">set</span>: <span class="keyword">function</span>(<span class="params">obj, prop, value</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (prop === <span class="string">&#x27;age&#x27;</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (!<span class="title class_">Number</span>.<span class="title function_">isInteger</span>(value)) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">TypeError</span>(<span class="string">&#x27;The age is not an integer&#x27;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (value &gt; <span class="number">200</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RangeError</span>(<span class="string">&#x27;The age seems invalid&#x27;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对于age以外的属性，直接保存</span></span><br><span class="line">    obj[prop] = value;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> person = <span class="keyword">new</span> <span class="title class_">Proxy</span>(&#123;&#125;, validator);</span><br><span class="line"></span><br><span class="line">person.<span class="property">age</span> = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">person.<span class="property">age</span> <span class="comment">// 100</span></span><br><span class="line">person.<span class="property">age</span> = <span class="string">&#x27;young&#x27;</span> <span class="comment">// 报错</span></span><br><span class="line">person.<span class="property">age</span> = <span class="number">300</span> <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure><p>上面代码中，由于设置了存值函数 <code>set</code>，任何不符合要求的 <code>age</code> 属性赋值，都会抛出一个错误，这是数据验证的一种实现方法。利用 <code>set</code> 方法，还可以数据绑定，即每当对象发生变化时，会自动更新  <code>DOM</code>。</p><p>有时，我们会在对象上面设置内部属性，属性名的第一个字符使用下划线开头，表示这些属性不应该被外部使用。结合 <code>get</code> 和 <code>set</code> 方法，就可以做到防止这些内部属性被外部读写。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> handler = &#123;</span><br><span class="line">  get (target, key) &#123;</span><br><span class="line">    <span class="title function_">invariant</span>(key, <span class="string">&#x27;get&#x27;</span>);</span><br><span class="line">    <span class="keyword">return</span> target[key];</span><br><span class="line">  &#125;,</span><br><span class="line">  set (target, key, value) &#123;</span><br><span class="line">    <span class="title function_">invariant</span>(key, <span class="string">&#x27;set&#x27;</span>);</span><br><span class="line">    target[key] = value;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">invariant</span> (key, action) &#123;</span><br><span class="line">  <span class="keyword">if</span> (key[<span class="number">0</span>] === <span class="string">&#x27;_&#x27;</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">`Invalid attempt to <span class="subst">$&#123;action&#125;</span> private &quot;<span class="subst">$&#123;key&#125;</span>&quot; property`</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> target = &#123;&#125;;</span><br><span class="line"><span class="keyword">var</span> proxy = <span class="keyword">new</span> <span class="title class_">Proxy</span>(target, handler);</span><br><span class="line">proxy.<span class="property">_prop</span></span><br><span class="line"><span class="comment">// Error: Invalid attempt to get private &quot;_prop&quot; property</span></span><br><span class="line">proxy.<span class="property">_prop</span> = <span class="string">&#x27;c&#x27;</span></span><br><span class="line"><span class="comment">// Error: Invalid attempt to set private &quot;_prop&quot; property</span></span><br></pre></td></tr></table></figure><p>上面代码中，只要读写的属性名的第一个字符是下划线，一律抛错，从而达到禁止读写内部属性的目的。</p><p>注意，如果目标对象自身的某个属性，不可写也不可配置，那么 <code>set</code> 不得改变这个属性的值，只能返回同样的值，否则报错。</p><h4 id="2-3-apply"><a href="#2-3-apply" class="headerlink" title="2.3 apply()"></a>2.3 apply()</h4><p><code>apply</code> 方法拦截函数的调用、<code>call</code> 和 <code>apply</code> 操作。</p><p><code>apply</code> 方法可以接受三个参数，分别是目标对象、目标对象的上下文对象（<code>this</code>）和目标对象的参数数组。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> handler = &#123;</span><br><span class="line">  apply (target, ctx, args) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Reflect</span>.<span class="title function_">apply</span>(...<span class="variable language_">arguments</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>下面是一个例子。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> target = <span class="keyword">function</span> (<span class="params"></span>) &#123; <span class="keyword">return</span> <span class="string">&#x27;I am the target&#x27;</span>; &#125;;</span><br><span class="line"><span class="keyword">var</span> handler = &#123;</span><br><span class="line">  <span class="attr">apply</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;I am the proxy&#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> p = <span class="keyword">new</span> <span class="title class_">Proxy</span>(target, handler);</span><br><span class="line"></span><br><span class="line"><span class="title function_">p</span>()</span><br><span class="line"><span class="comment">// &quot;I am the proxy&quot;</span></span><br></pre></td></tr></table></figure><p>上面代码中，变量 <code>p</code> 是 Proxy 的实例，当它作为函数调用时（<code>p()</code>），就会被 <code>apply</code> 方法拦截，返回一个字符串。</p><h4 id="2-4-has"><a href="#2-4-has" class="headerlink" title="2.4 has()"></a>2.4 has()</h4><p><code>has</code> 方法用来拦截 <code>HasProperty</code> 操作，即判断对象是否具有某个属性时，这个方法会生效。典型的操作就是 <code>in</code> 运算符。</p><p>下面的例子使用 <code>has</code> 方法隐藏某些属性，不被 <code>in</code> 运算符发现。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> handler = &#123;</span><br><span class="line">  has (target, key) &#123;</span><br><span class="line">    <span class="keyword">if</span> (key[<span class="number">0</span>] === <span class="string">&#x27;_&#x27;</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> key <span class="keyword">in</span> target;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> target = &#123; <span class="attr">_prop</span>: <span class="string">&#x27;foo&#x27;</span>, <span class="attr">prop</span>: <span class="string">&#x27;foo&#x27;</span> &#125;;</span><br><span class="line"><span class="keyword">var</span> proxy = <span class="keyword">new</span> <span class="title class_">Proxy</span>(target, handler);</span><br><span class="line"><span class="string">&#x27;_prop&#x27;</span> <span class="keyword">in</span> proxy <span class="comment">// false</span></span><br></pre></td></tr></table></figure><p>另外，虽然 <code>for...in</code> 循环也用到了 <code>in</code> 运算符，但是 <code>has</code> 拦截对 <code>for...in</code> 循环不生效。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> stu1 = &#123;<span class="attr">name</span>: <span class="string">&#x27;张三&#x27;</span>, <span class="attr">score</span>: <span class="number">59</span>&#125;;</span><br><span class="line"><span class="keyword">let</span> stu2 = &#123;<span class="attr">name</span>: <span class="string">&#x27;李四&#x27;</span>, <span class="attr">score</span>: <span class="number">99</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> handler = &#123;</span><br><span class="line">  <span class="title function_">has</span>(<span class="params">target, prop</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (prop === <span class="string">&#x27;score&#x27;</span> &amp;&amp; target[prop] &lt; <span class="number">60</span>) &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`<span class="subst">$&#123;target.name&#125;</span> 不及格`</span>);</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> prop <span class="keyword">in</span> target;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> oproxy1 = <span class="keyword">new</span> <span class="title class_">Proxy</span>(stu1, handler);</span><br><span class="line"><span class="keyword">let</span> oproxy2 = <span class="keyword">new</span> <span class="title class_">Proxy</span>(stu2, handler);</span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;score&#x27;</span> <span class="keyword">in</span> oproxy1</span><br><span class="line"><span class="comment">// 张三 不及格</span></span><br><span class="line"><span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;score&#x27;</span> <span class="keyword">in</span> oproxy2</span><br><span class="line"><span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> a <span class="keyword">in</span> oproxy1) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(oproxy1[a]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 张三</span></span><br><span class="line"><span class="comment">// 59</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> b <span class="keyword">in</span> oproxy2) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(oproxy2[b]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 李四</span></span><br><span class="line"><span class="comment">// 99</span></span><br></pre></td></tr></table></figure><p>上面代码中，<code>has</code> 拦截只对 <code>in</code> 循环生效，对 <code>for...in</code> 循环不生效，导致不符合要求的属性没有被排除在 <code>for...in</code> 循环之外。</p><h4 id="2-5-construct"><a href="#2-5-construct" class="headerlink" title="2.5 construct()"></a>2.5 construct()</h4><p><code>construct</code> 方法用于拦截 <code>new</code> 命令，下面是拦截对象的写法。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> handler = &#123;</span><br><span class="line">  construct (target, args, newTarget) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title function_">target</span>(...args);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><code>construct</code> 方法可以接受两个参数。</p><ul><li><ul><li><code>target</code>: 目标对象</li></ul></li><li><ul><li><code>args</code>：构建函数的参数对象</li></ul></li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> p = <span class="keyword">new</span> <span class="title class_">Proxy</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;&#125;, &#123;</span><br><span class="line">  <span class="attr">construct</span>: <span class="keyword">function</span>(<span class="params">target, args</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;called: &#x27;</span> + args.<span class="title function_">join</span>(<span class="string">&#x27;, &#x27;</span>));</span><br><span class="line">    <span class="keyword">return</span> &#123; <span class="attr">value</span>: args[<span class="number">0</span>] * <span class="number">10</span> &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">(<span class="keyword">new</span> <span class="title function_">p</span>(<span class="number">1</span>)).<span class="property">value</span></span><br><span class="line"><span class="comment">// &quot;called: 1&quot;</span></span><br><span class="line"><span class="comment">// 10</span></span><br></pre></td></tr></table></figure><p><code>construct</code> 方法返回的必须是一个对象，否则会报错。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> p = <span class="keyword">new</span> <span class="title class_">Proxy</span>(<span class="keyword">function</span>(<span class="params"></span>) &#123;&#125;, &#123;</span><br><span class="line">  <span class="attr">construct</span>: <span class="keyword">function</span>(<span class="params">target, argumentsList</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="title function_">p</span>() <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure><h4 id="2-6-deleteProperty"><a href="#2-6-deleteProperty" class="headerlink" title="2.6 deleteProperty()"></a>2.6 deleteProperty()</h4><p><code>deleteProperty</code> 方法用于拦截 <code>delete</code> 操作，如果这个方法抛出错误或者返回 <code>false</code>，当前属性就无法被 <code>delete</code> 命令删除。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> handler = &#123;</span><br><span class="line">  deleteProperty (target, key) &#123;</span><br><span class="line">    <span class="title function_">invariant</span>(key, <span class="string">&#x27;delete&#x27;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">invariant</span> (key, action) &#123;</span><br><span class="line">  <span class="keyword">if</span> (key[<span class="number">0</span>] === <span class="string">&#x27;_&#x27;</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">`Invalid attempt to <span class="subst">$&#123;action&#125;</span> private &quot;<span class="subst">$&#123;key&#125;</span>&quot; property`</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> target = &#123; <span class="attr">_prop</span>: <span class="string">&#x27;foo&#x27;</span> &#125;;</span><br><span class="line"><span class="keyword">var</span> proxy = <span class="keyword">new</span> <span class="title class_">Proxy</span>(target, handler);</span><br><span class="line"><span class="keyword">delete</span> proxy.<span class="property">_prop</span></span><br><span class="line"><span class="comment">// Error: Invalid attempt to delete private &quot;_prop&quot; property</span></span><br></pre></td></tr></table></figure><p>上面代码中，<code>deleteProperty</code> 方法拦截了 <code>delete</code> 操作符，删除第一个字符为下划线的属性会报错。</p><p>注意，目标对象自身的不可配置（<code>configurable</code>）的属性，不能被 <code>deleteProperty</code> 方法删除，否则报错。</p><h4 id="2-7-defineProperty"><a href="#2-7-defineProperty" class="headerlink" title="2.7 defineProperty()"></a>2.7 defineProperty()</h4><p><code>defineProperty</code> 方法拦截了 <code>Object.defineProperty</code> 操作。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> handler = &#123;</span><br><span class="line">  defineProperty (target, key, descriptor) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> target = &#123;&#125;;</span><br><span class="line"><span class="keyword">var</span> proxy = <span class="keyword">new</span> <span class="title class_">Proxy</span>(target, handler);</span><br><span class="line">proxy.<span class="property">foo</span> = <span class="string">&#x27;bar&#x27;</span></span><br><span class="line"><span class="comment">// TypeError: proxy defineProperty handler returned false for property &#x27;&quot;foo&quot;&#x27;</span></span><br></pre></td></tr></table></figure><p>上面代码中，<code>defineProperty</code> 方法返回 <code>false</code>，导致添加新属性会抛出错误。</p><p>注意，如果目标对象不可扩展（<code>extensible</code>），则 <code>defineProperty</code> 不能增加目标对象上不存在的属性，否则会报错。另外，如果目标对象的某个属性不可写（<code>writable</code>）或不可配置（<code>configurable</code>），则 <code>defineProperty</code> 方法不得改变这两个设置。</p><h4 id="2-8-getOwnPropertyDescriptor"><a href="#2-8-getOwnPropertyDescriptor" class="headerlink" title="2.8 getOwnPropertyDescriptor()"></a>2.8 getOwnPropertyDescriptor()</h4><p><code>getOwnPropertyDescriptor</code> 方法拦截 <code>Object.getOwnPropertyDescriptor()</code>，返回一个属性描述对象或者 <code>undefined</code>。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> handler = &#123;</span><br><span class="line">  getOwnPropertyDescriptor (target, key) &#123;</span><br><span class="line">    <span class="keyword">if</span> (key[<span class="number">0</span>] === <span class="string">&#x27;_&#x27;</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Object</span>.<span class="title function_">getOwnPropertyDescriptor</span>(target, key);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> target = &#123; <span class="attr">_foo</span>: <span class="string">&#x27;bar&#x27;</span>, <span class="attr">baz</span>: <span class="string">&#x27;tar&#x27;</span> &#125;;</span><br><span class="line"><span class="keyword">var</span> proxy = <span class="keyword">new</span> <span class="title class_">Proxy</span>(target, handler);</span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">getOwnPropertyDescriptor</span>(proxy, <span class="string">&#x27;wat&#x27;</span>)</span><br><span class="line"><span class="comment">// undefined</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">getOwnPropertyDescriptor</span>(proxy, <span class="string">&#x27;_foo&#x27;</span>)</span><br><span class="line"><span class="comment">// undefined</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">getOwnPropertyDescriptor</span>(proxy, <span class="string">&#x27;baz&#x27;</span>)</span><br><span class="line"><span class="comment">// &#123; value: &#x27;tar&#x27;, writable: true, enumerable: true, configurable: true &#125;</span></span><br></pre></td></tr></table></figure><p>上面代码中，<code>handler.getOwnPropertyDescriptor</code> 方法对于第一个字符为下划线的属性名会返回 <code>undefined</code>。</p><h4 id="2-9-getPrototypeOf"><a href="#2-9-getPrototypeOf" class="headerlink" title="2.9 getPrototypeOf()"></a>2.9 getPrototypeOf()</h4><p><code>getPrototypeOf</code> 方法主要用来拦截获取对象原型。具体来说，拦截下面这些操作。</p><ul><li><ul><li><code>Object.prototype.__proto__</code></li></ul></li><li><ul><li><code>Object.prototype.isPrototypeOf()</code></li></ul></li><li><ul><li><code>Object.getPrototypeOf()</code></li></ul></li><li><ul><li><code>Reflect.getPrototypeOf()</code></li></ul></li><li><ul><li><code>instanceof </code></li></ul></li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> proto = &#123;&#125;;</span><br><span class="line"><span class="keyword">var</span> p = <span class="keyword">new</span> <span class="title class_">Proxy</span>(&#123;&#125;, &#123;</span><br><span class="line">  <span class="title function_">getPrototypeOf</span>(<span class="params">target</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> proto;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">getPrototypeOf</span>(p) === proto <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>上面代码中，<code>getPrototypeOf</code> 方法拦截 <code>Object.getPrototypeOf()</code>，返回 <code>proto</code> 对象。</p><p>注意，<code>getPrototypeOf</code> 方法的返回值必须是对象或者 <code>null</code>，否则报错。另外，如果目标对象不可扩展（<code>extensible</code>）， <code>getPrototypeOf</code> 方法必须返回目标对象的原型对象。</p><h4 id="2-10-isExtensible"><a href="#2-10-isExtensible" class="headerlink" title="2.10 isExtensible()"></a>2.10 isExtensible()</h4><p><code>isExtensible</code> 方法拦截 <code>Object.isExtensible</code> 操作。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> p = <span class="keyword">new</span> <span class="title class_">Proxy</span>(&#123;&#125;, &#123;</span><br><span class="line">  <span class="attr">isExtensible</span>: <span class="keyword">function</span>(<span class="params">target</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;called&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">isExtensible</span>(p)</span><br><span class="line"><span class="comment">// &quot;called&quot;</span></span><br><span class="line"><span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>上面代码设置了 <code>isExtensible</code> 方法，在调用 <code>Object.isExtensible</code> 时会输出 <code>called</code>。</p><p>注意，该方法只能返回布尔值，否则返回值会被自动转为布尔值。</p><p>这个方法有一个强限制，它的返回值必须与目标对象的 <code>isExtensible</code> 属性保持一致，否则就会抛出错误。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Object</span>.<span class="title function_">isExtensible</span>(proxy) === <span class="title class_">Object</span>.<span class="title function_">isExtensible</span>(target)</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> p = <span class="keyword">new</span> <span class="title class_">Proxy</span>(&#123;&#125;, &#123;</span><br><span class="line">  <span class="attr">isExtensible</span>: <span class="keyword">function</span>(<span class="params">target</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">isExtensible</span>(p) <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure><h4 id="2-11-ownKeys"><a href="#2-11-ownKeys" class="headerlink" title="2.11 ownKeys()"></a>2.11 ownKeys()</h4><p><code>ownKeys</code> 方法用来拦截对象自身属性的读取操作。具体来说，拦截以下操作。</p><ul><li><ul><li><code>Object.getOwnPropertyNames()</code></li></ul></li><li><ul><li><code>Object.getOwnPropertySymbols()</code></li></ul></li><li><ul><li><code>Object.keys()</code></li></ul></li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> target = &#123;</span><br><span class="line">  <span class="attr">a</span>: <span class="number">1</span>,</span><br><span class="line">  <span class="attr">b</span>: <span class="number">2</span>,</span><br><span class="line">  <span class="attr">c</span>: <span class="number">3</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> handler = &#123;</span><br><span class="line">  <span class="title function_">ownKeys</span>(<span class="params">target</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> [<span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> proxy = <span class="keyword">new</span> <span class="title class_">Proxy</span>(target, handler);</span><br><span class="line"></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">keys</span>(proxy)</span><br><span class="line"><span class="comment">// [ &#x27;a&#x27; ]</span></span><br></pre></td></tr></table></figure><p>上面代码拦截了对于 <code>target</code> 对象的 <code>Object.keys()</code> 操作，只返回 <code>a、b、c</code> 三个属性之中的 <code>a</code> 属性。</p><p>注意，使用 <code>Object.keys</code> 方法时，有三类属性会被 <code>ownKeys</code> 方法自动过滤，不会返回。</p><ul><li><ul><li>目标对象上不存在的属性</li></ul></li><li><ul><li>属性名为 Symbol 值</li></ul></li><li><ul><li>不可遍历（ <code>enumerable</code> ）的属性</li></ul></li></ul><p><code>ownKeys</code> 方法还可以拦截 <code>Object.getOwnPropertyNames()</code>。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> p = <span class="keyword">new</span> <span class="title class_">Proxy</span>(&#123;&#125;, &#123;</span><br><span class="line">  <span class="attr">ownKeys</span>: <span class="keyword">function</span>(<span class="params">target</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">getOwnPropertyNames</span>(p)</span><br><span class="line"><span class="comment">// [ &#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27; ]</span></span><br></pre></td></tr></table></figure><p><code>ownKeys</code> 方法返回的数组成员，只能是字符串或 Symbol 值。如果有其他类型的值，或者返回的根本不是数组，就会报错。</p><h4 id="2-12-preventExtensions"><a href="#2-12-preventExtensions" class="headerlink" title="2.12 preventExtensions()"></a>2.12 preventExtensions()</h4><p><code>preventExtensions</code> 方法拦截 <code>Object.preventExtensions()</code>。该方法必须返回一个布尔值，否则会被自动转为布尔值。</p><p>这个方法有一个限制，只有目标对象不可扩展时（即 <code>Object.isExtensible(proxy)</code> 为 <code>false</code> ），<code>proxy.preventExtensions</code> 才能返回 <code>true</code>，否则会报错。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> p = <span class="keyword">new</span> <span class="title class_">Proxy</span>(&#123;&#125;, &#123;</span><br><span class="line">  <span class="attr">preventExtensions</span>: <span class="keyword">function</span>(<span class="params">target</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">preventExtensions</span>(p) <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure><p>上面代码中，<code>proxy.preventExtensions</code> 方法返回 <code>true</code>，但这时 <code>Object.isExtensible(proxy)</code> 会返回 <code>true</code>，因此报错。</p><p>为了防止出现这个问题，通常要在 <code>proxy.preventExtensions</code> 方法里面，调用一次 <code>Object.preventExtensions</code>。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> p = <span class="keyword">new</span> <span class="title class_">Proxy</span>(&#123;&#125;, &#123;</span><br><span class="line">  <span class="attr">preventExtensions</span>: <span class="keyword">function</span>(<span class="params">target</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;called&#x27;</span>);</span><br><span class="line">    <span class="title class_">Object</span>.<span class="title function_">preventExtensions</span>(target);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">preventExtensions</span>(p)</span><br><span class="line"><span class="comment">// &quot;called&quot;</span></span><br><span class="line"><span class="comment">// true</span></span><br></pre></td></tr></table></figure><h4 id="2-13-setPrototypeOf"><a href="#2-13-setPrototypeOf" class="headerlink" title="2.13 setPrototypeOf()"></a>2.13 setPrototypeOf()</h4><p><code>setPrototypeOf</code> 方法主要用来拦截 <code>Object.setPrototypeOf</code> 方法。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> handler = &#123;</span><br><span class="line">  setPrototypeOf (target, proto) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;Changing the prototype is forbidden&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> proto = &#123;&#125;;</span><br><span class="line"><span class="keyword">var</span> target = <span class="keyword">function</span> (<span class="params"></span>) &#123;&#125;;</span><br><span class="line"><span class="keyword">var</span> proxy = <span class="keyword">new</span> <span class="title class_">Proxy</span>(target, handler);</span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">setPrototypeOf</span>(proxy, proto);</span><br><span class="line"><span class="comment">// Error: Changing the prototype is forbidden</span></span><br></pre></td></tr></table></figure><p>上面代码中，只要修改 <code>target</code> 的原型对象，就会报错。</p><p>注意，该方法只能返回布尔值，否则会被自动转为布尔值。另外，如果目标对象不可扩展（ <code>extensible</code> ），<code>setPrototypeOf</code> 方法不得改变目标对象的原型。</p><h3 id="3-Proxy-revocable"><a href="#3-Proxy-revocable" class="headerlink" title="3. Proxy.revocable()"></a>3. Proxy.revocable()</h3><p><code>Proxy.revocable</code> 方法返回一个可取消的 Proxy 实例。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> target = &#123;&#125;;</span><br><span class="line"><span class="keyword">let</span> handler = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> &#123;proxy, revoke&#125; = <span class="title class_">Proxy</span>.<span class="title function_">revocable</span>(target, handler);</span><br><span class="line"></span><br><span class="line">proxy.<span class="property">foo</span> = <span class="number">123</span>;</span><br><span class="line">proxy.<span class="property">foo</span> <span class="comment">// 123</span></span><br><span class="line"></span><br><span class="line"><span class="title function_">revoke</span>();</span><br><span class="line">proxy.<span class="property">foo</span> <span class="comment">// TypeError: Revoked</span></span><br></pre></td></tr></table></figure><p><code>Proxy.revocable</code> 方法返回一个对象，该对象的 <code>proxy</code> 属性是 <code>Proxy</code> 实例，<code>revoke</code> 属性是一个函数，可以取消 <code>Proxy</code> 实例。上面代码中，当执行 <code>revoke</code> 函数之后，再访问 <code>Proxy</code> 实例，就会抛出一个错误。</p><p><code>Proxy.revocable</code> 的一个使用场景是，目标对象不允许直接访问，必须通过代理访问，一旦访问结束，就收回代理权，不允许再次访问。</p><h3 id="4-this-问题"><a href="#4-this-问题" class="headerlink" title="4. this 问题"></a>4. this 问题</h3><p>虽然 Proxy 可以代理针对目标对象的访问，但它不是目标对象的透明代理，即不做任何拦截的情况下，也无法保证与目标对象的行为一致。主要原因就是在 Proxy 代理的情况下，目标对象内部的 <code>this</code> 关键字会指向 Proxy 代理。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> target = &#123;</span><br><span class="line">  <span class="attr">m</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span> === proxy);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> handler = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> proxy = <span class="keyword">new</span> <span class="title class_">Proxy</span>(target, handler);</span><br><span class="line"></span><br><span class="line">target.<span class="title function_">m</span>() <span class="comment">// false</span></span><br><span class="line">proxy.<span class="title function_">m</span>()  <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>上面代码中，一旦 <code>proxy</code> 代理 <code>target.m</code>，后者内部的 <code>this</code> 就是指向 <code>proxy</code>，而不是 <code>target</code>。</p><p>此外，有些原生对象的内部属性，只有通过正确的 <code>this</code> 才能拿到，所以 Proxy 也无法代理这些原生对象的属性。</p>]]></content>
      
      
      <categories>
          
          <category> ES6 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Proxy </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ES6 简介</title>
      <link href="/2017/07/31/ES6/ES6%20%E7%AE%80%E4%BB%8B/"/>
      <url>/2017/07/31/ES6/ES6%20%E7%AE%80%E4%BB%8B/</url>
      
        <content type="html"><![CDATA[<p>ECMAScript 6.0（以下简称 ES6 ）是 JavaScript 语言的下一代标准，已经在 2015 年 6 月正式发布了。它的目标，是使得 JavaScript 语言可以用来编写复杂的大型应用程序，成为企业级开发语言。</p><h3 id="1-ECMAScript-和-JavaScript-的关系"><a href="#1-ECMAScript-和-JavaScript-的关系" class="headerlink" title="1. ECMAScript 和 JavaScript 的关系"></a>1. ECMAScript 和 JavaScript 的关系</h3><p>该标准从一开始就是针对 JavaScript 语言制定的，但是之所以不叫 JavaScript，有两个原因。一是商标，Java 是 Sun 公司的商标，根据授权协议，只有 Netscape 公司可以合法地使用 JavaScript 这个名字，且 JavaScript 本身也已经被 Netscape 公司注册为商标。二是想体现这门语言的制定者是 ECMA，不是 Netscape，这样有利于保证这门语言的开放性和中立性。</p><p>因此，ECMAScript 和 JavaScript 的关系是，前者是后者的规格，后者是前者的一种实现（另外的 ECMAScript 方言还有 Jscript 和 ActionScript）。</p><h3 id="2-声明变量的六种方法"><a href="#2-声明变量的六种方法" class="headerlink" title="2. 声明变量的六种方法"></a>2. 声明变量的六种方法</h3><ol><li>var</li><li>function</li><li>let</li><li>const</li><li>import</li><li>class</li></ol><h3 id="3-正则特殊字符说明"><a href="#3-正则特殊字符说明" class="headerlink" title="3. 正则特殊字符说明"></a>3. 正则特殊字符说明</h3><p>1、 <code>.</code> 字符：除了换行符以外的任意单个字符</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> s = <span class="string">&#x27;𠮷&#x27;</span>;</span><br><span class="line"><span class="regexp">/^.$/</span>.<span class="title function_">test</span>(s) <span class="comment">// false</span></span><br><span class="line">/^.<span class="property">$</span>/u.<span class="title function_">test</span>(s) <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>2、 <code>u</code> 修饰符：含义为 <strong>Unicode模式</strong>, 用来正确处理大于 \uFFFF 的 Unicode 字符。也就是说，会正确处理四个字节的 UTF-16 编码。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">/^\uD83D/u.<span class="title function_">test</span>(<span class="string">&#x27;\uD83D\uDC2A&#x27;</span>) <span class="comment">// false</span></span><br><span class="line">/^\uD83D/.<span class="title function_">test</span>(<span class="string">&#x27;\uD83D\uDC2A&#x27;</span>) <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>3、 <code>Unicode</code> 字符：ES6 新增了使用大括号表示 Unicode 字符，这种表示法在正则表达式中必须加上  <code>u</code> 修饰符，才能识别当中的大括号，否则会被解读为量词。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">/\u&#123;<span class="number">61</span>&#125;/.<span class="title function_">test</span>(<span class="string">&#x27;a&#x27;</span>) <span class="comment">// false</span></span><br><span class="line">/\u&#123;<span class="number">61</span>&#125;/u.<span class="title function_">test</span>(<span class="string">&#x27;a&#x27;</span>) <span class="comment">// true</span></span><br><span class="line">/\u&#123;20BB7&#125;/u.<span class="title function_">test</span>(<span class="string">&#x27;𠮷&#x27;</span>) <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>4、<code>量词</code>：使用 <code>u</code> 修饰符后，所有量词都会正确识别码点大于 0xFFFF 的 Unicode 字符。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">/a&#123;<span class="number">2</span>&#125;/.<span class="title function_">test</span>(<span class="string">&#x27;aa&#x27;</span>) <span class="comment">// true</span></span><br><span class="line">/a&#123;<span class="number">2</span>&#125;/u.<span class="title function_">test</span>(<span class="string">&#x27;aa&#x27;</span>) <span class="comment">// true</span></span><br><span class="line">/𠮷&#123;<span class="number">2</span>&#125;/.<span class="title function_">test</span>(<span class="string">&#x27;𠮷𠮷&#x27;</span>) <span class="comment">// false</span></span><br><span class="line">/𠮷&#123;<span class="number">2</span>&#125;/u.<span class="title function_">test</span>(<span class="string">&#x27;𠮷𠮷&#x27;</span>) <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>5、<code>预定义模式</code>：<code>u</code> 修饰符也影响到预定义模式，能否正确识别码点大于 0xFFFF 的 Unicode 字符。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">/^\S$/.<span class="title function_">test</span>(<span class="string">&#x27;𠮷&#x27;</span>) <span class="comment">// false</span></span><br><span class="line">/^\S$/u.<span class="title function_">test</span>(<span class="string">&#x27;𠮷&#x27;</span>) <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p><em>说明：上面代码的 <code>\S</code> 是预定义模式，匹配所有不是空格的字符。只有加了 <code>u</code> 修饰符，它才能正确匹配码点大于 0xFFFF 的 Unicode 字符。</em></p><p>6、<code>i</code> 修饰符：有些 Unicode 字符的编码不同，但是字型很相近，比如，\u004B 与 \u212A 都是大写的 K。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">/[a-z]/i.<span class="title function_">test</span>(<span class="string">&#x27;\u212A&#x27;</span>) <span class="comment">// false</span></span><br><span class="line">/[a-z]/iu.<span class="title function_">test</span>(<span class="string">&#x27;\u212A&#x27;</span>) <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p><em>上面代码中，不加 <code>u</code> 修饰符，就无法识别非规范的 <code>K</code> 字符</em></p><p>7、<code>y</code> 修饰符：除了 <code>u</code> 修饰符，ES6 还为正则表达式添加了 <code>y</code> 修饰符，叫做「粘连」（ sticky ）修饰符。<code>y</code> 修饰符的作用与g修饰符类似，也是全局匹配，后一次匹配都从上一次匹配成功的下一个位置开始。不同之处在于，<code>g</code> 修饰符只要剩余位置中存在匹配就可，而 <code>y</code> 修饰符确保匹配必须从剩余的第一个位置开始，这也就是 “粘连” 的涵义。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> s = <span class="string">&#x27;aaa_aa_a&#x27;</span>;</span><br><span class="line"><span class="keyword">var</span> r1 = <span class="regexp">/a+/g</span>;</span><br><span class="line"><span class="keyword">var</span> r2 = <span class="regexp">/a+/y</span>;</span><br><span class="line"></span><br><span class="line">r1.<span class="title function_">exec</span>(s) <span class="comment">// [&quot;aaa&quot;]</span></span><br><span class="line">r2.<span class="title function_">exec</span>(s) <span class="comment">// [&quot;aaa&quot;]</span></span><br><span class="line"></span><br><span class="line">r1.<span class="title function_">exec</span>(s) <span class="comment">// [&quot;aa&quot;]</span></span><br><span class="line">r2.<span class="title function_">exec</span>(s) <span class="comment">// null</span></span><br></pre></td></tr></table></figure><p><em>上面代码有两个正则表达式，一个使用 <code>g</code> 修饰符，另一个使用 <code>y</code> 修饰符。这两个正则表达式各执行了两次，第一次执行的时候，两者行为相同，剩余字符串都是 <code>_aa_a</code> 。由于 <code>g</code> 修饰没有位置要求，所以第二次执行会返回结果，而 <code>y</code> 修饰符要求匹配必须从头部开始，所以返回 <code>null</code>。</em></p><p>如果改一下正则表达式，保证每次都能头部匹配，<code>y</code> 修饰符就会返回结果了。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> s = <span class="string">&#x27;aaa_aa_a&#x27;</span>;</span><br><span class="line"><span class="keyword">var</span> r = <span class="regexp">/a+_/y</span>;</span><br><span class="line"></span><br><span class="line">r.<span class="title function_">exec</span>(s) <span class="comment">// [&quot;aaa_&quot;]</span></span><br><span class="line">r.<span class="title function_">exec</span>(s) <span class="comment">// [&quot;aa_&quot;]</span></span><br></pre></td></tr></table></figure><p><em>上面代码每次匹配，都是从剩余字符串的头部开始。</em></p><p>使用 <code>lastIndex</code> 属性，可以更好地说明 <code>y</code> 修饰符。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="variable constant_">REGEX</span> = <span class="regexp">/a/g</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 指定从2号位置（y）开始匹配</span></span><br><span class="line"><span class="variable constant_">REGEX</span>.<span class="property">lastIndex</span> = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 匹配成功</span></span><br><span class="line"><span class="keyword">const</span> match = <span class="variable constant_">REGEX</span>.<span class="title function_">exec</span>(<span class="string">&#x27;xaya&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在3号位置匹配成功</span></span><br><span class="line">match.<span class="property">index</span> <span class="comment">// 3</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 下一次匹配从4号位开始</span></span><br><span class="line"><span class="variable constant_">REGEX</span>.<span class="property">lastIndex</span> <span class="comment">// 4</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 4号位开始匹配失败</span></span><br><span class="line"><span class="variable constant_">REGEX</span>.<span class="title function_">exec</span>(<span class="string">&#x27;xaxa&#x27;</span>) <span class="comment">// null</span></span><br></pre></td></tr></table></figure><p>上面代码中，<code>lastIndex</code> 属性指定每次搜索的开始位置，<code>g</code> 修饰符从这个位置开始向后搜索，直到发现匹配为止。</p><p><code>y</code> 修饰符同样遵守 <code>lastIndex</code> 属性，但是要求必须在 <code>lastIndex</code> 指定的位置发现匹配。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="variable constant_">REGEX</span> = <span class="regexp">/a/y</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 指定从2号位置开始匹配</span></span><br><span class="line"><span class="variable constant_">REGEX</span>.<span class="property">lastIndex</span> = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不是粘连，匹配失败</span></span><br><span class="line"><span class="variable constant_">REGEX</span>.<span class="title function_">exec</span>(<span class="string">&#x27;xaya&#x27;</span>) <span class="comment">// null</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 指定从3号位置开始匹配</span></span><br><span class="line"><span class="variable constant_">REGEX</span>.<span class="property">lastIndex</span> = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3号位置是粘连，匹配成功</span></span><br><span class="line"><span class="keyword">const</span> match = <span class="variable constant_">REGEX</span>.<span class="title function_">exec</span>(<span class="string">&#x27;xaxa&#x27;</span>);</span><br><span class="line">match.<span class="property">index</span> <span class="comment">// 3</span></span><br><span class="line"><span class="variable constant_">REGEX</span>.<span class="property">lastIndex</span> <span class="comment">// 4</span></span><br></pre></td></tr></table></figure><p>实际上，<code>y</code> 修饰符号隐含了头部匹配的标志 <code>^</code>。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">/b/y.<span class="title function_">exec</span>(<span class="string">&#x27;aba&#x27;</span>)</span><br><span class="line"><span class="comment">// null</span></span><br></pre></td></tr></table></figure><p><em>上面代码由于不能保证头部匹配，所以返回 <code>null</code>。<code>y</code> 修饰符的设计本意，就是让头部匹配的标志 <code>^</code> 在全局匹配中都有效。</em></p><p>在 <code>split</code> 方法中使用 <code>y</code> 修饰符，原字符串必须以分隔符开头。这也意味着，只要匹配成功，数组的第一个成员肯定是空字符串。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 没有找到匹配</span></span><br><span class="line"><span class="string">&#x27;x##&#x27;</span>.<span class="title function_">split</span>(<span class="regexp">/#/y</span>)</span><br><span class="line"><span class="comment">// [ &#x27;x##&#x27; ]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 找到两个匹配</span></span><br><span class="line"><span class="string">&#x27;##x&#x27;</span>.<span class="title function_">split</span>(<span class="regexp">/#/y</span>)</span><br><span class="line"><span class="comment">// [ &#x27;&#x27;, &#x27;&#x27;, &#x27;x&#x27; ]</span></span><br></pre></td></tr></table></figure><p>后续的分隔符只有紧跟前面的分隔符，才会被识别。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27;#x#&#x27;</span>.<span class="title function_">split</span>(<span class="regexp">/#/y</span>)</span><br><span class="line"><span class="comment">// [ &#x27;&#x27;, &#x27;x#&#x27; ]</span></span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;##&#x27;</span>.<span class="title function_">split</span>(<span class="regexp">/#/y</span>)</span><br><span class="line"><span class="comment">// [ &#x27;&#x27;, &#x27;&#x27;, &#x27;&#x27; ]</span></span><br></pre></td></tr></table></figure><p>下面是字符串对象的 <code>replace</code> 方法的例子。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="variable constant_">REGEX</span> = <span class="regexp">/a/gy</span>;</span><br><span class="line"><span class="string">&#x27;aaxa&#x27;</span>.<span class="title function_">replace</span>(<span class="variable constant_">REGEX</span>, <span class="string">&#x27;-&#x27;</span>) <span class="comment">// &#x27;--xa&#x27;</span></span><br></pre></td></tr></table></figure><p><em>上面代码中，最后一个 <code>a</code> 因为不是出现在下一次匹配的头部，所以不会被替换。</em></p><p>单单一个 <code>y</code> 修饰符对 <code>match</code> 方法，只能返回第一个匹配，必须与 <code>g</code> 修饰符联用，才能返回所有匹配。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27;a1a2a3&#x27;</span>.<span class="title function_">match</span>(<span class="regexp">/a\d/y</span>) <span class="comment">// [&quot;a1&quot;]</span></span><br><span class="line"><span class="string">&#x27;a1a2a3&#x27;</span>.<span class="title function_">match</span>(<span class="regexp">/a\d/gy</span>) <span class="comment">// [&quot;a1&quot;, &quot;a2&quot;, &quot;a3&quot;]</span></span><br></pre></td></tr></table></figure><p><code>y</code> 修饰符的一个应用，是从字符串提取 token（词元），<code>y</code> 修饰符确保了匹配之间不会有漏掉的字符。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="variable constant_">TOKEN_Y</span> = <span class="regexp">/\s*(\+|[0-9]+)\s*/y</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="variable constant_">TOKEN_G</span>  = <span class="regexp">/\s*(\+|[0-9]+)\s*/g</span>;</span><br><span class="line"></span><br><span class="line"><span class="title function_">tokenize</span>(<span class="variable constant_">TOKEN_Y</span>, <span class="string">&#x27;3 + 4&#x27;</span>)</span><br><span class="line"><span class="comment">// [ &#x27;3&#x27;, &#x27;+&#x27;, &#x27;4&#x27; ]</span></span><br><span class="line"><span class="title function_">tokenize</span>(<span class="variable constant_">TOKEN_G</span>, <span class="string">&#x27;3 + 4&#x27;</span>)</span><br><span class="line"><span class="comment">// [ &#x27;3&#x27;, &#x27;+&#x27;, &#x27;4&#x27; ]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">tokenize</span>(<span class="params">TOKEN_REGEX, str</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> result = [];</span><br><span class="line">  <span class="keyword">let</span> match;</span><br><span class="line">  <span class="keyword">while</span> (match = <span class="variable constant_">TOKEN_REGEX</span>.<span class="title function_">exec</span>(str)) &#123;</span><br><span class="line">    result.<span class="title function_">push</span>(match[<span class="number">1</span>]);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><em>上面代码中，如果字符串里面没有非法字符，<code>y</code> 修饰符与 <code>g</code> 修饰符的提取结果是一样的。但是，一旦出现非法字符，两者的行为就不一样了。</em></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title function_">tokenize</span>(<span class="variable constant_">TOKEN_Y</span>, <span class="string">&#x27;3x + 4&#x27;</span>)</span><br><span class="line"><span class="comment">// [ &#x27;3&#x27; ]</span></span><br><span class="line"><span class="title function_">tokenize</span>(<span class="variable constant_">TOKEN_G</span>, <span class="string">&#x27;3x + 4&#x27;</span>)</span><br><span class="line"><span class="comment">// [ &#x27;3&#x27;, &#x27;+&#x27;, &#x27;4&#x27; ]</span></span><br></pre></td></tr></table></figure><p><em>上面代码中，<code>g</code> 修饰符会忽略非法字符，而 <code>y</code> 修饰符不会，这样就很容易发现错误。</em></p><p>8、<code>sticky</code> 属性：与 <code>y</code> 修饰符相匹配，ES6 的正则对象多了 <code>sticky</code> 属性，表示是否设置了 <code>y</code> 修饰符。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> r = <span class="regexp">/hello\d/y</span>;</span><br><span class="line">r.<span class="property">sticky</span> <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>9、<code>flags</code> 属性：ES6 为正则表达式新增了 <code>flags</code> 属性，会返回正则表达式的修饰符。 </p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ES5 的 source 属性</span></span><br><span class="line"><span class="comment">// 返回正则表达式的正文</span></span><br><span class="line">/abc/ig.<span class="property">source</span></span><br><span class="line"><span class="comment">// &quot;abc&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ES6 的 flags 属性</span></span><br><span class="line"><span class="comment">// 返回正则表达式的修饰符</span></span><br><span class="line">/abc/ig.<span class="property">flags</span></span><br><span class="line"><span class="comment">// &#x27;gi&#x27;</span></span><br></pre></td></tr></table></figure><p>10、<code>s</code> 修饰符：dotAll 模式</p><p>正则表达式中，点（ <code>.</code> ）是一个特殊字符，代表任意的单个字符，但是行终止符（line terminator character）除外。</p><p>以下四个字符属于 <code>行终止符</code>。</p><ol><li>U+000A 换行符（\n）</li><li>U+000D 回车符（\r）</li><li>U+2028 行分隔符（line separator）</li><li>U+2029 段分隔符（paragraph separator）</li></ol><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">/foo.<span class="property">bar</span>/.<span class="title function_">test</span>(<span class="string">&#x27;foo\nbar&#x27;</span>)</span><br><span class="line"><span class="comment">// false</span></span><br></pre></td></tr></table></figure><p><em>上面代码中，因为 <code>.</code> 不匹配 <code>\n</code>，所以正则表达式返回 <code>false</code>。</em></p><p>所以现在有一个提案，引入 <code>/s</code> 修饰符，使得 <code>.</code> 可以匹配任意单个字符。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">/foo.<span class="property">bar</span>/s.<span class="title function_">test</span>(<span class="string">&#x27;foo\nbar&#x27;</span>) <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>这被称为 <code>dotAll</code> 模式，即点（ <code>dot</code> ）代表一切字符。所以，正则表达式还引入了一个 <code>dotAll</code> 属性，返回一个布尔值，表示该正则表达式是否处在 <code>dotAll</code> 模式。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> re = <span class="regexp">/foo.bar/</span>s;</span><br><span class="line"><span class="comment">// 另一种写法</span></span><br><span class="line"><span class="comment">// const re = new RegExp(&#x27;foo.bar&#x27;, &#x27;s&#x27;);</span></span><br><span class="line"></span><br><span class="line">re.<span class="title function_">test</span>(<span class="string">&#x27;foo\nbar&#x27;</span>) <span class="comment">// true</span></span><br><span class="line">re.<span class="property">dotAll</span> <span class="comment">// true</span></span><br><span class="line">re.<span class="property">flags</span> <span class="comment">// &#x27;s&#x27;</span></span><br></pre></td></tr></table></figure><p><code>/s</code> 修饰符和多行修饰符 <code>/m</code> 不冲突，两者一起使用的情况下，.匹配所有字符，而 <code>^</code> 和 <code>$</code> 匹配每一行的行首和行尾。</p>]]></content>
      
      
      <categories>
          
          <category> ES6 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ES6 </tag>
            
            <tag> 简介 </tag>
            
            <tag> 基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>访问者模式</title>
      <link href="/2017/03/02/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BF%E9%97%AE%E8%80%85%E6%A8%A1%E5%BC%8F/"/>
      <url>/2017/03/02/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BF%E9%97%AE%E8%80%85%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<p><code>访问者模式（Visitor Pattern）</code>：提供一个作用于某对象结构中的各元素的操作表示，它使得可以在不改变各元素的类的前提下定义作用于这些元素的新操作。访问者模式是一种 <strong>对象行为型模式</strong>。</p><h3 id="1-优点"><a href="#1-优点" class="headerlink" title="1. 优点"></a>1. 优点</h3><ol><li>增加新的访问操作很方便。使用访问者模式，增加新的访问操作就意味着增加一个新的具体访问者类，实现简单，无须修改源代码，符合开闭原则；</li><li>将有关元素对象的访问行为集中到一个访问者对象中，而不是分散在一个个的元素类中。类的职责更加清晰，有利于对象结构中元素对象的复用，相同的对象结构可以供多个不同的访问者访问；</li><li>让用户能够在不修改现有元素类层次结构的情况下，定义作用于该层次结构的操作；</li></ol><h3 id="2-缺点"><a href="#2-缺点" class="headerlink" title="2. 缺点"></a>2. 缺点</h3><ol><li>增加新的元素类很困难。在访问者模式中，每增加一个新的元素类都意味着要在抽象访问者角色中增加一个新的抽象操作，并在每一个具体访问者类中增加相应的具体操作，这违背了开闭原则的要求；</li><li>破坏封装。访问者模式要求访问者对象访问并调用每一个元素对象的操作，这意味着元素对象有时候必须暴露一些自己的内部操作和内部状态，否则无法提供访问者访问；</li></ol>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 行为型模式 </tag>
            
            <tag> 访问者 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>模板方法模式</title>
      <link href="/2017/03/02/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F/"/>
      <url>/2017/03/02/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<p><code>模板方法模式（Template Method Pattern）</code>：定义一个操作中算法的框架，而将一些步骤延迟到子类中，模板方法使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。模板方法是一种 <strong>行为型模式</strong>。</p><h3 id="1-优点"><a href="#1-优点" class="headerlink" title="1. 优点"></a>1. 优点</h3><ol><li>模板方法模式在父类中形式化地定义一个算法，而由它的子类来实现细节的处理，在子类实现详细的处理算法时并不会改变算法中步骤的执行次序；</li><li>模板方法模式是一种代码复用技术，它在类库设计中尤为重要，它提取了类库中的公共行为，将公共行为放在父类中，而通过其子类来实现不同的行为，它鼓励恰当使用继承来实现代码复用；</li><li>模板方法模式可实现一种反向控制结构，通过子类覆盖父类的钩子方法来决定某一特定步骤是否需要执行；</li><li>在模板方法模式中可以通过子类来覆盖父类的基本方法，不同的子类可以提供基本方法的不同实现，更换和增加新的子类很方便，符合单一职责原则和开闭原则；</li></ol><h3 id="2-缺点"><a href="#2-缺点" class="headerlink" title="2. 缺点"></a>2. 缺点</h3><ol><li>需要为每一个基本方法的不同实现提供一个子类，如果父类中可变的基本方法太多，将会导致类的个数增加，系统更加庞大，设计也更加抽象，此时，可结合桥接模式来进行设计；</li></ol>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 行为型模式 </tag>
            
            <tag> 模板方法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>策略模式</title>
      <link href="/2017/03/01/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/"/>
      <url>/2017/03/01/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<p><code>策略模式（Strategy Pattern）</code>：定义一系列算法类，将每一个算法封装起来，并让它们可以互相替换。策略模式让算法独立于使用它的客户而变化，也称为 <strong>政策模式（Policy）</strong>。策略模式是一种 <strong>对象行为型模式</strong>。</p><h3 id="1-优点"><a href="#1-优点" class="headerlink" title="1. 优点"></a>1. 优点</h3><ol><li>策略模式提供了对开闭原则的完美支持，用户可以再不修改原有系统的基础上选择算法或行为，也可以灵活地增加新的算法或行为；</li><li>策略模式提供了管理相关的算法族的办法。策略类的等级结构定义了一个算法或行为族，恰当使用继承可以把公共的代码移到抽象策略中，从而避免重复的代码；</li><li>策略模式提供了一种可以替换继承关系的办法。如果不使用策略模式，那么使用算法的环境类就可能会有一些子类，每一个子类提供一种不同的算法。但是，这样一来算法的使用就和算法本身混在一起，不符合单一职责原则，决定使用哪一种算法的逻辑和该算法本身混合在一起，从而不可能再独立演化；而且使用继承无法实现算法或行为在程序运行时的动态切换；</li><li>使用策略模式可以避免多重条件选择语句。多重条件选择语句不易维护，它把采取哪一种算法或行为的逻辑与算法或行为本身的实现逻辑混合在一起，将它们全部硬编码（Hard Coding）在一个庞大的多重条件选择语句中，比直接继承环境类的办法还要原始和落后；</li><li>策略模式提供了一种算法的复用机制，由于将算法单独提取出来封装在策略类中，因此不同的环境类可以方便地复用这些策略类；</li></ol><h3 id="2-缺点"><a href="#2-缺点" class="headerlink" title="2. 缺点"></a>2. 缺点</h3><ol><li>客户端必须知道所有的策略类，并自行决定使用哪一个策略类。这就意味着客户端必须理解这些算法的区别，以便适时选择恰当的算法。换言之，策略模式只适用于客户端知道所有的算法或行为的情况；</li><li>策略模式将造成系统产生很多具体策略类，任何细小的变化都将导致系统要增加一个新的具体策略类；</li><li>无法同时在客户端使用多个策略类，也就是说，在使用策略模式时，客户端每次只能使用一个策略类，不支持使用一个策略类完成部分功能后再使用另一个策略类来完成剩余功能的情况；</li></ol>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 行为型模式 </tag>
            
            <tag> 策略 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>状态模式</title>
      <link href="/2017/03/01/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E7%8A%B6%E6%80%81%E6%A8%A1%E5%BC%8F/"/>
      <url>/2017/03/01/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E7%8A%B6%E6%80%81%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<p><code>状态模式（State Pattern）</code>：允许一个对象在其内部状态改变时改变它的行为，对象看起来似乎修改了它的类。其别名为状态对象（Objects for States），装填模式是一种 <strong>对象行为型模式</strong>。</p><h3 id="1-优点"><a href="#1-优点" class="headerlink" title="1. 优点"></a>1. 优点</h3><ol><li>封装了状态的转换规则，在装填模式中可以将状态的转换代码封装在环境类或者具体状态类中，可以对状态转换代码进行集中管理，而不是分散在一个个业务方法中；</li><li>将所有与某个状态有关的行为放到一个类中，只需要注入一个不同的状态对象即可使环境对象拥有不同的行为；</li><li>允许状态转换逻辑与状态对象合成一体，而不是提供一个巨大的条件语句块，状态模式可以避免使用庞大的条件语句来将业务方法和状态转换代码交织在一起；</li><li>可以让多个环境对象共享一个状态对象，从而减少系统中对象的个数；</li></ol><h3 id="2-缺点"><a href="#2-缺点" class="headerlink" title="2. 缺点"></a>2. 缺点</h3><ol><li>状态模式的使用必然会增加系统中类和对象的个数，导致系统运行开销增大；</li><li>状态模式的程序结构与实现都较为复杂，如果使用不当将导致程序结构和代码的混乱，增加系统设计的难度；</li><li>状态模式对开闭原则的支持并不太好，增加新的状态类需要修改那些负责状态转换的源代码，否则无法转换到新的新增状态；而且修改某个状态类的行为也需要修改对应类的源代码；</li></ol>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 行为型模式 </tag>
            
            <tag> 状态 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>观察者模式</title>
      <link href="/2017/03/01/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/"/>
      <url>/2017/03/01/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<p><code>观察者模式（Observer Pattern）</code>：定义对象之间的一种一对多依赖关系，使得每当一个对象状态发生改变时，其相关依赖对象皆得到通知并被自动更新。观察者模式的别名包括发布-订阅（Publish&#x2F;Subscribe）模式、模型-视图（Model&#x2F;View）模式、源-监听器（Source&#x2F;Listener）模式或从属者（Dependents）模式。观察者模式是一种 <strong>对象行为型模式</strong>。</p><h3 id="1-优点"><a href="#1-优点" class="headerlink" title="1. 优点"></a>1. 优点</h3><ol><li>观察者模式可以实现表示层和数据逻辑层的分离，定义了稳定的消息更新传递机制，并抽象了更新接口，使得可以有各种各样不同的表示层充当具体观察者角色；</li><li>观察者模式在观察目标和观察者之间建立一个抽象的耦合。观察者目标只需要维持一个抽象观察者的集合，无须了解其具体观察者。由于观察目标和观察者没有紧密地耦合在一起，因此它们可以属于不同的抽象化层次；</li><li>观察者模式支持广播通信，观察目标会向所有已注册的观察者对象发送通知，简化了一对多系统设计的难度；</li><li>观察者模式满足开闭原则的要求，增加新的具体观察者无须修改原有系统代码，在具体观察者与观察目标之间不存在关联关系的情况下，增加新的观察目标也很方便；</li></ol><h3 id="2-缺点"><a href="#2-缺点" class="headerlink" title="2. 缺点"></a>2. 缺点</h3><ol><li>如果一个观察目标对象有很多直接和间接观察者，将所有的观察者都通知到会花费很多时间；</li><li>如果在观察者和观察目标之间存在循环依赖，观察目标会触发它们之间进行循环调用，可能导致系统崩溃；</li><li>观察者模式没有相应的机制让观察者知道所观察的目标对象是怎么发生变化的，而仅仅只是知道观察目标发生了变化；</li></ol>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 行为型模式 </tag>
            
            <tag> 观察者 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>备忘录模式</title>
      <link href="/2017/03/01/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%A4%87%E5%BF%98%E5%BD%95%E6%A8%A1%E5%BC%8F/"/>
      <url>/2017/03/01/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%A4%87%E5%BF%98%E5%BD%95%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<p><code>备忘录模式（Memento Pattern）</code>：在不破坏封装的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态，这样可以在以后将对象恢复到原先保存的状态。它是一种 <strong>对象行为型模式</strong>，其别名为 Token。</p><h3 id="1-优点"><a href="#1-优点" class="headerlink" title="1. 优点"></a>1. 优点</h3><ol><li>它提供了一种状态恢复的实现机制，使得用户可以方便地回到一个特定的历史步骤，当新的状态无效或者存在问题时，可以使用暂时存储起来的备忘录将状态复原；</li><li>备忘录实现了对信息的封装，一个备忘录对象是一种原发器对象状态的表示，不会被其他代码所改动。备忘录保存了原发器的状态，采用列表、堆栈等集合来存储备忘录对象可以实现多次撤销操作；</li></ol><h3 id="2-缺点"><a href="#2-缺点" class="headerlink" title="2. 缺点"></a>2. 缺点</h3><ol><li>资源消耗过大，如果需要保存的原发器类的成员变量太多，就不可避免地需要占用大量的存储空间，每保存一次对象的状态都需要消耗一定的系统资源；</li></ol>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 行为型模式 </tag>
            
            <tag> 备忘录 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>中介者模式</title>
      <link href="/2017/02/28/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E4%B8%AD%E4%BB%8B%E8%80%85%E6%A8%A1%E5%BC%8F/"/>
      <url>/2017/02/28/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E4%B8%AD%E4%BB%8B%E8%80%85%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<p><code>中介者模式（Mediator Pattern）</code>：用一个中介对象（中介者）来封装一系列的对象交互，中介者使各对象不需要显示地相互引用，从而使其耦合松散，而且可以独立地改变它们之间的交互。中介者模式又称为 <strong>调停者模式</strong>，它是一种 <strong>对象行为型模式</strong>。</p><h3 id="1-优点"><a href="#1-优点" class="headerlink" title="1. 优点"></a>1. 优点</h3><ol><li>中介者模式简化了对象之间的交互，它用中介者和同事的一对多交互代替了原来同事之间的多对多交互，一对多关系更容易理解、维护和扩展，将原本难以理解的网状结构转换成相对简单的星型结构；</li><li>中介者模式可将各同事对象解耦。中介者有利于各同事之间的松耦合，可以独立地改变和复用每一个同事和中介者，增加新的中介者和新的同事类都比较方便，更好地符合开闭原则；</li><li>可以减少大量同事子类生成，中介者将原本分布于多个对象之间的行为集中在一起，改变这些行为只需要生成新的中介者子类即可，这使得各个同事类可以被重用，无须对同事类进行扩展；</li></ol><h3 id="2-缺点"><a href="#2-缺点" class="headerlink" title="2. 缺点"></a>2. 缺点</h3><ol><li>在具体中介者类中包含了大量同事之间的交互细节，可能会导致具体中介者类非常复杂，使得系统难以维护</li></ol>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 中介者 </tag>
            
            <tag> 行为型模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>迭代器模式</title>
      <link href="/2017/02/27/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%BF%AD%E4%BB%A3%E5%99%A8%E6%A8%A1%E5%BC%8F/"/>
      <url>/2017/02/27/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%BF%AD%E4%BB%A3%E5%99%A8%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<p><code>迭代器模式（Iterator）</code>：提供一种方法来访问聚合对象，而不用暴露这个对象的内部表示，其别名为游标（Cursor）。迭代器模式是一种 <strong>对象行为型模式</strong>。</p><h3 id="1-优点"><a href="#1-优点" class="headerlink" title="1. 优点"></a>1. 优点</h3><ol><li>支持以不同的方式遍历一个聚合对象，在同一个聚合对象上可以定义多种遍历方式。在迭代器模式中只需要用一个不同的迭代器来替换原有迭代器即可改变遍历算法，也可以自己定义迭代器的子类以支持新的遍历方式；</li><li>迭代器简化了聚合类。由于引入了迭代器，在原有的聚合对象中不需要再自行提供数据遍历等方法，这样可以简化聚合类的设计；</li><li>在迭代器模式中，由于引入了抽象层，增加新的聚合类和迭代器类都很方便，无须修改原有代码，满足开闭原则的要求；</li></ol><h3 id="2-缺点"><a href="#2-缺点" class="headerlink" title="2. 缺点"></a>2. 缺点</h3><ol><li>由于迭代器模式将存储数据和遍历数据的职责分离，增加新的聚合类需要对应增加新的迭代器类，类的个数成对增加，这在一定程度上增加了系统的复杂性；</li><li>抽象迭代器的设计难度较大，需要充分考虑到系统将来的扩展，例如 JDK 内存迭代器 Iterator 就无法实现逆向遍历，如果需要实现逆向遍历，只能通过其子类 ListIterator 等来实现，而 ListIterator 迭代器无法用于操作 Serializable 类型的聚合对象。在自定义迭代器时，创建一个考虑全面的抽象迭代器并不是件很容易的事情；</li></ol>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 行为型模式 </tag>
            
            <tag> 迭代器 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>解释器模式</title>
      <link href="/2017/02/27/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%A7%A3%E9%87%8A%E5%99%A8%E6%A8%A1%E5%BC%8F/"/>
      <url>/2017/02/27/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%A7%A3%E9%87%8A%E5%99%A8%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<p><code>解释器模式（Interpreter Pattern）</code>：定义一个语言的文法，并且建立一个解释器来解释该语言中的句子，这里的「语言」是指使用规定格式和语法的代码。解释器模式是一种 <strong>类行为型模式</strong>。</p><h3 id="1-优点"><a href="#1-优点" class="headerlink" title="1. 优点"></a>1. 优点</h3><ol><li>易于改变和扩展文法。由于在解释器模式中使用类来表示语言的文法规则，因此可以通过继承等机制来改变或扩展文法；</li><li>每一条文法规则都可以表示为一个类，因此可以方便地实现一个简单的语言；</li><li>实现文法较为容易。在抽象语法树中每一个表达式节点类的实现方式都是相似的，这些类的代码编写都不会特别复杂，还可以通过一些工具自动生成节点类代码；</li><li>增加新的解释表达式较为方便。如果用户需要增加新的解释表达式只需要对应增加一个新的终结符表达式或非终结符表达式类，原有表达式类代码无需修改，符合开闭原则；</li></ol><h3 id="2-缺点"><a href="#2-缺点" class="headerlink" title="2. 缺点"></a>2. 缺点</h3><ol><li>对于复杂文法难以维护。在解释器模式中，每一条规则至少需要定义一个类，因此如果一个语言包含太多文法规则，类的个数将会急剧增加，导致系统难以管理和维护，此时可以考虑使用语法分析程序等方式来取代解释器模式；</li><li>执行效率较低。由于在解释器模式中使用了大量的循环和递归调用，因此在解释较为复杂的句子时其速度很慢，而且代码的调试过程也比较麻烦；</li></ol>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 行为型模式 </tag>
            
            <tag> 解释器 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>命令模式</title>
      <link href="/2017/02/27/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%91%BD%E4%BB%A4%E6%A8%A1%E5%BC%8F/"/>
      <url>/2017/02/27/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%91%BD%E4%BB%A4%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<p><code>命令模式（Command Pattern）</code>：将一个请求封装为一个对象，从而可用不同的请求对客户进行参数化；对请求排队或者记录请求日志，以及支持可撤销的操作。命令模式是一种 <strong>对象行为型模式</strong>，其别名为 <strong>动作（Action）模式</strong> 或 <strong>事务模式（Transaction）模式</strong>。</p><h3 id="1-优点"><a href="#1-优点" class="headerlink" title="1. 优点"></a>1. 优点</h3><ol><li>降低系统的耦合度。由于请求者与接收者之间不存在直接引用，因此请求者与接收者之间实现完全解耦，相同的请求者可以对应不同的接收者，同样，相同的接收者也可以供不同的请求者使用，两者之间具有良好的独立性；</li><li>新的命令可以很容易地加入到系统中。由于增加新的具体命令类不会影响到其他类，因此增加新的具体命令类很容易，无须修改原有系统源代码甚至客户类代码，满足开闭原则的要求；</li><li>可以比较容易地设计一个命令队列或者宏命令（组合命令）；</li><li>为请求的撤销（Undo）和恢复（Redo）操作提供了一种设计和实现方案；</li></ol><h3 id="2-缺点"><a href="#2-缺点" class="headerlink" title="2. 缺点"></a>2. 缺点</h3><ol><li>使用命令模式可能会导致某些系统有过多的具体命令类。因为针对每一个对请求接收者的调用操作都需要设计一个具体命令类，因此在某些系统中可能需要提供大量的具体命令类，这将影响命令模式的使用；</li></ol>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 行为型模式 </tag>
            
            <tag> 命令 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>职责链模式</title>
      <link href="/2017/02/27/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%81%8C%E8%B4%A3%E9%93%BE%E6%A8%A1%E5%BC%8F/"/>
      <url>/2017/02/27/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%81%8C%E8%B4%A3%E9%93%BE%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<p><code>职责链模式（Chain of Responsibility Pattern）</code>：避免将请求发送者与接收者耦合在一起，让多个对象都有机会接收请求，将这些对象链接成一条链，并且沿着这条链传递请求，知道有对象处理它为止。职责链模式是一种 <strong>对象行为型模式</strong>。</p><p>职责链模式可分为纯的职责链模式和不纯的职责链模式两种。</p><p><code>纯的职责链模式</code> 要求一个具体处理者对象只能在两个行为中选择一个：要么承担全部责任，要么将责任推给下家，不允许出现某一个具体处理者对象在承担了一部分或全部责任后又将责任向下传递的情况。而且在纯的职责链模式中，要求一个请求必须被某一个处理者对象所接收，不能出现某个请求未被任何一个处理者对象处理的情况。</p><p><code>不纯的职责链模式</code> 允许某个请求被一个具体处理者部分处理后再向下传递，或者一个具体处理者处理完某请求后其后继处理者可以继续处理该请求，而且一个请求可以最终不被任何处理者对象所接收。</p><h3 id="1-优点"><a href="#1-优点" class="headerlink" title="1. 优点"></a>1. 优点</h3><ol><li>职责链模式使得一个对象无须知道是其他哪一个对象处理其请求，对象仅需知道该请求会被处理即可，接收者和发送者都没有对方的明确信息，且链中的对象不需知道链的结构，由客户端负责链的创建，降低了系统的耦合度；</li><li>请求处理对象仅需维持一个指向其后继者的引用，而不需要维持它对所有的候选处理者的引用，可简化对象的相互连接；</li><li>在给对象分派职责时，职责链可以提供更多的灵活性，可以通过在运行时对链进行动态的增加或修改来增加或改变处理一个请求的职责；</li><li>在系统中增加一个新的具体请求处理者时无需修改原有系统的代码，只需要在客户端重新建链即可，从这一点来看是符合开闭原则的；</li></ol><h3 id="2-缺点"><a href="#2-缺点" class="headerlink" title="2. 缺点"></a>2. 缺点</h3><ol><li>由于一个请求没有明确的接收者，那么就不能保证它一定会被处理，该请求可能一直到链的末端都得不到处理；一个请求也可能因职责链没有被正确配置而得不到处理；</li><li>对于比较长的职责链，请求的处理可能涉及多个处理对象，系统性能将受到一定影响，而且在进行代码调试时不太方便；</li><li>如果建链不当，可能会造成循环调用，将导致系统陷入死循环；</li></ol>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 行为型模式 </tag>
            
            <tag> 职责链 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>代理模式</title>
      <link href="/2017/02/24/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/"/>
      <url>/2017/02/24/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<p><code>代理模式（Proxy Pattern）</code>：给某一个对象提供一个代理，并由代理对象控制对原对象的应用。代理模式是一种 <strong>对象结构性模式</strong>。</p><h3 id="1-常见的几种代理模式"><a href="#1-常见的几种代理模式" class="headerlink" title="1. 常见的几种代理模式"></a>1. 常见的几种代理模式</h3><ol><li><code>远程代理（Remote Proxy）</code>：为一个位于不同的地址空间的对象提供一个本地的代理对象，这个不同的地址空间可以在同一台主机中，也可以在另一台主机中。远程代理又称为大使（Ambassador）</li><li><code>虚拟代理（Virtual Proxy）</code>：如果需要创建一个资源消耗较大的对象，先创建一个消耗对象较小的对象来表示，真实对象只在需要时才会被真正创建</li><li><code>保护代理（Protect Proxy）</code>：控制对一个对象的访问，可以给不同的用户提供不同级别的使用权限</li><li><code>缓冲代理（Cache Proxy）</code>：为某一个目标操作的结果提供临时的存储空间，以便多个客户端可以共享这些结果</li><li><code>只能引用代理（Smart  Reference Proxy）</code>：当一个对象被引用时，提供一些额外的操作，例如将对象被调用的次数记录下来等等</li></ol><h3 id="2-RMI的基本实现步骤"><a href="#2-RMI的基本实现步骤" class="headerlink" title="2. RMI的基本实现步骤"></a>2. RMI的基本实现步骤</h3><ol><li>客户端发起请求，将请求转交至 RMI 客户端的 Stub 类</li><li>Stub 类将请求的接口、方法、参数等信息进行序列化</li><li>将序列化后的流使用 Socket 传输至服务器端</li><li>服务器端接收到流后将其转发至相应的 Skeleton 类</li><li>Skeleton 类将请求信息反序列化后调用实际的业务处理类</li><li>业务处理类处理完毕后将结果返回给 Skeleton 类</li><li>Skeleton 类将结果序列化，再次通过 Socket 将流传送给客户端的 Stub</li><li>Stub 在接收到流后进行反序列化，将反序列化后得到的 Java Object 对象返回给客户端调用者</li></ol><h3 id="3-优点"><a href="#3-优点" class="headerlink" title="3. 优点"></a>3. 优点</h3><ol><li>代理模式能够协调调用者和被调用者，在一定程度上降低了系统的耦合度，满足迪米特法则</li><li>客户端可以针对抽象主题角色进行编程，增加和更换代理类无须修改源代码，符合开闭原则，系统具有较好的灵活性和可扩展性</li><li>远程代理为位于两个不同地址空间对象的访问提供了一种实现机制，可以将一些消耗资源较多的对象和操作移至性能更好的计算机上，提高系统的整体运行效率</li><li>虚拟代理通过一个消耗资源较少的对象来代表一个消耗资源较多的对象，可以在一定程度上节省系统的运行开销</li><li>保护代理可以控制对一个对象的访问权限，为不同的用户提供不同级别的使用权限</li></ol><h3 id="4-缺点"><a href="#4-缺点" class="headerlink" title="4. 缺点"></a>4. 缺点</h3><ol><li>由于在客户端和真实主题之间增加了代理对象，因此有些类型的代理模式可能会造成请求的处理速度变慢，例如保护代理</li><li>实现代理模式需要额外的工作，有些代理模式的实现非常复杂，例如远程代理</li></ol>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 代理 </tag>
            
            <tag> 结构型模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>享元模式</title>
      <link href="/2017/02/24/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E4%BA%AB%E5%85%83%E6%A8%A1%E5%BC%8F/"/>
      <url>/2017/02/24/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E4%BA%AB%E5%85%83%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<p><code>享元模式（Flyweight Pattern）</code>：运用共享技术有效地支持大量细粒度对象的复用。系统只使用少量的对象，而这些对象都很相似，状态变化很小，可以实现对象的多次复用。由于享元模式要求能够共享的对象必须是细腻度对象，因此它又称为轻量级模式，是一种 <strong>对象结构性模式</strong>。</p><p><code>单纯享元模式</code> 中，所有的具体享元类都是可以共享的，不存在非共享具体享元类。</p><p><code>符合享元模式</code> 是将一些单纯享元对象使用组合模式加以组合。</p><h3 id="1-优点"><a href="#1-优点" class="headerlink" title="1. 优点"></a>1. 优点</h3><ol><li>可以极大减少内存中对象的数量，使得相同或相似对象在内存中只保存一份，从而可以节约系统资源，提高系统性能</li><li>享元模式的外部状态相对独立，而且不会影响其内部状态，从而使得享元对象可以在不同的环节中被共享</li></ol><h3 id="2-缺点"><a href="#2-缺点" class="headerlink" title="2. 缺点"></a>2. 缺点</h3><ol><li>享元模式使得系统变得复杂，需要分离出内部状态和外部状态，这使得程序的逻辑复杂化</li><li>为了使对象可以共享，享元模式需要将享元对象的部分状态外部化，而读取外部状态将使得运行时间长</li></ol>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 享元 </tag>
            
            <tag> 结构型模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>外观模式</title>
      <link href="/2017/02/24/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%A4%96%E8%A7%82%E6%A8%A1%E5%BC%8F/"/>
      <url>/2017/02/24/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%A4%96%E8%A7%82%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<p><code>外观模式（Facade Pattern）</code>：外部与一个子系统的通信通过一个统一的外观角色进行，为子系统中的一组接口提供一个一致的入口，外观模式定义了一个高层接口，这个接口使得这一子系统更加容易使用。外观模式又称为门面模式，它是一种 <strong>对象结构性模式</strong>。</p><h3 id="1-优点"><a href="#1-优点" class="headerlink" title="1. 优点"></a>1. 优点</h3><ol><li>对客户端屏蔽了子系统组件，减少了客户端所需处理的对象数目并使得子系统使用起来更加容易。通过引入外观模式，客户端代码将变得很简单，与之关联的对象也很少</li><li>实现了子系统与客户端之间的松耦合关系，这使得子系统的变化不会影响到调用它的客户端，只需要调整外观类即可</li><li>一个子系统的修改对其他子系统没有任何影响，而且子系统内部变化也不会影响到外观对象</li><li>只提供了一个访问子系统的统一入口，并不影响客户端直接使用子系统类</li></ol><h3 id="2-缺点"><a href="#2-缺点" class="headerlink" title="2. 缺点"></a>2. 缺点</h3><ol><li>不能很好地限制客户端直接只用子系统类，如果对客户端访问子系统类做太多的限制则减少了可变性和灵活性</li><li>如果设计不当，怎加新的子系统可能需要修改外观类的源代码，这违背了开闭原则</li></ol>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 结构型模式 </tag>
            
            <tag> 外观 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>装饰模式</title>
      <link href="/2017/02/23/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%A3%85%E9%A5%B0%E6%A8%A1%E5%BC%8F/"/>
      <url>/2017/02/23/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%A3%85%E9%A5%B0%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<p><code>装饰模式（Decorator Pattern）</code>：动态地给一个对象增加一些额外的职责，就增加对象功能来说，装饰模式比生产子类实现更为灵活。装饰模式是一种 <strong>对象结构型模式</strong>。</p><h3 id="1-注意事项"><a href="#1-注意事项" class="headerlink" title="1. 注意事项"></a>1. 注意事项</h3><ol><li>尽量保持装饰类的接口与被装饰类的接口相同，这样，对于客户端而言，无论是装饰之前的对象还是装饰之后的对象都可以一致对待。这也就是说，在可能的情况下，应该尽量使用透明装饰模式</li><li>尽量保持具体构件类 ConcreteComponent 是一个「轻」类，也就是说不要把太多的行为放在具体构件类中，可以通过装饰类对其进行扩展</li><li>如果只有一个具体构件类，那么抽象装饰类可以作为该具体构件类的直接子类</li></ol><h3 id="2-优点"><a href="#2-优点" class="headerlink" title="2. 优点"></a>2. 优点</h3><ol><li>对于扩展一个对象的功能，装饰模式比继承更加灵活，不会导致类的个数急剧增加</li><li>可以通过一种动态的方式来扩展一个对象的功能，通过配置文件可以在运行时选择不同的具体装饰类，从而实现不同的行为</li><li>可以对一个对象进行多次装饰，通过使用不同的具体装饰类以及这些装饰类的排列组合，可以创造出很多不同行为的组合，得到功能更为强大的对象</li><li>具体构件类与具体装饰类可以独立变化，用户可以根据需要增加新的具体构件类和具体装饰类，原有类库代码无需改变，符合开闭原则</li></ol><h3 id="3-缺点"><a href="#3-缺点" class="headerlink" title="3. 缺点"></a>3. 缺点</h3><ol><li>使用装饰者模式进行系统设计时将产生很多小对象，这些对象的区别在于它们之间相互连接的方式有所不同，而不是它们的类或者属性值有所不同，大量小对象的产生势必会占用更多的系统资源，在一定程度上影响程序的性能</li><li>装饰模式提供了一种比继承更加灵活机动的解决方案，但同时也意味着比继承更加易于出错，排错也很困难，对于多次装饰的对象，调试时寻找错误可能需要逐级排查，较为繁琐</li></ol>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 结构型模式 </tag>
            
            <tag> 装饰 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>组合模式</title>
      <link href="/2017/02/23/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F/"/>
      <url>/2017/02/23/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<p><code>组合模式（Composite Pattern）</code>：组合多个对象形成树形结构以表示具有「整体一部分」关系的层次结构。组合模式对单个对象（即叶子对象）和组合对象（即容器对象）的使用具有一致性，组合模式又可以称为 <strong>「整体-部分」模式</strong>，它是一种 <strong>对象结构性模式</strong>。</p><h3 id="1-组合模式"><a href="#1-组合模式" class="headerlink" title="1. 组合模式"></a>1. 组合模式</h3><ul><li><strong>透明组合模式</strong> 中，抽象组件 Component 中声明了所有用于管理成员对象的方法，包括 add(), remove() 以及 getChild() 等方法，这样做的好处是确保所有的构件类都有相同的接口</li><li><strong>安全组合模式</strong> 中，在抽象组件 Component 中没有声明任何用于管理成员对象的方法，而是在 Composite 类中声明并实现这些方法。</li></ul><h3 id="2-优点"><a href="#2-优点" class="headerlink" title="2. 优点"></a>2. 优点</h3><ol><li>组合模式可以清楚地定义分层次的复杂对象，表示对象的全部或部分层次，它让客户端忽略了层次的差异，方便对整个层次结构进行控制</li><li>客户端可以一致地使用一个组合结构或其中单个对象，不必关心处理的是单个对象还是整个组合结构，简化了客户端代码</li><li>在组合模式中增加新的容器构件和叶子构件都很方便，无需对现有类库进行任何修改，符合开闭原则</li><li>组合模式为树形结构的面向对象实现提供了一种灵活的解决方案，通过叶子对象和容器对象的递归组合，可以形成复杂的树形结构，但对树形结构的控制却非常简单</li></ol><h3 id="3-缺点"><a href="#3-缺点" class="headerlink" title="3. 缺点"></a>3. 缺点</h3><ol><li>在增加新构件时很难对容器中的构件类型进行限制。</li></ol>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 结构型模式 </tag>
            
            <tag> 组合 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>桥接模式</title>
      <link href="/2017/02/21/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E6%A1%A5%E6%8E%A5%E6%A8%A1%E5%BC%8F/"/>
      <url>/2017/02/21/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E6%A1%A5%E6%8E%A5%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<p><code>桥接模式（Bridge Pattern）</code>：将抽象部分与其实现部分分离，使他们都可以独立地变化。它是一种 <strong>对象结构型模式</strong>，又称为 <strong>柄体（Handle and Body）模式</strong> 或 <strong>接口（Interface）模式</strong>。</p><h3 id="1-优点"><a href="#1-优点" class="headerlink" title="1. 优点"></a>1. 优点</h3><ol><li>分离抽象接口及其实现部分。桥接模式使用「对象间的关联关系」解耦了抽象和实现之间固有的绑定关系，使得抽象和实现可以沿着各自的维度来变化（即抽象和实现不再在同一个继承层次结构中，而是「子类化」它们，使它们各自都具有自己的子类，以便任意组合子类，从而获得多维度组合对象）；</li><li>在很多情况下，桥接模式可以取代更多层继承方案。多继承方案违背了单一职责原则，复用性较差，且类的个数非常多，桥接模式是比多层继承方案更好的解决方法，它极大的减少了子类的个数；</li><li>桥接模式提高了系统的可扩展性，在两个变化维度中任意扩展一个维度，都不需要修改原有系统，符合开闭原则</li></ol><h3 id="2-缺点"><a href="#2-缺点" class="headerlink" title="2. 缺点"></a>2. 缺点</h3><ol><li>桥接模式的使用会增加系统的理解与设计难度，由于关联关系建立在抽象层，要求开发者一开始就针对抽象层进行设计与编程；</li><li>桥接模式要求正确识别出系统中两个独立变化的维度，因此其使用范围具有一定的局限性，如何正确识别两个独立维度也需要一定的经验积累</li></ol>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 结构型模式 </tag>
            
            <tag> 桥接 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>适配器模式</title>
      <link href="/2017/02/20/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F/"/>
      <url>/2017/02/20/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<p><code>适配器模式（Adapter Pattern）</code>：将一个接口转换成客户希望的另一个接口，使接口不兼容的那些类可以一起工作，其别名为包装器（Wrapper）。适配器模式既可以作为类结构型模式，也可以作为对象结构型模式。</p><h3 id="1-适配器模式分类"><a href="#1-适配器模式分类" class="headerlink" title="1. 适配器模式分类"></a>1. 适配器模式分类</h3><ol><li>对象适配器</li><li>类适配器</li><li>双向适配器</li><li>缺省适配器</li></ol><p><code>缺省适配器模式（Default Adapter Pattern）</code>：当不需要实现一个接口所提供的所有方法时，可先设计一个抽象类实现该接口，并为接口中每个方法提供一个默认实现（空方法），那么该抽象类的子类可以选择性地覆盖父类的某些方法来实现需求，它适用于不想使用一个接口中的所有方法的情况，又称为单接口适配器模式。</p><h3 id="2-优点"><a href="#2-优点" class="headerlink" title="2. 优点"></a>2. 优点</h3><ol><li>将目标类和适配者类解耦，通过引入一个适配器类来重用现有的适配者类，无须修改原有结构；</li><li>增加了类的透明性和复用性，将具体的业务实现过程封装在适配者类中，对于客户端类而言是透明的，而且提高了适配者类的复用性，同一个适配者类可以在多个不同的系统中复用；</li><li>灵活性和扩展性都非常好，通过使用配置文件，可以很方便地更换适配器，也可以在不修改原有代码的基础上增加新的适配器类，完全符合开闭原则；</li></ol><p><strong>类适配器优点</strong>：由于适配器类是适配者类的子类，因此可以在适配器类中置换一些适配者的方法，使得适配器的灵活性更强。</p><p><strong>对象适配器优点</strong>：</p><ol><li>一个对象适配器可以把多个不同的适配者适配到同一个目标</li><li>可以适配一个适配者的子类，由于适配器和适配者之间是关联关系，根据里氏代换原则，适配者的子类也可通过该适配器进行适配</li></ol><h3 id="3-缺点"><a href="#3-缺点" class="headerlink" title="3. 缺点"></a>3. 缺点</h3><ol><li>对于 Java、c# 等不支持多重类继承的语言，一次最多只能适配一个适配者类，不能同时适配多个适配者；</li><li>适配者类不能为最终类，例如在 Java 中不能为 final 类，C# 中不能为 sealed 类；</li><li>在 Java、C# 等语言中，类适配器模式中的目标抽象类只能为接口，不能为类，其使用有一定的局限性；</li></ol><h3 id="4-适用场景"><a href="#4-适用场景" class="headerlink" title="4. 适用场景"></a>4. 适用场景</h3><ol><li>系统需要使用一些现有的类，而这些类的接口(例如方法名)不符合系统的需要，甚至没有这些类的源代码；</li><li>想创建一个可以重复使用的类，用于与一些彼此之间没有太大关联的类，包括一些可能在将来引进的类一起工作；</li></ol>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 结构型模式 </tag>
            
            <tag> 适配器 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>建造者模式</title>
      <link href="/2017/02/17/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F/"/>
      <url>/2017/02/17/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<p><code>建造者模式（Builder Pattern）</code>：将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。建造者模式是一种 <strong>对象创建型模式</strong>。</p><h3 id="1-优点"><a href="#1-优点" class="headerlink" title="1. 优点"></a>1. 优点</h3><ol><li>在建造者模式中，客户端不必知道产品内部组成的细节，将产品本身与产品的创建过程解耦，使得相同的创建过程可以创建不同的产品对象</li><li>每一个具体建造者都相对独立，而与其他具体建造者无关，因此可以很方便地替换具体建造者或增加新的具体建造者，用户使用不同的具体建造者即可得到不同的产品对象。由于指挥类针对抽象建造者编程，增加新的具体建造者无须修改原有类库的代码，系统扩展方便，符合开闭原则</li><li>可以更加精细地控制产品的创建过程。将复杂产品的创建步骤分解在不同的方法中，使得创建过程更加清晰，也更加方便使用程序来控制创建过程</li></ol><h3 id="2-缺点"><a href="#2-缺点" class="headerlink" title="2. 缺点"></a>2. 缺点</h3><ol><li>建造者模式所创建的产品一般具有较多的共同点，其组成部分相似，如果产品之间的差异性很大，例如很多组成部分都不相同，就不适合使用建造者模式，因此其使用范围受到一定的限制</li><li>如果产品的内部结构复杂且多变，可能会需要定义很多具体建造者类来实现这种变化，这就导致系统变得很庞大，增加系统的理解难度和运行成本</li></ol>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 创建型模式 </tag>
            
            <tag> 建造者 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>原型模式</title>
      <link href="/2017/02/16/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F/"/>
      <url>/2017/02/16/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<p><code>原型模式（Prototype Pattern）</code>：使用原型实例指定创建对象的种类，并且通过克隆这些原型创建新的对象。原型模式是一种 <strong>对象创建型模式</strong>。</p><h3 id="1-原型模式结构"><a href="#1-原型模式结构" class="headerlink" title="1. 原型模式结构"></a>1. 原型模式结构</h3><ol><li>抽象原型类（Prototype）：它是声明克隆方法的接口，是所有具体原型类的公共父类，可以是抽象类也可以是接口，甚至还可以是具体实现类</li><li>具体原型类（ConcretePrototype）：它实现在抽象原型类中声明的克隆方法，在克隆方法中返回自己的一个克隆对象</li><li>客户类（Client）：让一个原型对象克隆自身从而创建一个新的对象，在客户类中只需要直接实例化或通过工厂方法等方式创建一个原型对象，再通过调用该对象的克隆方法即可得到多个相同的对象</li></ol><h3 id="2-浅克隆与深克隆相同与区别"><a href="#2-浅克隆与深克隆相同与区别" class="headerlink" title="2. 浅克隆与深克隆相同与区别"></a>2. 浅克隆与深克隆相同与区别</h3><h4 id="2-1-相同点"><a href="#2-1-相同点" class="headerlink" title="2.1 相同点"></a>2.1 相同点</h4><ol><li>克隆的 object 的都是新的，即内存地址是不同的</li></ol><h4 id="2-2-不同点"><a href="#2-2-不同点" class="headerlink" title="2.2 不同点"></a>2.2 不同点</h4><ol><li>浅克隆克隆的是内存指向地址，如果是 <strong>基本数据类型</strong>，影响不大，如果是 <strong>引用类型</strong>，则 clone 对象中属性的修改，会引起被克隆对象数据的修改，导致数据紊乱</li><li>深 clone，即将整个对象 clone 并且生成新的对象，不论是对象内存指向地址还是属性内存指向地址，都不相同，可以进行需求操作而不影响被 clone 体</li></ol><p><strong>浅克隆</strong> 的实现方案是：利用 java 的 cloneable 接口，可以快速实现克隆；或者创建一个新对象，并且赋值即可。</p><p><strong>深克隆</strong> 的实现方案是：利用 Serializable 接口，克隆对象流并生成新对象即可。</p><h3 id="3-优点"><a href="#3-优点" class="headerlink" title="3. 优点"></a>3. 优点</h3><ol><li>当创建新的对象实例较为复杂时，使用原型模式可以简化对象的创建过程，通过复制一个已有实例可以提高新实例的创建效率</li><li>扩展性好。由于在原型模式中提供了抽象原型类，在客户端可以针对抽象原型类进行编程，而将具体原型类写在配置文件中，增加或减少具体原型类对原有系统都没有任何影响</li><li>原型模式提供了简化的创建结构。工厂方法模式常常需要有一个月产品类等级结构相同的工厂等级结构，而原型模式就不需要这样，原型模式中产品的复制是通过封装在原型类中的克隆方法实现的，无须专门的工厂类来创建产品</li><li>可以使用深克隆的方式保存对象状态。使用原型模式将对象复制一份并将其状态保存起来，以便在需要的时候使用，例如恢复到某一历史状态，可辅助实现撤销操作</li></ol><h3 id="4-缺点"><a href="#4-缺点" class="headerlink" title="4. 缺点"></a>4. 缺点</h3><ol><li>需要为每一个类配备一个克隆方法，而且该克隆方法位于一个类的内部，当对已有的类进行改造时，需要修改源代码，违背了开闭原则</li><li>在实现深克隆时需要编写较为复杂的代码，而且当对象之间存在多重的嵌套引用时，为了实现深克隆，每一层对象对应的类都必须支持深克隆，实现起来可能会比较麻烦</li></ol>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 创建型模式 </tag>
            
            <tag> 原型 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>3种工厂模式对比</title>
      <link href="/2017/02/16/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/3%E7%A7%8D%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F%E5%AF%B9%E6%AF%94/"/>
      <url>/2017/02/16/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/3%E7%A7%8D%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F%E5%AF%B9%E6%AF%94/</url>
      
        <content type="html"><![CDATA[<table><thead><tr><th align="left">模式名称</th><th align="left">优点</th><th align="left">缺点</th></tr></thead><tbody><tr><td align="left">简单工厂模式（Simple Factory Pattern）</td><td align="left">1、一个工厂类就可以实现功能；<br/>2、外部无需关注如何获取所需对象</td><td align="left">1、每当添加或者删除一个对象时，需要修改 Factory 类，不符合开闭原则；<br/>2、Factory 类职责过重，需要负责的东西很多</td></tr><tr><td align="left">工厂方法模式（Factory Method Pattern）</td><td align="left">1、新增产品时，无需修改 Factory 代码，符合开闭原则</td><td align="left">1、每添加一个新产品，需要生成一个产品 class 和一个产品对应的 Facroty，会增加项目的复杂度；</td></tr><tr><td align="left">抽象工厂模式（Abstract Factory Pattern）</td><td align="left">1、新增产品族时无需修改 Factory 类，符合开闭原则，满足后期扩展的需求</td><td align="left">1、新增产品等级结构的时候，需要修改 Factory 类，不符合开闭原则；<br/>2、修改 Factory 的时候，由于 Factory 是抽象类，影响较大，如果系统比较庞大，会出现很多新问题</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 工厂 </tag>
            
            <tag> 汇总 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>抽象工厂模式</title>
      <link href="/2017/02/15/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/"/>
      <url>/2017/02/15/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<p><code>抽象工厂模式（Abstract Factory Pattern）</code>：提供一个创建一系列相关或相互依赖对象的接口，而无须指定它们具体的类。抽象工厂模式又称为 Kit 模式，它是一种 <strong>对象创建型模式</strong>。</p><h3 id="1-优点"><a href="#1-优点" class="headerlink" title="1. 优点"></a>1. 优点</h3><ol><li>抽象工厂模式隔离了具体类的生成，使得客户并不需要知道什么被创建。由于这种隔离，更换一个具体工厂就变得相对容易，所有的具体工厂都实现了在抽象工厂中声明的那些公共接口，因此只需要改变具体工厂的实例，就可以在某种程度上改变整个软件系统的行为</li><li>当一个产品族中的多个对象被设计成一起工作时，它能够保证客户端始终只使用同一个产品族中的对象</li><li>增加新的产品族很方便，无需修改已有系统，符合开闭原则</li></ol><h3 id="2-缺点"><a href="#2-缺点" class="headerlink" title="2. 缺点"></a>2. 缺点</h3><ol><li>增加新的产品等级结构麻烦，需要对原有系统进行较大的修改，甚至需要修改抽象层代码，违背了<code>开闭原则</code></li></ol>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 创建型模式 </tag>
            
            <tag> 抽象工厂 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>工厂方法模式</title>
      <link href="/2017/02/15/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F/"/>
      <url>/2017/02/15/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<p><code>工厂方法模式（Factory Method Pattern）</code>：定义一个用于创建对象的接口，让子类决定将哪一个类实例化。工厂方法模式让一个类的实例化延迟到其子类。工厂方法模式又简称为 <strong>工厂模式（Factory Pattern）</strong>，又可称作 <strong>虚拟构造器模式（Virtual Constructor Pattern）</strong> 或 <strong>多态工厂模式（Polymorphic Factory Pattern）</strong>。工厂方法模式是一种 <strong>类创建型模式</strong>。</p><h3 id="1-优点"><a href="#1-优点" class="headerlink" title="1. 优点"></a>1. 优点</h3><ol><li>在工厂方法模式中，工厂方法用来创建客户所需要的产品，同时还向客户隐藏了哪种具体产品类将被实例化这一细节，用户只需要关心所需产品对应的工厂，无需关心创建细节，甚至无须知道具体产品类的类名</li><li>基于工厂角色和产品角色的多态性设计是工厂方法模式的关键。它能够让工厂可以自主确定创建何种产品对象，而如何创建这个对象的细节则完全封装在具体工厂内部。工厂方法模式之所以又被称为多态工厂模式，正是因为所有的具体工厂类都具有同一抽象父类</li><li>使用工厂方法模式的另一个优点使在系统中加入新产品时，无须修改抽象工厂和抽象产品提供的接口，无须修改客户端，也无须修改其它的具体工厂和具体产品，而只要添加一个具体工厂和具体产品就可以了，这样，系统的可扩展性也就变得非常好，完全符合开闭原则</li></ol><h3 id="2-缺点"><a href="#2-缺点" class="headerlink" title="2. 缺点"></a>2. 缺点</h3><ol><li>在添加新产品时，需要编写新的具体产品类，而且还要提供与之对应的具体工厂类，系统中类的个数将成对增加，在一定程度上增加了系统的复杂度，有更多的类需要编译和运行，会给系统带来一些额外的开销</li><li>由于考虑到系统的可扩展性，需要引入抽象层，在客户端代码中均使用抽象层就行定义，增加了系统的抽象性和理解难度，且在实现时可能需要用到 DOM、反射等技术，增加了系统的实现难度</li></ol>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 创建型模式 </tag>
            
            <tag> 工厂方法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>简单工厂模式</title>
      <link href="/2017/02/15/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E7%AE%80%E5%8D%95%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/"/>
      <url>/2017/02/15/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E7%AE%80%E5%8D%95%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<p><code>简单工厂模式（Simple Factory Pattern）</code>：定义一个工厂类，它可以根据参数的不同返回不同的实例，被创建的实例通常都具有共同的父类。</p><h3 id="1-优点"><a href="#1-优点" class="headerlink" title="1. 优点"></a>1. 优点</h3><ol><li>工厂类包含必要的判断逻辑，可以决定在什么时候创建哪一个产品类的实例，客户端可以免除直接创建产品对象的职责，而仅仅「消费」产品。简单工厂模式实现了对象创建和使用的分离</li><li>客户端无需知道所创建的具体产品类的类名，只需要知道具体产品类所对应的参数即可，对于一些复杂的类名，通过简单工厂模式可以在一定的程度减少使用者的记忆量</li><li>通过引入配置文件，可以在不修改任何客户端代码的情况下更换和增加新的具体产品类，在一定程度上提高了系统的灵活性</li></ol><h3 id="2-缺点"><a href="#2-缺点" class="headerlink" title="2. 缺点"></a>2. 缺点</h3><ol><li>由于工厂类集中了所有产品的创建逻辑，职责过重，一旦不能正常工作，整个系统都要受到影响</li><li>使用简单工厂模式势必会增加系统中类的个数，增加了系统的复杂度和理解难度</li><li>系统扩展困难，一旦添加新产品就不得不修改工厂逻辑，在产品类型较多时，有可能造成工厂逻辑过于复杂，不利于系统的扩展和维护</li><li>简单工程模式由于使用了静态工厂方法，造成工厂角色无法形成基于继承的等级结构</li></ol>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 创建型模式 </tag>
            
            <tag> 简单工厂 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>单例模式</title>
      <link href="/2017/02/15/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"/>
      <url>/2017/02/15/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<p><code>单例模式（Singleton Pattern）</code>：确保某一个类只有一个实例，而且自行实例化并向整个系统提供这个实例，这个类称为单例类，它提供全局访问的方法。单例模式是一种 <strong>对象创建型模式</strong>。</p><h3 id="1-单例模式要点"><a href="#1-单例模式要点" class="headerlink" title="1. 单例模式要点"></a>1. 单例模式要点</h3><ol><li>某个类只能有一个实例</li><li>它必须自行创建这个实例</li><li>它必须自行向整个系统提供这个实例</li></ol><p><img src="http://personal-blog.oss-cn-hangzhou.aliyuncs.com/design_pattern_singleton.png" alt="单例模式"></p><h3 id="2-优点"><a href="#2-优点" class="headerlink" title="2. 优点"></a>2. 优点</h3><ol><li>单例模式提供了对唯一实例的受访控制</li><li>由于在系统内只存在一个对象，因此可以节约系统资源</li><li>允许可变数量的实例</li></ol><h3 id="3-缺点"><a href="#3-缺点" class="headerlink" title="3. 缺点"></a>3. 缺点</h3><ol><li>由于单例模式中没有抽象层，因此单例类的扩展有很大的困难</li><li>单例类的职责过重，在一定程度上违背了单一职责原则</li><li>编程语言的自动垃圾回收技术，如果实例化的共享对象长时间不被利用，系统会自动销毁并回收资源，这将导致共享的单例对象状态的丢失</li></ol>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 单例 </tag>
            
            <tag> 创建型模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>UML 概述</title>
      <link href="/2017/02/14/UML/UML%E6%A6%82%E8%BF%B0/"/>
      <url>/2017/02/14/UML/UML%E6%A6%82%E8%BF%B0/</url>
      
        <content type="html"><![CDATA[<p><code>UML 类图</code> 可用于描述每一个设计模式的结构以及对模式实例进行说明，而模式结构又是设计模式解法的核心组成部分。</p><h3 id="1-UML-特性"><a href="#1-UML-特性" class="headerlink" title="1. UML 特性"></a>1. UML 特性</h3><ol><li>UML 融合了多种优秀的面向对象建模方法以及多种得到认可的软件工程方法，消除了因方法林立且互相独立而带来的种种不便，集百家之所长，故名 <strong>「统一（Unified）」</strong>；</li><li>UML 是一种通用的可视化 <strong>建模（Modeling）</strong> 语言，不同于编程语言，它通过一些标准的图形符号和文字来对系统进行建模，用于对软件进行描述、可视化处理、构造和建立软件系统制品的文档；</li><li>UML 是一种 <strong>语言（Language）</strong>，也就意味着它有属于自己的标准表达规则，它不是一种类似  Java，C++，C# 的编程语言，而是一种分析设计语言，也就是一种建模语言；</li></ol><h3 id="2-UML-结构"><a href="#2-UML-结构" class="headerlink" title="2. UML 结构"></a>2. UML 结构</h3><ol><li><code>视图（View）</code>：UML 视图用于从不同的角度来表示待建模系统（UML 视图包括用户视图、结构视图、行为视图、实现视图和环境视图）；</li><li><code>图（Diagram）</code>：UML 图是描述 UML 视图内容的图形（分别是用例图、类图、对象图、包图、组合结构图、状态图、活动图、顺序图、通信图、定时图、交互概览图、组件图和部署图）；</li><li><code>模型元素（Model Element）</code>：模型元素是指 UML 图中所使用的一些概念，它们对应于普通的面向对象概念，如类、对象、消息以及这些概念之间的关系，如关联关系、依赖关系、泛化关系等；</li><li><code>通用机制（General Mechanism）</code>：UML 提供的通用机制为模型元素提供额外的注释、信息和寓意，这些通用机制也提供了扩展机制，允许用户对 UML 进行扩展，如定义新的建模元素、扩展原有元素的语义、添加新的特殊信息来扩展模型元素的规则说明等，以便适用于一个特定的方法或过程、组织或用户；</li></ol><h3 id="3-UML-类的组成"><a href="#3-UML-类的组成" class="headerlink" title="3. UML 类的组成"></a>3. UML 类的组成</h3><ol><li><code>类名</code>：每个类都必须有一个名字，类名也是一个字符串；</li><li><code>类的操作（Operations）</code>：操作是类的任意一个实例对象都可以使用的行为，是类的成员方法；</li><li><code>类的属性（Attributes）</code>：属性是指类的性质，即类的成员变量。一个类可以有任意多个属性，也可以没有属性；UML 规定属性的表示方法为：<code>可见性 名称 :类型[ = 默认值]</code>。</li></ol><blockquote><ol><li>「可见性」表示该属性对于类外的元素而言是否可见，包括公有（public）、私有（private）和受保护（protected）3 种，在类图中分别用符号 +、- 和 # 表示;</li><li>「名称」表示属性名，用一个字符串表示;</li><li>「类型」表示属性的数据类型，可以是基本数据类型，也可以是用户自定义类型;</li><li>「默认值」是一个可选项，即属性的初始值;</li></ol></blockquote><h3 id="4-类之间的关系"><a href="#4-类之间的关系" class="headerlink" title="4. 类之间的关系"></a>4. 类之间的关系</h3><ol><li>关联关系<ul><li><pre><code>双向关联</code></pre></li><li>单向关联</li><li>自关联</li><li>多重性关联</li><li>聚合关系</li><li>组合关系</li></ul></li><li>依赖关系</li><li>泛化关系</li><li>接口与实现关系</li></ol><p><img src="http://personal-blog.oss-cn-hangzhou.aliyuncs.com/uml_base.png" alt="类之间关系图例"></p>]]></content>
      
      
      <categories>
          
          <category> UML </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 基础 </tag>
            
            <tag> UML </tag>
            
            <tag> 特性 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>面向对象设计原则</title>
      <link href="/2017/01/11/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99/"/>
      <url>/2017/01/11/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99/</url>
      
        <content type="html"><![CDATA[<p>在引用开发过程中，最难的不是完成应用的开发工作，而是在后续的升级、维护过程中让应用系统能够拥抱变化。拥抱变化也就意味着在满足需求且不破坏系统稳定性的前提下保持高可扩展性、高内聚、低耦合，在经历了个版本的变更之后依然保持清晰、灵活、稳定的系统架构。当然，这是一个比较理想的情况，但我们必须要朝着这个方向去努力，那么遵循面向对象设计原则就是我们走向灵活软件之路所迈出的第一步。</p><h4 id="1-单一职责原则（Single-Responsibility-Principle-SRP）"><a href="#1-单一职责原则（Single-Responsibility-Principle-SRP）" class="headerlink" title="1. 单一职责原则（Single Responsibility Principle, SRP）"></a>1. 单一职责原则（Single Responsibility Principle, SRP）</h4><p><code>单一职责原则</code>：就一个类而言，应该仅有一个引起它变化的原因。简单来说，一个类中应该是一组相关性很高的函数、数据的封装。</p><p>简单一点的理解就是：一个类只负责一个职责。举个栗子：商品类只处理商品相关信息，而不需要去管员工信息。</p><h4 id="2-开闭原则（Open-Closed-Principle-OCP）"><a href="#2-开闭原则（Open-Closed-Principle-OCP）" class="headerlink" title="2. 开闭原则（Open-Closed Principle, OCP）"></a>2. 开闭原则（Open-Closed Principle, OCP）</h4><p><code>开闭原则</code>：软件中的对象（类、模块、函数等）应该对于扩展是开放的，但是，对于修改是封闭的。</p><h4 id="3-里氏替换原则（Liskov-Substitution-Principle-LSP）"><a href="#3-里氏替换原则（Liskov-Substitution-Principle-LSP）" class="headerlink" title="3. 里氏替换原则（Liskov Substitution Principle, LSP）"></a>3. 里氏替换原则（Liskov Substitution Principle, LSP）</h4><p><code>里氏替换原则</code> 通俗的定义是：所有引用基类(父类)的地方必须能透明地使用其子类对象。</p><p><code>里氏替换原则</code> 的定义是（两种定义）：</p><ol><li>如果对每一个类型为 S 的对象 O1，都有类型为 T 的对象 O2，使得以 T 定义的所有程序 P 在所有的对象 O1 都代换成 O2 时，程序 P 的行为没有发生变化，那么类型 S 是类型 T 的子类型；</li><li>所有引用基类的地方必须能透明地使用其子类对象；</li></ol><p>继承的<strong>优点</strong>：</p><ol><li>代码重用，减少创建类的成本，每个子类都拥有父类的方法和属性；</li><li>子类与父类基本相似，但又与父类有所区别；</li><li>提高代码的可扩展性；</li></ol><p>继承的<strong>缺点</strong>：</p><ol><li>继承是侵入性的，只要继承就必须拥有父类的所有属性和方法；</li><li>可能造成子类代码冗余、灵活性降低，因为子类必须拥有父类的属性和方法；</li></ol><p>上述解释可能感觉有点绕，实际上也可以简单一点来说：</p><ol><li>子类可以扩展父类的功能</li><li>不要改变父类原有的功能（这一点最重要）</li></ol><h4 id="4-依赖倒置原则（Dependency-Inversion-Principle-DIP）"><a href="#4-依赖倒置原则（Dependency-Inversion-Principle-DIP）" class="headerlink" title="4. 依赖倒置原则（Dependency Inversion Principle, DIP）"></a>4. 依赖倒置原则（Dependency Inversion Principle, DIP）</h4><p><code>依赖倒置原则</code>：指代了一种特定的解耦形式，使得高层次的模块不依赖于低层次的模块的实现细节的目的，依赖模块被颠倒了。通俗的讲就是：抽象不应该依赖于细节，细节应当依赖于抽象；换言之，要针对接口编程，而不是针对实现编程。</p><p><strong>关键点</strong></p><ol><li>高层模块不应该依赖低层模块，两者都应该依赖其抽象；</li><li>抽象不应该依赖细节；</li><li>细节应该依赖抽象；</li></ol><h4 id="5-接口隔离原则（Interface-Segregation-Principle-ISP）"><a href="#5-接口隔离原则（Interface-Segregation-Principle-ISP）" class="headerlink" title="5. 接口隔离原则（Interface Segregation Principle, ISP）"></a>5. 接口隔离原则（Interface Segregation Principle, ISP）</h4><p><code>接口隔离原则</code> 的定义是（两种定义）：</p><ol><li>客户端不应该依赖它不需要的接口；</li><li>类间的依赖关系应该建立在最小的接口上；</li></ol><h4 id="6-合成复用原则（Composite-Reuse-Principle-CRP）"><a href="#6-合成复用原则（Composite-Reuse-Principle-CRP）" class="headerlink" title="6. 合成复用原则（Composite Reuse Principle, CRP）"></a>6. 合成复用原则（Composite Reuse Principle, CRP）</h4><p><code>合成复用原则</code>：尽量使用对象组合，而不是继承来达到复用的目的。</p><h4 id="7-迪米特原则（Law-of-Demeter-LOD）"><a href="#7-迪米特原则（Law-of-Demeter-LOD）" class="headerlink" title="7. 迪米特原则（Law of Demeter, LOD）"></a>7. 迪米特原则（Law of Demeter, LOD）</h4><p><code>迪米特原则</code> 的定义是：一个对象应该对其他对象有最少的了解。通俗地讲，一个类应该对自己需要耦合或调用的类知道的最少，类的内部如何实现与调用者或者依赖者只需要知道它需要的方法即可，其它的可一概不用管。类与类之间的关系越密切，耦合度越大，当一个类发生改变时，对另一个类的影响也越大。</p><p>简单一点来说，局部变量中，不要引入新的类，错误示例代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Order</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="type">Product</span> <span class="variable">product</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Product</span>();</span><br><span class="line"><span class="keyword">private</span> <span class="type">Customer</span> <span class="variable">customer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Customer</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">book</span><span class="params">(<span class="type">int</span> productId, <span class="type">int</span> userId)</span> &#123;</span><br><span class="line"><span class="type">Worker</span> <span class="variable">worker</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Worker</span>(); <span class="comment">// 在局部变量中，引入了新的类 Worker，违反了迪米特原则</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 基础 </tag>
            
            <tag> 设计原则 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设计模式概述</title>
      <link href="/2017/01/10/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%A6%82%E8%BF%B0/"/>
      <url>/2017/01/10/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%A6%82%E8%BF%B0/</url>
      
        <content type="html"><![CDATA[<h3 id="1-设计模式简介"><a href="#1-设计模式简介" class="headerlink" title="1. 设计模式简介"></a>1. 设计模式简介</h3><p><code>模式</code> 是在特定环境下人们解决某类重复出现问题的一套成功或有效的解决方案（A pattern is a successful or efficient solution to a recurring problem within a context）。</p><p><code>设计模式（Design Pattern）</code> 是一套被反复使用的、多数人知晓的、经过分类编目的、代码设计经验的总结，使用设计模式是为了可重用代码、让代码更容易被他人理解并且保证代码可靠性。</p><p><code>设计模式</code> 一般包含 <strong>模式名称</strong>、<strong>问题</strong>、<strong>目的</strong>、<strong>解决方案</strong>、<strong>效果</strong> 等组成要素，其中关键要素是 <strong>模式名称</strong>、<strong>问题</strong>、<strong>解决方案</strong> 和 <strong>效果</strong>。</p><blockquote><p><code>模式名称（Pattern name）</code>：通过一两个词来为模式命名，以便我们更好地理解模式并方便开发人员之间的交流，绝大多数模式都是根据其功能或模式结构来命名的。</p></blockquote><blockquote><p><code>问题（Problem）</code>：描述了应该在何时使用模式，它包含了设计中存在的问题以及问题存在的原因。</p></blockquote><blockquote><p><code>解决方案（Solution）</code>：描述了一个设计模式的组成部分，以及这些组成部分之间的相互关系、各自的职责和协作方式，通常解决方案通过 UML 类图和核心代码进行描述。</p></blockquote><blockquote><p><code>效果（Consequence）</code>：描述了模式的优缺点以及在使用模式时应权衡的问题。</p></blockquote><h3 id="2-设计模式分类"><a href="#2-设计模式分类" class="headerlink" title="2. 设计模式分类"></a>2. 设计模式分类</h3><p>根据设计模式的用途，设计模式可分为 <strong>创建型（Creational）</strong>、<strong>结构型（Structural）</strong> 和 <strong>行为型（Behavioral）</strong> 三种。</p><p><code>创建型模式</code> 主要用于描述如何创建对象；</p><p><code>结构型模式</code> 主要用于描述如何实现类或对象的组合；</p><p><code>行为型模式</code> 主要用于描述类或对象怎样交互以及怎样分配职责；</p><h4 id="2-1-创建型模式（Creational-Pattern）"><a href="#2-1-创建型模式（Creational-Pattern）" class="headerlink" title="2.1 创建型模式（Creational Pattern）"></a>2.1 创建型模式（Creational Pattern）</h4><table><thead><tr><th align="left">模式名称</th><th align="left">学习难度</th><th align="left">使用频率</th></tr></thead><tbody><tr><td align="left"><a href="https://walkerdenial.com/2017/02/15/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/">单例模式（Singleton Pattern）</a></td><td align="left">✨</td><td align="left">✨✨✨✨</td></tr><tr><td align="left"><a href="https://walkerdenial.com/2017/02/15/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E7%AE%80%E5%8D%95%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/">简单工厂模式（Simple Factory Pattern）</a></td><td align="left">✨✨</td><td align="left">✨✨✨</td></tr><tr><td align="left"><a href="https://walkerdenial.com/2017/02/15/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F/">工厂方法模式（Factory Method Pattern）</a></td><td align="left">✨✨</td><td align="left">✨✨✨✨✨</td></tr><tr><td align="left"><a href="https://walkerdenial.com/2017/02/15/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/">抽象工厂模式（Abstract Factory Pattern）</a></td><td align="left">✨✨✨✨</td><td align="left">✨✨✨✨✨</td></tr><tr><td align="left"><a href="https://walkerdenial.com/2017/02/16/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F/">原型模式（Prototype Pattern）</a></td><td align="left">✨✨✨</td><td align="left">✨✨✨</td></tr><tr><td align="left"><a href="https://walkerdenial.com/2017/02/17/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F/">建造者模式（Builder Pattern）</a></td><td align="left">✨✨✨✨</td><td align="left">✨✨</td></tr></tbody></table><h4 id="2-2-结构型模式（Structural-Pattern）"><a href="#2-2-结构型模式（Structural-Pattern）" class="headerlink" title="2.2 结构型模式（Structural Pattern）"></a>2.2 结构型模式（Structural Pattern）</h4><table><thead><tr><th align="left">模式名称</th><th align="left">学习难度</th><th align="left">使用频率</th></tr></thead><tbody><tr><td align="left"><a href="https://walkerdenial.com/2017/02/20/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F/">适配器模式（Adapter Pattern）</a></td><td align="left">✨✨</td><td align="left">✨✨✨✨</td></tr><tr><td align="left"><a href="https://walkerdenial.com/2017/02/21/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E6%A1%A5%E6%8E%A5%E6%A8%A1%E5%BC%8F/">桥接模式（Bridge Pattern）</a></td><td align="left">✨✨✨</td><td align="left">✨✨✨</td></tr><tr><td align="left"><a href="https://walkerdenial.com/2017/02/23/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F/">组合模式（Composite Pattern）</a></td><td align="left">✨✨✨</td><td align="left">✨✨✨✨</td></tr><tr><td align="left"><a href="https://walkerdenial.com/2017/02/23/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%A3%85%E9%A5%B0%E6%A8%A1%E5%BC%8F/">装饰模式（Decorator Pattern）</a></td><td align="left">✨✨✨</td><td align="left">✨✨✨</td></tr><tr><td align="left"><a href="https://walkerdenial.com/2017/02/24/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%A4%96%E8%A7%82%E6%A8%A1%E5%BC%8F/">外观模式（Facade Pattern）</a></td><td align="left">✨</td><td align="left">✨✨✨✨✨</td></tr><tr><td align="left"><a href="https://walkerdenial.com/2017/02/24/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E4%BA%AB%E5%85%83%E6%A8%A1%E5%BC%8F/">享元模式（Flyweight Pattern）</a></td><td align="left">✨✨✨✨</td><td align="left">✨</td></tr><tr><td align="left"><a href="https://walkerdenial.com/2017/02/24/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/">代理模式（Proxy Pattern）</a></td><td align="left">✨✨✨</td><td align="left">✨✨✨✨</td></tr></tbody></table><h4 id="2-3-行为型模式（Behavioral-Pattern）"><a href="#2-3-行为型模式（Behavioral-Pattern）" class="headerlink" title="2.3 行为型模式（Behavioral Pattern）"></a>2.3 行为型模式（Behavioral Pattern）</h4><table><thead><tr><th align="left">模式名称</th><th align="left">学习难度</th><th align="left">使用频率</th></tr></thead><tbody><tr><td align="left"><a href="https://walkerdenial.com/2017/02/27/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%81%8C%E8%B4%A3%E9%93%BE%E6%A8%A1%E5%BC%8F/">职责链模式（Chain of Responsibility Pattern）</a></td><td align="left">✨✨✨</td><td align="left">✨✨</td></tr><tr><td align="left"><a href="https://walkerdenial.com/2017/02/27/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%91%BD%E4%BB%A4%E6%A8%A1%E5%BC%8F/">命令模式（Command Pattern）</a></td><td align="left">✨✨✨</td><td align="left">✨✨✨✨</td></tr><tr><td align="left"><a href="https://walkerdenial.com/2017/02/27/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%A7%A3%E9%87%8A%E5%99%A8%E6%A8%A1%E5%BC%8F/">解释器模式（Interpreter Pattern）</a></td><td align="left">✨✨✨✨✨</td><td align="left">✨</td></tr><tr><td align="left"><a href="https://walkerdenial.com/2017/02/27/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%BF%AD%E4%BB%A3%E5%99%A8%E6%A8%A1%E5%BC%8F/">迭代器模式（Iterator Pattern）</a></td><td align="left">✨✨✨</td><td align="left">✨✨✨✨✨</td></tr><tr><td align="left"><a href="https://walkerdenial.com/2017/02/28/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E4%B8%AD%E4%BB%8B%E8%80%85%E6%A8%A1%E5%BC%8F/">中介者模式（Mediator Pattern）</a></td><td align="left">✨✨✨</td><td align="left">✨✨</td></tr><tr><td align="left"><a href="https://walkerdenial.com/2017/03/01/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%A4%87%E5%BF%98%E5%BD%95%E6%A8%A1%E5%BC%8F/">备忘录模式（Memento Pattern）</a></td><td align="left">✨✨</td><td align="left">✨✨</td></tr><tr><td align="left"><a href="https://walkerdenial.com/2017/03/01/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/">观察者模式（Observer Pattern）</a></td><td align="left">✨✨✨</td><td align="left">✨✨✨✨✨</td></tr><tr><td align="left"><a href="https://walkerdenial.com/2017/03/01/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E7%8A%B6%E6%80%81%E6%A8%A1%E5%BC%8F/">状态模式（State Pattern）</a></td><td align="left">✨✨✨</td><td align="left">✨✨✨</td></tr><tr><td align="left"><a href="https://walkerdenial.com/2017/03/01/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/">策略模式（Strategy Pattern）</a></td><td align="left">✨</td><td align="left">✨✨✨✨</td></tr><tr><td align="left"><a href="https://walkerdenial.com/2017/03/02/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F/">模板方法模式（Template Method Pattern）</a></td><td align="left">✨✨</td><td align="left">✨✨✨</td></tr><tr><td align="left"><a href="https://walkerdenial.com/2017/03/02/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BF%E9%97%AE%E8%80%85%E6%A8%A1%E5%BC%8F/">访问者模式（Visitor Pattern）</a></td><td align="left">✨✨✨✨</td><td align="left">✨</td></tr></tbody></table><h3 id="3-设计模式用途"><a href="#3-设计模式用途" class="headerlink" title="3. 设计模式用途"></a>3. 设计模式用途</h3><ol><li>可以避免做一些重复性的工作，有助于提高设计和开发效率；</li><li>提供了一套通用的设计词汇和一种通用的形式来方便开发人员之间的交流和沟通，使得设计方案更加通熟易懂；</li><li>使开发人员可以更好地重用一些已有的设计方案、功能模块甚至一个完整的软件系统，避免经常做一些重复的设计、编写一些重复的代码；</li><li>有助于别人更快地理解系统；</li><li>有助于深入地理解面向对象思想；</li></ol>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 概述 </tag>
            
            <tag> 模式 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
    
    
    <entry>
      <title>About me</title>
      <link href="/about/index.html"/>
      <url>/about/index.html</url>
      
        <content type="html"><![CDATA[<p>Name : Walker Denial</p><p>Email : <a href="mailto:&#x57;&#97;&#x6c;&#107;&#101;&#114;&#68;&#101;&#110;&#105;&#97;&#108;&#64;&#113;&#113;&#x2e;&#99;&#x6f;&#109;">&#x57;&#97;&#x6c;&#107;&#101;&#114;&#68;&#101;&#110;&#105;&#97;&#108;&#64;&#113;&#113;&#x2e;&#99;&#x6f;&#109;</a></p><p>Address : ShangHai</p><p>Desciption : Life will be better!</p>]]></content>
      
    </entry>
    
    
  
</search>
