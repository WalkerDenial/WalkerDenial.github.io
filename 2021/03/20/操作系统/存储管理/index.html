<!DOCTYPE html>
<html lang="">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
  
  <meta name="keywords" content="Walker Denial">
  <meta name="description" content="This is Walker Denial&#39;s blog!">
  
  <title>Walker Denial</title>
  
    <!-- stylesheets list from config.yml -->
    
      <link rel="stylesheet" href="/css/materialize.min.css">
    
      <link rel="stylesheet" href="/css/main.min.css">
    
  
  <style type="text/css">
      html{
          font-family: sans-serif;
          font-weight: 300;
      }
      @font-face {
          font-family: 'Material Icons';
          font-style: normal;
          font-weight: 400;
          src: url(/fonts/MaterialIcons-Regular.eot);
          src: url(/fonts/MaterialIcons-Regular.woff2) format('woff2'),
          url(/fonts/MaterialIcons-Regular.woff) format('woff'),
          url(/fonts/MaterialIcons-Regular.ttf) format('truetype')
      }
  </style>
<meta name="generator" content="Hexo 7.0.0-rc2"><link rel="stylesheet" href="/css/prism.css" type="text/css">
<link rel="stylesheet" href="/css/prism-line-numbers.css" type="text/css"></head>
<body>
<div id="menu-box"><a href="javascript:void(0)" id="menu" data-activates="slide-out" class="button-collapse menu" ><span class="nav-btn"></span></a></div>
<div id="menu-outer">
  <div id="menu-inner">
      <ul id="slide-out" class="side-nav" >
    <div class="nav-header"  style="background-image: url(/images/header-bg.png);background-color:#26A69A">
    <div class="header-box"><img src="/images/profile.png" ondragstart="return false;"></div>
    <p>Walker Denial</p>
    <div class="nav-link">
        
        <a href="https://twitter.com/WalkerDenial" target="_blank"> <div class="link-box twitter"></div></a>
        
        
        <a  href="https://github.com/WalkerDenial" target="_blank"><div class="link-box github"></div></a>
        
        
        <a href="mailto:mailto:WalkerDenial@gmail.com"><div class="link-box email"></div></a>
        
        
        <a href="http://weibo.com/u/3213135930" target="_blank"><div class="link-box weibo"></div></a>
        
        
        <a href="https://www.zhihu.com/people/walkerdenial/activities" target="_blank"> <div class="link-box zhihu"></div></a>
        
    </div>
    <div class="nav-search">
        <form id="search-form"> <!-- 搜索框相关 -->
            <input type="text" id="local-search-input" name="q" results="0" placeholder="搜索..." class="search form-control" autocomplete="off" autocorrect="off"/>
            <div class="nav-search-img"><i class="material-icons">search</i></div>
        </form>
        <div id="local-search-result"></div> <!-- 搜索结果区 -->
        <p class='no-result'>无搜索结果</p>
    </div>
</div>
    <!--Homepage-->

<li class="nav-list">
    <a href="/" target="_self">
        <div class="nav-ico"><i class="material-icons">home</i> </div><p>主页</p>
    </a>
</li>

<!--archives-->

<li class="nav-list dropdown-btn">
    <a  class=""  target="_self">
        <div class="nav-ico"><i class="material-icons">assignment</i></div><p>归档</p><div class="dropdown-ico"><i class="material-icons">arrow_drop_down</i></div>
    </a>
</li>

<ul class="dropdown-menu dropdown" >
    <li class="nav-dropdown-list">
        <a class="archive-link" href="/archives/2022/06/">June 2022<span class="archive-count">1</span></a></li><li class="nav-dropdown-list"><a class="archive-link" href="/archives/2022/05/">May 2022<span class="archive-count">1</span></a></li><li class="nav-dropdown-list"><a class="archive-link" href="/archives/2022/04/">April 2022<span class="archive-count">4</span></a></li><li class="nav-dropdown-list"><a class="archive-link" href="/archives/2022/03/">March 2022<span class="archive-count">2</span></a></li><li class="nav-dropdown-list"><a class="archive-link" href="/archives/2021/12/">December 2021<span class="archive-count">3</span></a></li><li class="nav-dropdown-list"><a class="archive-link" href="/archives/2021/11/">November 2021<span class="archive-count">1</span></a></li><li class="nav-dropdown-list"><a class="archive-link" href="/archives/2021/09/">September 2021<span class="archive-count">3</span></a></li><li class="nav-dropdown-list"><a class="archive-link" href="/archives/2021/08/">August 2021<span class="archive-count">3</span></a></li><li class="nav-dropdown-list"><a class="archive-link" href="/archives/2021/04/">April 2021<span class="archive-count">1</span></a></li><li class="nav-dropdown-list"><a class="archive-link" href="/archives/2021/03/">March 2021<span class="archive-count">12</span></a></li><li class="nav-dropdown-list"><a class="archive-link" href="/archives/2021/02/">February 2021<span class="archive-count">2</span></a></li><li class="nav-dropdown-list"><a class="archive-link" href="/archives/2021/01/">January 2021<span class="archive-count">6</span></a></li><li class="nav-dropdown-list"><a class="archive-link" href="/archives/2020/12/">December 2020<span class="archive-count">5</span></a></li><li class="nav-dropdown-list"><a class="archive-link" href="/archives/2020/11/">November 2020<span class="archive-count">6</span></a></li><li class="nav-dropdown-list"><a class="archive-link" href="/archives/2020/04/">April 2020<span class="archive-count">2</span></a></li><li class="nav-dropdown-list"><a class="archive-link" href="/archives/2018/01/">January 2018<span class="archive-count">2</span></a></li><li class="nav-dropdown-list"><a class="archive-link" href="/archives/2017/12/">December 2017<span class="archive-count">1</span></a></li><li class="nav-dropdown-list"><a class="archive-link" href="/archives/2017/11/">November 2017<span class="archive-count">6</span></a></li><li class="nav-dropdown-list"><a class="archive-link" href="/archives/2017/08/">August 2017<span class="archive-count">1</span></a></li><li class="nav-dropdown-list"><a class="archive-link" href="/archives/2017/07/">July 2017<span class="archive-count">1</span></a></li><li class="nav-dropdown-list"><a class="archive-link" href="/archives/2017/03/">March 2017<span class="archive-count">6</span></a></li><li class="nav-dropdown-list"><a class="archive-link" href="/archives/2017/02/">February 2017<span class="archive-count">20</span></a></li><li class="nav-dropdown-list"><a class="archive-link" href="/archives/2017/01/">January 2017<span class="archive-count">2</span></a>
    </li>
</ul>
<!--categories-->

<li class="nav-list dropdown-btn">
    <a   class=""  target="_self">
        <div class="nav-ico"><i class="material-icons">dashboard</i></div><p>分类</p><div class="dropdown-ico"><i class="material-icons">arrow_drop_down</i></div>
    </a>
</li>

<ul class="dropdown-menu dropdown" >
    <li class="nav-dropdown-list">
        <a class="category-link" href="/categories/Algorithm/">Algorithm<span class="category-count">1</span></a></li><li class="nav-dropdown-list"><a class="category-link" href="/categories/ES6/">ES6<span class="category-count">2</span></a></li><li class="nav-dropdown-list"><a class="category-link" href="/categories/Flutter/">Flutter<span class="category-count">7</span></a></li><li class="nav-dropdown-list"><a class="category-link" href="/categories/Gradle/">Gradle<span class="category-count">2</span></a></li><li class="nav-dropdown-list"><a class="category-link" href="/categories/Java/">Java<span class="category-count">6</span></a></li><li class="nav-dropdown-list"><a class="category-link" href="/categories/Kotlin/">Kotlin<span class="category-count">4</span></a></li><li class="nav-dropdown-list"><a class="category-link" href="/categories/RPC/">RPC<span class="category-count">3</span></a></li><li class="nav-dropdown-list"><a class="category-link" href="/categories/UML/">UML<span class="category-count">1</span></a></li><li class="nav-dropdown-list"><a class="category-link" href="/categories/%E5%85%B6%E4%BB%96/">其他<span class="category-count">2</span></a></li><li class="nav-dropdown-list"><a class="category-link" href="/categories/%E5%86%99%E4%BD%9C/">写作<span class="category-count">1</span></a></li><li class="nav-dropdown-list"><a class="category-link" href="/categories/%E5%89%8D%E7%AB%AF/">前端<span class="category-count">10</span></a></li><li class="nav-dropdown-list"><a class="category-link" href="/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">操作系统<span class="category-count">7</span></a></li><li class="nav-dropdown-list"><a class="category-link" href="/categories/%E8%87%AA%E5%AD%A6/">自学<span class="category-count">9</span></a></li><li class="nav-dropdown-list"><a class="category-link" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84/">计算机系统结构<span class="category-count">7</span></a></li><li class="nav-dropdown-list"><a class="category-link" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">计算机网络<span class="category-count">2</span></a></li><li class="nav-dropdown-list"><a class="category-link" href="/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/">设计模式<span class="category-count">27</span></a>
    </li>
</ul>
<!--tags-->

<li class="nav-list">
    <a href="/archives" target="_self">
        <div class="nav-ico"><i class="material-icons">bookmark</i> </div><p>标签</p>
    </a>
</li>

<!--photo-->

<!--friends-->

<!--about-->

<li class="nav-list">
    <a href="/about" target="_self">
        <div class="nav-ico"><i class="material-icons">copyright</i> </div><p>关于</p>
    </a>
</li>


</ul>

  </div>
</div>

<div id="content-outer">
  <div id="content-inner">
    
<article id="post">
  <div class="post-page-title"  style="background-color:#26A69A;background-image:url(/images/random/vateral-14.png)" >
  <h2>存储管理</h2>
    
  <p>作者 : Walker Denial &nbsp&nbsp 发布于 : <time datetime="2021-03-19T16:06:00.000Z">
          2021-03-20
    </time>
  </p>
    
  </div>
  <div class="post-page-content">
  <p>计算机系统中的存储器可以分成两类：<strong>内存储器（简称内存）</strong>和 <strong>外存储器（简称外存）</strong>。处理器可以直接访问内存，但不能直接访问外存。处理器要通过启动相应的输入&#x2F;输出设备后才能使外存与内存交换信息。</p>
<p><img src="https://personal-blog.oss-cn-hangzhou.aliyuncs.com/OS_chapter_6.png"></p>
<h1 id="1-存储管理的任务"><a href="#1-存储管理的任务" class="headerlink" title="1 存储管理的任务"></a>1 存储管理的任务</h1><p>在计算机系统中，存储器是处理器处理的信息的来源于归宿，占据着重要地位。到目前为止，最先进的计算机科学技术能够提供的存储设备的速度，仍然明显地慢于同级别的中央处理器的速度。而且由于成本等方面的原因，任何一种存储设备都无法在速度上与容量两个方面同时满足用户的需求。</p>
<h2 id="1-1-内存空间的划分"><a href="#1-1-内存空间的划分" class="headerlink" title="1.1 内存空间的划分"></a>1.1 内存空间的划分</h2><p><img src="https://personal-blog.oss-cn-hangzhou.aliyuncs.com/OS_storage_system.png"></p>
<p>快速存储设备和大容量存储设备必须构成为统一的整体，由操作系统协调这些存储器的使用。对于内存速度和容量的要求是，内存的直接存取速度尽量快到与处理器存取速度相匹配，其容量大道能装下当前运行的程序与数据，否则处理器执行速度就会受到内存速度和容量的影响而得不到充分发挥。各种速度和容量的存储器硬件，在操作系统协调之下形成了一种存储器层次结构，或称存储体系。</p>
<h2 id="1-2-内存空间的分配和回收"><a href="#1-2-内存空间的分配和回收" class="headerlink" title="1.2 内存空间的分配和回收"></a>1.2 内存空间的分配和回收</h2><p>内存空间一般分为两部分：</p>
<ol>
<li>系统区，用以存储操作系统常驻内存部分，用户不能占用这部分空间；</li>
<li>用户区，分配给用户使用，用于装入并存储用户程序和数据，这部分的信息随时都在发生变化；</li>
</ol>
<p>存储管理实质上就是管理供用户使用的那部分空间。</p>
<p>内存管理问题主要包括：</p>
<ol>
<li>内存管理方法</li>
<li>内存的分配和释放算法；</li>
<li>虚拟存储器的管理；</li>
<li>控制内存和外存之间的数据流动方法；</li>
<li>地址变换技术；</li>
<li>内存数据保护与共享技术等；</li>
</ol>
<p>内存分配有两种方式：</p>
<ol>
<li>静态分配：程序要求的内存空间是在目标模块连接装入内存时确定并分配的，并且在程序运行过程中不允许再申请或在内存中「搬家」，即分配工作是在程序运行前一次性完成；</li>
<li>动态分配：程序要求的基本内存空间是在目标模块装入时确定并分配的，但是在程序运行过程中允许申请附加的内存空间或在内存中「搬家」，即分配工作可以再程序运行前及运行过程中逐步完成；</li>
</ol>
<p>一个有效的存储分配机制，应对用户提出的需求予以快速响应，为之分配相应的存储空间，在用户程序不再需要它时及时回收，以供其他用户使用。为此，应该具有以下功能：</p>
<ol>
<li>记住每个存储区域的状态。内存空间哪些是分配了的，哪些是空闲的？这就需要设置相应的分配表格，记录内存空间使用状态；</li>
<li>实施分配。当用户提出申请时，按需要进行分配，并修改相应的分配表格。分配方式有静态分配和动态分配两种；</li>
<li>回收。接收用户释放的区域，并修改相应的分配表格；</li>
</ol>
<h2 id="1-3-存储保护问题"><a href="#1-3-存储保护问题" class="headerlink" title="1.3 存储保护问题"></a>1.3 存储保护问题</h2><p>存储保护的目的在于为多个程序共享内存提供保障，使在内存中的各道程序，只能访问它自己的区域，避免各道程序间相互干扰。特别是当一道程序发生错误时，不至于影响其他程序的运行，更要防止破坏系统程序。存储保护通常需要有硬件支持，并由软件配合实现。</p>
<p>存储保护的内容包括：</p>
<ol>
<li>保护系统程序区不被用户有意或无意的侵犯；</li>
<li>不允许用户程序读写不属于自己地址空间的数据，如系统区地址空间、其他用户程序的地址空间；</li>
</ol>
<h2 id="1-4-存储共享"><a href="#1-4-存储共享" class="headerlink" title="1.4 存储共享"></a>1.4 存储共享</h2><p>所谓的存储共享是指两个或多个进程公用内存中相同区域，这样不仅能使多道程序动态地共享内存，提高内存利用率，而且还能共享内存中某个区域的信息。共享的内容包括代码共享和数据共享，特别是代码共享要求代码必须是纯代码。</p>
<p>存储共享的一个目的是通过代码共享节省内存空间，提高内存利用率；另一个目的是通过数据共享实现进程通信。</p>
<h2 id="1-5-地址转换、地址重定位"><a href="#1-5-地址转换、地址重定位" class="headerlink" title="1.5 地址转换、地址重定位"></a>1.5 地址转换、地址重定位</h2><p>当用户程序进入计算机系统请求执行时，存储管理要为它分配合适的内存空间，这个分配到的内存空间可能是从某单元开始的一组连续的地址空间。该地址空间的起始地址是不固定的，而且逻辑地址与分到的内存空间的绝对地址经常不一致。因此，每个逻辑地址再内存中也没有一个固定的绝对地址与之对应。程序执行时不能按照其逻辑地址到内存中存取信息，处理器必须按照实际地址去访问内存才能保证程序的正确执行。</p>
<p>为了保证程序的正确执行，必须根据分配给程序的内存区域对程序中指令和数据的存储地址进行重定位，即要把逻辑地址转换成绝对地址。</p>
<p>包逻辑地址转换成绝对地址的工作称「地址重定位」或「地址转换」，又称「地址映射」。重定位的方式可以有「静态重定位」和「动态重定位」两种。</p>
<h3 id="1-5-1-静态重定位"><a href="#1-5-1-静态重定位" class="headerlink" title="1.5.1 静态重定位"></a>1.5.1 静态重定位</h3><p>内存在装入一个程序时，要把程序中的指令地址和数据地址全部转换成绝对地址。由于地址转换工作时在程序开始执行前集中完成的，所以在程序执行过程中就无须再进行地址转换工作，这种地址转换方式称「静态重定位」。</p>
<h3 id="1-5-2-动态重定位"><a href="#1-5-2-动态重定位" class="headerlink" title="1.5.2 动态重定位"></a>1.5.2 动态重定位</h3><p>内存在装入程序时，不进行地址转换，而是直接把程序装入到分配的内存区域中。在程序执行过程中，每当执行一条指令时都由硬件的地址转换机构将指令中的逻辑地址转换成绝对地址。这种方式的地址转换是在程序执行时动态完成的，故称为「动态重定位」。</p>
<h1 id="2-可变分区存储管理方案"><a href="#2-可变分区存储管理方案" class="headerlink" title="2 可变分区存储管理方案"></a>2 可变分区存储管理方案</h1><h2 id="2-1-可变分区管理基本工作原理"><a href="#2-1-可变分区管理基本工作原理" class="headerlink" title="2.1 可变分区管理基本工作原理"></a>2.1 可变分区管理基本工作原理</h2><p>可变分区是指系统不预先划分固定分区，而是在装入程序时划分内存分区，使为程序分配的分区的大小正好等于该程序的需求量，且分区的个数是可变的。显然，可变分区有较大的灵活性，较之固定分区能获得较好的内存利用率。</p>
<h2 id="2-2-内存分配表"><a href="#2-2-内存分配表" class="headerlink" title="2.2 内存分配表"></a>2.2 内存分配表</h2><p>用于固定分区管理的内存分配表是一张分区说明表，按顺序每个分区在分区说明表中对应一个表目。表目内容包括分区序号、分区大小、分区起始地址以及使用状态（空闲或占用）。一个程序在运行时，先要根据其对内存的需求量，按一定的分配策略在分区说明表中查找空闲分区。若能找到合乎需要的分区，就将该分区分配给程序，并将该分区置为占用状态。当程序完成时释放这块分区内存，由系统回收，并在分区说明表中将回收的分区重新置为空闲状态。</p>
<p>内存分配表由两张表格组成。一个是已分配区表，记录已装入的程序在内存中占用分区的起始地址和长度，用标志位指出占用分区的程序名。另一个是空闲表，记录内存中可供分配的空闲区的起始地址和长度，用标志位指出该分区是未分配的空闲区。由于已占分区和空闲区的个数不定，因此，两张表格中都应设置适当的空栏目，分别用以登记新内存分配表。</p>
<h2 id="2-3-内存分配与回收算法"><a href="#2-3-内存分配与回收算法" class="headerlink" title="2.3 内存分配与回收算法"></a>2.3 内存分配与回收算法</h2><p>常用的分配算法：</p>
<ol>
<li>最先适应算法：最先适应算法，又称顺序分配算法，当接到内存申请时，顺序查找分区说明表，找到第一个满足申请长度的空闲区，将其分割并分配；</li>
<li>最优适应算法：当接到内存申请时，查找分区说明表，找到第一个能满足申请长度的最小空闲区，将其分割并分配；</li>
<li>最坏适应算法：当接到内存申请时，查找分区说明表，找到能满足申请要求的最大空闲区；</li>
</ol>
<h2 id="2-4-紧缩技术"><a href="#2-4-紧缩技术" class="headerlink" title="2.4 紧缩技术"></a>2.4 紧缩技术</h2><p>解决碎片问题的办法是在适当时刻警醒碎片整理，通过移动内存中的程序，把所有空闲碎片合并成一个连续的大空闲区且放在内存的一端，而把所有程序占用区放在内存的另一端，这一技术成为「紧缩技术」，或「压缩技术」。</p>
<p>紧缩技术可以集中分散的空闲区，提高内存的利用率，便于进程动态扩充内存。采用紧缩技术要注意以下问题：</p>
<ol>
<li>紧缩技术会增加系统的开销；</li>
<li>移动是有条件的；</li>
</ol>
<h1 id="3-覆盖技术和交换技术"><a href="#3-覆盖技术和交换技术" class="headerlink" title="3 覆盖技术和交换技术"></a>3 覆盖技术和交换技术</h1><h2 id="3-1-覆盖技术"><a href="#3-1-覆盖技术" class="headerlink" title="3.1 覆盖技术"></a>3.1 覆盖技术</h2><p>覆盖技术是指一个程序的若干程序段，或几个程序的某些部分共享某一个存储空间。覆盖技术的实现时把程序划分为若干个功能上相对独立的程序段，按照其自身的逻辑结构使那些不会同时执行的程序段共享同一块内存区域。未执行的程序段先保存在磁盘上，当有关程序段的前一部分执行结束后，把后续程序段调入内存，覆盖前面的程序段。</p>
<p>覆盖技术不需要任何来自操作系统的特殊支持，可以完全由用户实现，即覆盖技术是用户程序自己附加的控制。覆盖技术要求程序员提供一个清楚的覆盖结构，即程序员要把一个程序划分成不同的程序段，并规定好它们的执行和覆盖的顺序。操作系统则根据程序员提供的覆盖结构，完成程序段之间的覆盖。</p>
<p>覆盖技术可以由编译程序提供支持。此时被覆盖的块是由程序员或编译程序预先（在执行前）确定的。总之，覆盖可以从用户级彻底解决内存小装不下程序的问题。</p>
<h2 id="3-2-交换技术"><a href="#3-2-交换技术" class="headerlink" title="3.2 交换技术"></a>3.2 交换技术</h2><p>交换技术又称对换技术。在分时系统中，用户的进程比内存能容纳的数量要多，这就需要在磁盘上保存那些内存放不下的进程。在需要运行这些进程时，再将它们装入内存。</p>
<p>进程从内存移到磁盘，并再移回内存称为交换。</p>
<p>交换技术是进程在内存与外存之间的动态调度，是由操作系统控制的。系统可以将那些不在运行中的进程或其一部分调出内存，暂时存储在外存上的一个后备存储区（称为盘交换区）中，以腾出内存空间给现在需要内存空间的进程，后者可能需要从外存换入内存，以后再降换出的进程调入内存继续执行。</p>
<p>交换技术的目的是尽可能达到「足够快地交换进程，以使当处理器调度程序想重新调度处理器时，总有进程在内存中处于就绪（准备执行）状态」的理想状态，从而提高内存利用率。</p>
<h1 id="4-虚拟页式存储管理方案"><a href="#4-虚拟页式存储管理方案" class="headerlink" title="4 虚拟页式存储管理方案"></a>4 虚拟页式存储管理方案</h1><p>虚拟存储管理是由操作系统在硬件支持下把两级存储器（内存和外存）统一实施管理，达到「扩充」内存的目的，呈现给用户的是一个远远大于内存容量的编程空间，即虚存。程序、数据、堆栈的大小可以超过内存的大小，操作系统把程序当前使用的部分保留在内存，而把其他部分保存在磁盘上，并在需要时在内存和磁盘之间动态交换。虚拟存储管理支持多道程序设计技术。</p>
<h2 id="4-1-虚拟地址空间和虚拟地址"><a href="#4-1-虚拟地址空间和虚拟地址" class="headerlink" title="4.1 虚拟地址空间和虚拟地址"></a>4.1 虚拟地址空间和虚拟地址</h2><p>存储管理部件首先把内存分成大小相等的许多区，把每个区称为「物理页面」，物理页面是进程内存空间分配的物理单位。同时，要求程序中的逻辑地址也进行分页，页的大小与物理页面的大小一致。</p>
<p>此时「逻辑地址」可被称为虚拟地址。</p>
<p>这样，就可把程序信息按页存放到物理页面中。于是，页式存储器提供编程使用的虚拟地址由两部分组成：虚拟页号和页内地址。</p>
<h2 id="4-2-页表的作用和页表项的内容"><a href="#4-2-页表的作用和页表项的内容" class="headerlink" title="4.2 页表的作用和页表项的内容"></a>4.2 页表的作用和页表项的内容</h2><p>页式存储管理要有硬件的地址转换机构作支持。同时，要为每个被装入内存的进程提供一张页表。该页表所在内存的起始地址和长度作为现场信息存储在该进程的进程控制块中。一旦进程被调度进入处理器执行，这些信息将被作为恢复现场信息送入系统的地址映射机制中的寄存器里。</p>
<p>页表指出该程序虚拟地址中的页号与所占用的物理页面号之间的对应关系。页表的长度有程序拥有的页面数而定，故每个程序的页表长度可能是不同的。</p>
<p>页表又是硬件进行地址转换的依据，每执行一条指令时按虚拟地址中的页号查页表。若页表中无此页号，则产生一个「地址错」的程序性中断事件。若页表中有此页号，则可得到对应的物理页面号，按计算公式可转换成访问的内存的物理地址。</p>
<p>物理地址的计算公式为：<center>物理地址 &#x3D; 物理页面号 x 块长 + 页内地址</center></p>
<p>物理页面号又称为页帧和页框号。</p>
<p>在虚拟也是存储管理中，页表项的设计如下：</p>
<ol>
<li>物理页面号：页面在内存中时所对应的物理页面号；</li>
<li>有效位：又称驻留位、存在位，表示该页是在内存还是在磁盘；</li>
<li>访问位：访问位表示该页在内存期间是否被访问过；</li>
<li>修改位：修改位表示该页在内存中是否被修改过；</li>
<li>保护位：是否能读&#x2F;写；</li>
</ol>
<p>其中，访问位和修改位可以用来决定置换哪个页面，具体由页面置换算法决定。</p>
<h2 id="4-3-地址转换过程与-TLB"><a href="#4-3-地址转换过程与-TLB" class="headerlink" title="4.3 地址转换过程与 TLB"></a>4.3 地址转换过程与 TLB</h2><p>一般而言，页式存储管理中的页表是存储在内存中的。于是，当要按给定的虚拟地址进行读写时，必须访问两次内存。第一次按页号读出页表中对应的块号，第二次按计算出来的绝对地址进行读写。两次访问内存显然延长了指令的执行周期，降低了执行速度。</p>
<p>为了提高存取速度，有两种方法：</p>
<ol>
<li>在地址映射机制中增加一组告诉寄存器保存页表，这需要大量的硬件开销，在经济上不可行；</li>
<li>在地址映射机制中增加一个小容量的联想寄存器（相连寄存器），它由高速缓冲存储器组成；</li>
</ol>
<p>利用高速缓冲存储器存储当前访问最频繁的少数活动页面的页号，这个高速缓冲存储器称为「转换检测缓冲区」（Translation Lookaside Buffer，TLB）。</p>
<p>TLB 中登记了页表中的一部分页号与物理页面号的对应关系。根据程序的存储访问局部性原理，在一段时间内总是经常访问少数几页，若所这些页等级在 TLB 中，显然可快速查找并提高指令执行速度。</p>
<p>TLB 内容的更新原理如下：当某一用户程序需要存取数据时，根据该数据所在的逻辑页号在 TLB 中找出对应的物理页面号，然后拼接页内地址，以形成物理地址；如果在 TLB 中没有相应的逻辑页号，则地址映射仍然通过内存中的页表进行；在得到物理页面号后需将该块号填到 TLB 的空闲单元中；若 TLB 中没有空闲单元，则根据淘汰算法淘汰某一行，再填入新得到的页号和块号。</p>
<p>实际上，查找 TLB 和查找内存页表是并行进行的，一旦发现 TLB 中有与所查页号一致的逻辑页号就停止朝招内存页表，而直接利用 TLB 中的逻辑页号。</p>
<h2 id="4-4-缺页异常处理"><a href="#4-4-缺页异常处理" class="headerlink" title="4.4 缺页异常处理"></a>4.4 缺页异常处理</h2><p>若在页表中发现所要访问的页面不在内存，则产生缺页异常。当发生缺页异常时，操作系统必须在内存中选择一个页面将其移除内存，以便为即将调入的页面让出空间。如果要移走的页面在内存期间已经被修改过，就必须把它写会磁盘以更新该页在磁盘上的副本。如果该页没有被修改过，那么它在磁盘上的副本仍然是最新的，则不需要写回，调入的页直接覆盖被淘汰的页。</p>
<p>整个缺页处理过程简单阐述如下：</p>
<ol>
<li>根据当前执行指令中的逻辑地址查页表的有效位，判断该页是否在内存；</li>
<li>该页标志位「0」，形成缺页异常。保留线程，中断装置通过交换 PSW 让操作系统的中断处理程序占用处理器；</li>
<li>操作系统处理缺页异常，寻找一个空闲的页面；</li>
<li>若有空闲页，则把磁盘上读出的信息装入该页面中；</li>
<li>修改页表及内存分配表，表示该页已在内存；</li>
<li>如果内存中无空闲项，则按某种算法选择一个已在内存的页面，把它暂时调出内存。若在执行中该页面已被修改过，则要把该页信息重新写回到磁盘上，否则不必重新写回磁盘。当一页被暂时调出内存后，让出的内存空间用来存储当前需要使用的页面。页面被调出或装入之后都要对页表及内存分配表作修改；</li>
<li>恢复现场，重新执行被中断的指令。当重新执行该指令时，由于要访问的页面已被装入内存，所以可正常执行下去；</li>
</ol>
<h1 id="5-典型的页面置换算法"><a href="#5-典型的页面置换算法" class="headerlink" title="5 典型的页面置换算法"></a>5 典型的页面置换算法</h1><h2 id="5-1-最佳页面置换算法（OPT）"><a href="#5-1-最佳页面置换算法（OPT）" class="headerlink" title="5.1 最佳页面置换算法（OPT）"></a>5.1 最佳页面置换算法（OPT）</h2><p>OPT 算法淘汰以后不再需要的或者在最长时间以后才会用到的页面。这一算法一般不可能实现，但它可以作为衡量其他页面淘汰算法优劣的一个标准。</p>
<h2 id="5-2-先进先出算法（FIFO）"><a href="#5-2-先进先出算法（FIFO）" class="headerlink" title="5.2 先进先出算法（FIFO）"></a>5.2 先进先出算法（FIFO）</h2><p>总是选择最先装入内存的一页调出，或者说是把驻留在内存中时间最长的一页调出。</p>
<h2 id="5-3-第二次机会算法（Second-Chance）"><a href="#5-3-第二次机会算法（Second-Chance）" class="headerlink" title="5.3 第二次机会算法（Second Chance）"></a>5.3 第二次机会算法（Second Chance）</h2><p>检查进入内存时间最久页面的 R 位，如果是 0，那么这个页面既老又没有被使用，可以立刻置换掉；如果是 1，就将 R 位清 0，并把该页面放到链表的尾端，修改其进入时间，然后继续搜索。</p>
<p>这一算法称为第二次机会算法，其基本思想是寻找一个最佳的时钟间隔以来没有被访问过的页面。如果所有的页面都被访问过了，该算法就退化为 FIFO 算法。</p>
<h2 id="5-4-时钟算法（Clock）"><a href="#5-4-时钟算法（Clock）" class="headerlink" title="5.4 时钟算法（Clock）"></a>5.4 时钟算法（Clock）</h2><p>把所有的页面都保存在一个类似时钟面的环形链表中，一个表针指向最老的页面。当发生缺页时，算法首先检查表针指向的页面，如果它的 R 为是 0 就置换该页面，并把新的页面插入这个位置，然后把表针前移一个位置；如果 R 位是 1 就清除 R 位并把表针前移一个位置，重复这个过程直到找到了一个 R 位为 0 的页面为止。由于这个算法的工作方式，就将它称为时钟算法。</p>
<h2 id="5-5-最近最少使用算法（LRU）"><a href="#5-5-最近最少使用算法（LRU）" class="headerlink" title="5.5 最近最少使用算法（LRU）"></a>5.5 最近最少使用算法（LRU）</h2><p>在缺页发生时，首先淘汰掉最长时间未被使用过的页面。</p>
<h2 id="5-6-颠簸或抖动"><a href="#5-6-颠簸或抖动" class="headerlink" title="5.6 颠簸或抖动"></a>5.6 颠簸或抖动</h2><p>在虚存中，页面可能在内存与外存之间频繁地调度，有可能出现抖动或颠簸。点系统出现这一现象时，系统用于调度页面所需要的时间比进程实际运行所占用的时间还多，系统效率会急剧下降。</p>
<p>颠簸是由于缺页率高而引起的。例如，由于页面置换算法不合理，可能出现刚被淘汰出去的一页，又要被访问，因而又要把它调入的情况，如此反复，使整个西戎的页面调入调出工作非常频繁。</p>

  </div>
  <!--评论块-->
    

</article>
<nav class="post-nav">
  <!-- Prev Nav -->
    
  <a href="/2021/03/20/操作系统/文件系统/" id="post_nav-newer" class="post-nav-content prev-content">
      <上一篇
  </a>
    


  <!-- Next Nav -->
    
  <a href="/2021/03/19/操作系统/死锁/" id="post_nav-older" class="post-nav-content next-content">
      下一篇>
  </a>
    
</nav>
<div class="post-toc-btn"><i class="material-icons">format_list_numbered</i></div>
<div class="post-toc-none"><p>(无)</p></div>
<div class="post-toc-box">
    <ol class="post-toc"><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#1-%E5%AD%98%E5%82%A8%E7%AE%A1%E7%90%86%E7%9A%84%E4%BB%BB%E5%8A%A1"><span class="post-toc-text">1 存储管理的任务</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#1-1-%E5%86%85%E5%AD%98%E7%A9%BA%E9%97%B4%E7%9A%84%E5%88%92%E5%88%86"><span class="post-toc-text">1.1 内存空间的划分</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#1-2-%E5%86%85%E5%AD%98%E7%A9%BA%E9%97%B4%E7%9A%84%E5%88%86%E9%85%8D%E5%92%8C%E5%9B%9E%E6%94%B6"><span class="post-toc-text">1.2 内存空间的分配和回收</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#1-3-%E5%AD%98%E5%82%A8%E4%BF%9D%E6%8A%A4%E9%97%AE%E9%A2%98"><span class="post-toc-text">1.3 存储保护问题</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#1-4-%E5%AD%98%E5%82%A8%E5%85%B1%E4%BA%AB"><span class="post-toc-text">1.4 存储共享</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#1-5-%E5%9C%B0%E5%9D%80%E8%BD%AC%E6%8D%A2%E3%80%81%E5%9C%B0%E5%9D%80%E9%87%8D%E5%AE%9A%E4%BD%8D"><span class="post-toc-text">1.5 地址转换、地址重定位</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#1-5-1-%E9%9D%99%E6%80%81%E9%87%8D%E5%AE%9A%E4%BD%8D"><span class="post-toc-text">1.5.1 静态重定位</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#1-5-2-%E5%8A%A8%E6%80%81%E9%87%8D%E5%AE%9A%E4%BD%8D"><span class="post-toc-text">1.5.2 动态重定位</span></a></li></ol></li></ol></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#2-%E5%8F%AF%E5%8F%98%E5%88%86%E5%8C%BA%E5%AD%98%E5%82%A8%E7%AE%A1%E7%90%86%E6%96%B9%E6%A1%88"><span class="post-toc-text">2 可变分区存储管理方案</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#2-1-%E5%8F%AF%E5%8F%98%E5%88%86%E5%8C%BA%E7%AE%A1%E7%90%86%E5%9F%BA%E6%9C%AC%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86"><span class="post-toc-text">2.1 可变分区管理基本工作原理</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#2-2-%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E8%A1%A8"><span class="post-toc-text">2.2 内存分配表</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#2-3-%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E4%B8%8E%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95"><span class="post-toc-text">2.3 内存分配与回收算法</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#2-4-%E7%B4%A7%E7%BC%A9%E6%8A%80%E6%9C%AF"><span class="post-toc-text">2.4 紧缩技术</span></a></li></ol></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#3-%E8%A6%86%E7%9B%96%E6%8A%80%E6%9C%AF%E5%92%8C%E4%BA%A4%E6%8D%A2%E6%8A%80%E6%9C%AF"><span class="post-toc-text">3 覆盖技术和交换技术</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#3-1-%E8%A6%86%E7%9B%96%E6%8A%80%E6%9C%AF"><span class="post-toc-text">3.1 覆盖技术</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#3-2-%E4%BA%A4%E6%8D%A2%E6%8A%80%E6%9C%AF"><span class="post-toc-text">3.2 交换技术</span></a></li></ol></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#4-%E8%99%9A%E6%8B%9F%E9%A1%B5%E5%BC%8F%E5%AD%98%E5%82%A8%E7%AE%A1%E7%90%86%E6%96%B9%E6%A1%88"><span class="post-toc-text">4 虚拟页式存储管理方案</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#4-1-%E8%99%9A%E6%8B%9F%E5%9C%B0%E5%9D%80%E7%A9%BA%E9%97%B4%E5%92%8C%E8%99%9A%E6%8B%9F%E5%9C%B0%E5%9D%80"><span class="post-toc-text">4.1 虚拟地址空间和虚拟地址</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#4-2-%E9%A1%B5%E8%A1%A8%E7%9A%84%E4%BD%9C%E7%94%A8%E5%92%8C%E9%A1%B5%E8%A1%A8%E9%A1%B9%E7%9A%84%E5%86%85%E5%AE%B9"><span class="post-toc-text">4.2 页表的作用和页表项的内容</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#4-3-%E5%9C%B0%E5%9D%80%E8%BD%AC%E6%8D%A2%E8%BF%87%E7%A8%8B%E4%B8%8E-TLB"><span class="post-toc-text">4.3 地址转换过程与 TLB</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#4-4-%E7%BC%BA%E9%A1%B5%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86"><span class="post-toc-text">4.4 缺页异常处理</span></a></li></ol></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#5-%E5%85%B8%E5%9E%8B%E7%9A%84%E9%A1%B5%E9%9D%A2%E7%BD%AE%E6%8D%A2%E7%AE%97%E6%B3%95"><span class="post-toc-text">5 典型的页面置换算法</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#5-1-%E6%9C%80%E4%BD%B3%E9%A1%B5%E9%9D%A2%E7%BD%AE%E6%8D%A2%E7%AE%97%E6%B3%95%EF%BC%88OPT%EF%BC%89"><span class="post-toc-text">5.1 最佳页面置换算法（OPT）</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#5-2-%E5%85%88%E8%BF%9B%E5%85%88%E5%87%BA%E7%AE%97%E6%B3%95%EF%BC%88FIFO%EF%BC%89"><span class="post-toc-text">5.2 先进先出算法（FIFO）</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#5-3-%E7%AC%AC%E4%BA%8C%E6%AC%A1%E6%9C%BA%E4%BC%9A%E7%AE%97%E6%B3%95%EF%BC%88Second-Chance%EF%BC%89"><span class="post-toc-text">5.3 第二次机会算法（Second Chance）</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#5-4-%E6%97%B6%E9%92%9F%E7%AE%97%E6%B3%95%EF%BC%88Clock%EF%BC%89"><span class="post-toc-text">5.4 时钟算法（Clock）</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#5-5-%E6%9C%80%E8%BF%91%E6%9C%80%E5%B0%91%E4%BD%BF%E7%94%A8%E7%AE%97%E6%B3%95%EF%BC%88LRU%EF%BC%89"><span class="post-toc-text">5.5 最近最少使用算法（LRU）</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#5-6-%E9%A2%A0%E7%B0%B8%E6%88%96%E6%8A%96%E5%8A%A8"><span class="post-toc-text">5.6 颠簸或抖动</span></a></li></ol></li></ol>
</div>
<!--<div class="post-back"><i class="material-icons">arrow_back</i></div>-->
<script type="text/javascript">
    menu();
</script>
  </div>
</div>
<div id="bottom-outer">
  <div id="bottom-inner">
    <a  id="top-button" onfocus="this.blur();"><div class="up upinbody" style="background-color:#26A69A"><i class="material-icons material-up">vertical_align_top</i></div></a>


<p >Copyright ©  2017  Walker Denial</p>
<!-- <p >Powered by <a href="https://hexo.io/" target="_blank"> Hexo </a> & Theme - <a href="https://github.com/moumao/hexo-theme-Vateral" target="_blank">Vateral</a></p> -->
<p style="font-size: 10px; margin-top: 0" id="footer-times" data-time="01/10/2017 00:00:00"></p>
<script>
    var beginTime=document.getElementById("footer-times").dataset.time
    function show_date_time(){
        var span=document.getElementById("footer-times")
        window.setTimeout("show_date_time()", 1000);
        BirthDay=new Date(beginTime);//初始日期
        today=new Date();
        timeold=(today.getTime()-BirthDay.getTime());
        sectimeold=timeold/1000
        secondsold=Math.floor(sectimeold);
        msPerDay=24*60*60*1000
        e_daysold=timeold/msPerDay
        daysold=Math.floor(e_daysold);
        e_hrsold=(e_daysold-daysold)*24;
        hrsold=Math.floor(e_hrsold);
        e_minsold=(e_hrsold-hrsold)*60;
        minsold=Math.floor((e_hrsold-hrsold)*60);
        seconds=Math.floor((e_minsold-minsold)*60);
        span.innerHTML="本站已运行"+daysold+"天"+hrsold+"小时"+minsold+"分"+seconds+"秒";
    }
    show_date_time();
</script>

  </div>
</div>

<!--影集界面需要的资源-->



<!-- scripts list from theme config.yml -->

<script src="/js/jquery-3.1.1.min.js"></script>

<script src="/js/materialize.min.js"></script>

<script src="/js/main.min.js"></script>


<script>
    NProgress.start();
    NProgress.done();
    lazy();
    links();
    window.onpopstate = menu();
    //pjax操作
    $(document).pjax('a:not(.nopjax)', '#content-inner', {fragment:'#content-inner', timeout:8000});
    $(document).on('pjax:start', NProgress.start).on('pjax:end', NProgress.done)
        .on('pjax:end', () => {
            dowmdiv();
            lazy();
            toc();
            links();
            menu();
        });
</script>

</body>
</html>
