<!DOCTYPE html>
<html lang="">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
  
  <meta name="keywords" content="Walker Denial">
  <meta name="description" content="This is Walker Denial&#39;s blog!">
  
  <title>Walker Denial</title>
  
    <!-- stylesheets list from config.yml -->
    
      <link rel="stylesheet" href="/css/materialize.min.css">
    
      <link rel="stylesheet" href="/css/main.min.css">
    
  
  <style type="text/css">
      html{
          font-family: sans-serif;
          font-weight: 300;
      }
      @font-face {
          font-family: 'Material Icons';
          font-style: normal;
          font-weight: 400;
          src: url(/fonts/MaterialIcons-Regular.eot);
          src: url(/fonts/MaterialIcons-Regular.woff2) format('woff2'),
          url(/fonts/MaterialIcons-Regular.woff) format('woff'),
          url(/fonts/MaterialIcons-Regular.ttf) format('truetype')
      }
  </style>
<meta name="generator" content="Hexo 7.0.0-rc2"><link rel="stylesheet" href="/css/prism.css" type="text/css">
<link rel="stylesheet" href="/css/prism-line-numbers.css" type="text/css"></head>
<body>
<div id="menu-box"><a href="javascript:void(0)" id="menu" data-activates="slide-out" class="button-collapse menu" ><span class="nav-btn"></span></a></div>
<div id="menu-outer">
  <div id="menu-inner">
      <ul id="slide-out" class="side-nav" >
    <div class="nav-header"  style="background-image: url(/images/header-bg.png);background-color:#26A69A">
    <div class="header-box"><img src="/images/profile.png" ondragstart="return false;"></div>
    <p>Walker Denial</p>
    <div class="nav-link">
        
        <a href="https://twitter.com/WalkerDenial" target="_blank"> <div class="link-box twitter"></div></a>
        
        
        <a  href="https://github.com/WalkerDenial" target="_blank"><div class="link-box github"></div></a>
        
        
        <a href="mailto:mailto:WalkerDenial@gmail.com"><div class="link-box email"></div></a>
        
        
        <a href="http://weibo.com/u/3213135930" target="_blank"><div class="link-box weibo"></div></a>
        
        
        <a href="https://www.zhihu.com/people/walkerdenial/activities" target="_blank"> <div class="link-box zhihu"></div></a>
        
    </div>
    <div class="nav-search">
        <form id="search-form"> <!-- 搜索框相关 -->
            <input type="text" id="local-search-input" name="q" results="0" placeholder="搜索..." class="search form-control" autocomplete="off" autocorrect="off"/>
            <div class="nav-search-img"><i class="material-icons">search</i></div>
        </form>
        <div id="local-search-result"></div> <!-- 搜索结果区 -->
        <p class='no-result'>无搜索结果</p>
    </div>
</div>
    <!--Homepage-->

<li class="nav-list">
    <a href="/" target="_self">
        <div class="nav-ico"><i class="material-icons">home</i> </div><p>主页</p>
    </a>
</li>

<!--archives-->

<li class="nav-list dropdown-btn">
    <a  class=""  target="_self">
        <div class="nav-ico"><i class="material-icons">assignment</i></div><p>归档</p><div class="dropdown-ico"><i class="material-icons">arrow_drop_down</i></div>
    </a>
</li>

<ul class="dropdown-menu dropdown" >
    <li class="nav-dropdown-list">
        <a class="archive-link" href="/archives/2022/06/">June 2022<span class="archive-count">1</span></a></li><li class="nav-dropdown-list"><a class="archive-link" href="/archives/2022/05/">May 2022<span class="archive-count">1</span></a></li><li class="nav-dropdown-list"><a class="archive-link" href="/archives/2022/04/">April 2022<span class="archive-count">4</span></a></li><li class="nav-dropdown-list"><a class="archive-link" href="/archives/2022/03/">March 2022<span class="archive-count">2</span></a></li><li class="nav-dropdown-list"><a class="archive-link" href="/archives/2021/12/">December 2021<span class="archive-count">3</span></a></li><li class="nav-dropdown-list"><a class="archive-link" href="/archives/2021/11/">November 2021<span class="archive-count">1</span></a></li><li class="nav-dropdown-list"><a class="archive-link" href="/archives/2021/09/">September 2021<span class="archive-count">3</span></a></li><li class="nav-dropdown-list"><a class="archive-link" href="/archives/2021/08/">August 2021<span class="archive-count">3</span></a></li><li class="nav-dropdown-list"><a class="archive-link" href="/archives/2021/04/">April 2021<span class="archive-count">1</span></a></li><li class="nav-dropdown-list"><a class="archive-link" href="/archives/2021/03/">March 2021<span class="archive-count">12</span></a></li><li class="nav-dropdown-list"><a class="archive-link" href="/archives/2021/02/">February 2021<span class="archive-count">2</span></a></li><li class="nav-dropdown-list"><a class="archive-link" href="/archives/2021/01/">January 2021<span class="archive-count">6</span></a></li><li class="nav-dropdown-list"><a class="archive-link" href="/archives/2020/12/">December 2020<span class="archive-count">5</span></a></li><li class="nav-dropdown-list"><a class="archive-link" href="/archives/2020/11/">November 2020<span class="archive-count">6</span></a></li><li class="nav-dropdown-list"><a class="archive-link" href="/archives/2020/04/">April 2020<span class="archive-count">2</span></a></li><li class="nav-dropdown-list"><a class="archive-link" href="/archives/2018/01/">January 2018<span class="archive-count">2</span></a></li><li class="nav-dropdown-list"><a class="archive-link" href="/archives/2017/12/">December 2017<span class="archive-count">1</span></a></li><li class="nav-dropdown-list"><a class="archive-link" href="/archives/2017/11/">November 2017<span class="archive-count">6</span></a></li><li class="nav-dropdown-list"><a class="archive-link" href="/archives/2017/08/">August 2017<span class="archive-count">1</span></a></li><li class="nav-dropdown-list"><a class="archive-link" href="/archives/2017/07/">July 2017<span class="archive-count">1</span></a></li><li class="nav-dropdown-list"><a class="archive-link" href="/archives/2017/03/">March 2017<span class="archive-count">6</span></a></li><li class="nav-dropdown-list"><a class="archive-link" href="/archives/2017/02/">February 2017<span class="archive-count">20</span></a></li><li class="nav-dropdown-list"><a class="archive-link" href="/archives/2017/01/">January 2017<span class="archive-count">2</span></a>
    </li>
</ul>
<!--categories-->

<li class="nav-list dropdown-btn">
    <a   class=""  target="_self">
        <div class="nav-ico"><i class="material-icons">dashboard</i></div><p>分类</p><div class="dropdown-ico"><i class="material-icons">arrow_drop_down</i></div>
    </a>
</li>

<ul class="dropdown-menu dropdown" >
    <li class="nav-dropdown-list">
        <a class="category-link" href="/categories/Algorithm/">Algorithm<span class="category-count">1</span></a></li><li class="nav-dropdown-list"><a class="category-link" href="/categories/ES6/">ES6<span class="category-count">2</span></a></li><li class="nav-dropdown-list"><a class="category-link" href="/categories/Flutter/">Flutter<span class="category-count">7</span></a></li><li class="nav-dropdown-list"><a class="category-link" href="/categories/Gradle/">Gradle<span class="category-count">2</span></a></li><li class="nav-dropdown-list"><a class="category-link" href="/categories/Java/">Java<span class="category-count">6</span></a></li><li class="nav-dropdown-list"><a class="category-link" href="/categories/Kotlin/">Kotlin<span class="category-count">4</span></a></li><li class="nav-dropdown-list"><a class="category-link" href="/categories/RPC/">RPC<span class="category-count">3</span></a></li><li class="nav-dropdown-list"><a class="category-link" href="/categories/UML/">UML<span class="category-count">1</span></a></li><li class="nav-dropdown-list"><a class="category-link" href="/categories/%E5%85%B6%E4%BB%96/">其他<span class="category-count">2</span></a></li><li class="nav-dropdown-list"><a class="category-link" href="/categories/%E5%86%99%E4%BD%9C/">写作<span class="category-count">1</span></a></li><li class="nav-dropdown-list"><a class="category-link" href="/categories/%E5%89%8D%E7%AB%AF/">前端<span class="category-count">10</span></a></li><li class="nav-dropdown-list"><a class="category-link" href="/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">操作系统<span class="category-count">7</span></a></li><li class="nav-dropdown-list"><a class="category-link" href="/categories/%E8%87%AA%E5%AD%A6/">自学<span class="category-count">9</span></a></li><li class="nav-dropdown-list"><a class="category-link" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84/">计算机系统结构<span class="category-count">7</span></a></li><li class="nav-dropdown-list"><a class="category-link" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">计算机网络<span class="category-count">2</span></a></li><li class="nav-dropdown-list"><a class="category-link" href="/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/">设计模式<span class="category-count">27</span></a>
    </li>
</ul>
<!--tags-->

<li class="nav-list">
    <a href="/archives" target="_self">
        <div class="nav-ico"><i class="material-icons">bookmark</i> </div><p>标签</p>
    </a>
</li>

<!--photo-->

<!--friends-->

<!--about-->

<li class="nav-list">
    <a href="/about" target="_self">
        <div class="nav-ico"><i class="material-icons">copyright</i> </div><p>关于</p>
    </a>
</li>


</ul>

  </div>
</div>

<div id="content-outer">
  <div id="content-inner">
    
<article id="post">
  <div class="post-page-title"  style="background-color:#26A69A;background-image:url(/images/random/vateral-13.png)" >
  <h2>Dart 类与异步</h2>
    
  <p>作者 : Walker Denial &nbsp&nbsp 发布于 : <time datetime="2021-11-02T15:29:00.000Z">
          2021-11-02
    </time>
  </p>
    
  </div>
  <div class="post-page-content">
  <p>Dart 是一个面向对象编程语言，每个对象都是一个类的实例，所有的类都继承于 Object。</p>
<h2 id="类"><a href="#类" class="headerlink" title="类"></a>类</h2><h3 id="命名规则"><a href="#命名规则" class="headerlink" title="命名规则"></a>命名规则</h3><blockquote>
<p>使用 <code>lowercase_with_underscores</code> 风格来命名库和文件名名字</p>
<p>使用 <code>UpperCamelCase</code> 风格来命名类型名称</p>
<p>使用 <code>lowerCamelCase</code> 风格来命名其他的标识符</p>
<p>推荐使用 <code>lowerCamelCase</code> 来命名常量</p>
</blockquote>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 每个实例变量都会自动生成一个 getter 方法，非 final 实例变量还会自动生成一个 setter 方法。</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">	<span class="built_in">num</span> x;</span><br><span class="line">	<span class="built_in">num</span> _y; <span class="comment">// 使用 _ 开头的表示私有变量，外部无法访问</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h3><p>由于把构造函数参数赋值给实例变量的场景太常见了，Dart 提供了一个语法糖来简化这个操作：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">	<span class="built_in">num</span> x;</span><br><span class="line">	<span class="built_in">num</span> y;</span><br><span class="line">	</span><br><span class="line">	Point(<span class="keyword">this</span>.x, <span class="keyword">this</span>.y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="命名构造函数"><a href="#命名构造函数" class="headerlink" title="命名构造函数"></a>命名构造函数</h3><p> Dart 并不支持函数的重载，而采用了命名构造函数为一个类实现多个构造函数：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">	<span class="built_in">num</span> x;</span><br><span class="line">	<span class="built_in">num</span> y;</span><br><span class="line">	</span><br><span class="line">	Point(<span class="keyword">this</span>.x, <span class="keyword">this</span>.y);</span><br><span class="line">	</span><br><span class="line">	Point.Cool(<span class="keyword">this</span>.y); <span class="comment">// 命名构造方法，命名更加直观的表示这个构造方法的作用与特性</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="常量构造方法"><a href="#常量构造方法" class="headerlink" title="常量构造方法"></a>常量构造方法</h3><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ImmutabelPoint</span></span>&#123;</span><br><span class="line">  <span class="keyword">final</span> <span class="built_in">int</span> x;</span><br><span class="line">  <span class="keyword">final</span> <span class="built_in">int</span> y;</span><br><span class="line">  <span class="comment">// 常量构造方法</span></span><br><span class="line">  <span class="keyword">const</span> ImmutabelPoint(<span class="keyword">this</span>.x,<span class="keyword">this</span>.y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用  new 来创建常量构造方法的对象就和普通的对象没有区别</span></span><br><span class="line"><span class="comment">// 使用 const 来创建多个对象，传递参数一样表示这几个对象是同一个编译期常量对象（必须定义常量构造函数）</span></span><br><span class="line"><span class="keyword">var</span> p1 = <span class="keyword">const</span> ImmutabelPoint(<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line"><span class="keyword">var</span> p2 = <span class="keyword">const</span> ImmutabelPoint(<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line"><span class="built_in">print</span>(p1.hashCode == p2.hashCode);</span><br><span class="line"><span class="built_in">print</span>(p1 == p2);</span><br></pre></td></tr></table></figure>

<h3 id="工厂构造方法"><a href="#工厂构造方法" class="headerlink" title="工厂构造方法"></a>工厂构造方法</h3><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Manager</span></span>&#123;</span><br><span class="line">  <span class="built_in">int</span> i;</span><br><span class="line">  <span class="keyword">static</span> Manager _instance;</span><br><span class="line">  <span class="comment">// 工厂构造方法 必须返回一个实例对象</span></span><br><span class="line">  <span class="keyword">factory</span> Manager.getInstance()&#123;</span><br><span class="line">    <span class="keyword">if</span> (_instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">      _instance = <span class="keyword">new</span> Manager._newInstance();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> _instance;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 私有的 private 的</span></span><br><span class="line">  Manager._newInstance();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> Manager.getInstance();</span><br></pre></td></tr></table></figure>

<h3 id="运算符重载"><a href="#运算符重载" class="headerlink" title="运算符重载"></a>运算符重载</h3><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span></span>&#123;</span><br><span class="line">  <span class="comment">// 每一个实例属性变量都会有一个隐式的 get，非 final 还有 set</span></span><br><span class="line">  <span class="built_in">int</span> _x;</span><br><span class="line">  <span class="built_in">int</span> _y;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//x 是方法名</span></span><br><span class="line">  <span class="built_in">int</span> <span class="keyword">get</span> x =&gt; _x;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">set</span> x(<span class="built_in">int</span> x) =&gt; _x = x;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 运算符重载， 定义 + 操作的行为</span></span><br><span class="line">  Point <span class="keyword">operator</span> +(Point othre)&#123;</span><br><span class="line">    <span class="keyword">var</span> point = <span class="keyword">new</span> Point();</span><br><span class="line">    point._x = _x + othre.x;</span><br><span class="line">    <span class="keyword">return</span> point;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">String</span> <span class="keyword">operator</span> -(<span class="built_in">int</span> x)&#123;</span><br><span class="line">   <span class="keyword">return</span> <span class="string">&quot;hahahaha&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="混合"><a href="#混合" class="headerlink" title="混合"></a>混合</h3><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 被 mixin (混入) 的类不能有构造函数</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>  </span>&#123;</span><br><span class="line">  <span class="keyword">void</span> a()&#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;A  的 a 方法!&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span></span>&#123;</span><br><span class="line">  <span class="keyword">void</span> b()&#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;b 方法&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">void</span> a()&#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;B 的 a 方法!&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 满足了我们的多继承的需求</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span> <span class="title">with</span> <span class="title">B</span>, <span class="title">A</span></span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">void</span> c()&#123;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 重写了混入类的 a 方法</span></span><br><span class="line">  <span class="keyword">void</span> a()&#123;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// C 就是 A、B 的混合类</span></span><br><span class="line"><span class="comment">// class C = Object with A, B;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> main()&#123;</span><br><span class="line">  <span class="comment">// 1、自身是第一优先级</span></span><br><span class="line">  <span class="comment">// 2、如果自身没有对应的方法，就从 with 最右边开始查找方法</span></span><br><span class="line">  <span class="keyword">var</span> c = <span class="keyword">new</span> C();</span><br><span class="line">  c.a();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="异步"><a href="#异步" class="headerlink" title="异步"></a>异步</h2><p>Dart 是基于单线程模型的语言。但是在开发当中我们经常会进行耗时操作，比如：网络请求，这种耗时操作会阻塞我们的代码，所以在 Dart 也有并发机制，名叫 <strong>isolate</strong>。</p>
<h3 id="isolate-机制"><a href="#isolate-机制" class="headerlink" title="isolate 机制"></a>isolate 机制</h3><p>APP 的启动入口 <code>main</code> 函数就是一个类似 Android 主线程的一个主 <code>isolate</code>。和 Java 的 Thread 不同的是，Dart 中的 <code>isolate</code> 无法共享内存。</p>
<p><img src="https://personal-blog.oss-cn-hangzhou.aliyuncs.com/flutter_isolate_connect.png"></p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&#x27;dart:isolate&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">int</span> i;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> main() &#123;</span><br><span class="line">  i = <span class="number">10</span>;</span><br><span class="line">  <span class="comment">// 创建一个消息接收器</span></span><br><span class="line">  ReceivePort receivePort = <span class="keyword">new</span> ReceivePort();</span><br><span class="line">  <span class="comment">// 创建 isolate</span></span><br><span class="line">  Isolate.spawn(isolateMain, receivePort.sendPort);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 接收其他 isolate 发过来的消息</span></span><br><span class="line">  receivePort.listen((message) &#123;</span><br><span class="line">    <span class="comment">// 发过来 sendPort，则主 isolate 也可以向创建的 isolate 发送消息</span></span><br><span class="line">    <span class="keyword">if</span> (message <span class="keyword">is</span> SendPort) &#123;</span><br><span class="line">      message.send(<span class="string">&quot;好呀好呀!&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="built_in">print</span>(<span class="string">&quot;接到子 isolate 消息：&quot;</span> + message);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 新 isolate 的入口函数</span></span><br><span class="line"><span class="keyword">void</span> isolateMain(SendPort sendPort) &#123;</span><br><span class="line">  <span class="comment">// isolate 是内存隔离的，i 的值是在主 isolate 定义的所以这里获得 null</span></span><br><span class="line">  <span class="built_in">print</span>(i);</span><br><span class="line"></span><br><span class="line">  ReceivePort receivePort = <span class="keyword">new</span> ReceivePort();</span><br><span class="line">  sendPort.send(receivePort.sendPort);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 向主 isolate 发送消息</span></span><br><span class="line">  sendPort.send(<span class="string">&quot;去学习吗？&quot;</span>);</span><br><span class="line"></span><br><span class="line">  receivePort.listen((message) &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;接到主 isolate 消息:&quot;</span> + message);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="event-loop"><a href="#event-loop" class="headerlink" title="event-loop"></a>event-loop</h3><p>可以看到代码中，我们接收消息使用了 <strong>listen</strong> 函数来监听消息，假设我们现在在 <strong>main</strong> 方法最后加入 <strong>sleep</strong> 休眠，会不会影响 <strong>listen</strong> 回调的时机？</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&#x27;dart:io&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">&#x27;dart:isolate&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">int</span> i;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> main() &#123;</span><br><span class="line">  i = <span class="number">10</span>;</span><br><span class="line">  <span class="comment">// 创建一个消息接收器</span></span><br><span class="line">  ReceivePort receivePort = <span class="keyword">new</span> ReceivePort();</span><br><span class="line">  <span class="comment">// 创建 isolate</span></span><br><span class="line">  Isolate.spawn(isolateMain, receivePort.sendPort);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 接收其他 isolate 发过来的消息</span></span><br><span class="line">  receivePort.listen((message) &#123;</span><br><span class="line">    <span class="comment">// 发过来 sendPort，则主 isolate 也可以向创建的 isolate 发送消息</span></span><br><span class="line">    <span class="keyword">if</span> (message <span class="keyword">is</span> SendPort) &#123;</span><br><span class="line">      message.send(<span class="string">&quot;好呀好呀!&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="built_in">print</span>(<span class="string">&quot;接到子 isolate 消息：&quot;</span> + message);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 增加休眠，是否会影响 listen 的时机？</span></span><br><span class="line">  sleep(<span class="built_in">Duration</span>(seconds: <span class="number">2</span>));</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">&quot;休眠完成&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 新 isolate 的入口函数</span></span><br><span class="line"><span class="keyword">void</span> isolateMain(SendPort sendPort) &#123;</span><br><span class="line">  <span class="comment">// isolate 是内存隔离的，i 的值是在主 isolate 定义的所以这里获得 null</span></span><br><span class="line">  <span class="built_in">print</span>(i);</span><br><span class="line"></span><br><span class="line">  ReceivePort receivePort = <span class="keyword">new</span> ReceivePort();</span><br><span class="line">  sendPort.send(receivePort.sendPort);</span><br><span class="line">  <span class="comment">// 向主 isolate 发送消息</span></span><br><span class="line">  sendPort.send(<span class="string">&quot;去学习吗？&quot;</span>);</span><br><span class="line"></span><br><span class="line">  receivePort.listen((message) &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;接到主 isolate 消息：&quot;</span> + message);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果是大概 2s 后，我们的 <strong>listen</strong> 才打印出其他 <code>isolate</code> 发过来的消息，同 <code>Android Handler</code> 类似，在 Dart 运行环境中也是靠事件驱动的，通过 <code>event loop</code> 不停的从队列中获取消息或者事件来驱动整个应用的运行，<code>isolate</code> 发过来的消息就是通过 <strong>loop</strong> 处理。但是不同的是在 Android 中每个线程只有一个 Looper 所对应的 MessageQueue，而 Dart 中有两个队列，一个叫做 <strong>event queue（事件队列）</strong>，另一个叫做 <strong>microtask queue（微任务队列）</strong>。</p>
<p><img src="https://personal-blog.oss-cn-hangzhou.aliyuncs.com/flutter_message_handler.png"></p>
<p>Dart 在执行完 main 函数后，就会由 Loop 开始执行两个任务队列中的 Event。首先 Loop 检查微服务队列，依次执行 Event，当 <strong>Microtask queue</strong> 执行完后，就检查 <strong>Event queue</strong> 队列依次执行，在执行 <strong>Event queue</strong> 的过程中，每执行完一个 Event 就再检查一次微服务队列。所以微服务队列优先级高，可以利用微服务进行插队。</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&#x27;dart:io&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> main()&#123;</span><br><span class="line">  <span class="keyword">new</span> File(<span class="string">&quot;~/a.txt&quot;</span>).readAsString().then((content)&#123;</span><br><span class="line">      <span class="built_in">print</span>(content);</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>文件内容永远也无法打印出来，因为 <strong>main</strong> 函数还没执行完。而 <strong>then</strong> 方法是由 Loop 检查 <strong>Event queue</strong> 执行的。</p>
<p>如果需要往微服务中插入 Event 进行插队：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&#x27;dart:async&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">&#x27;dart:io&#x27;</span>;</span><br><span class="line"><span class="comment">// 结果是限制性了 microtask 然后执行 then 方法。</span></span><br><span class="line"><span class="keyword">void</span> main() &#123;</span><br><span class="line">  <span class="keyword">new</span> File(<span class="string">&quot;~/a.txt&quot;</span>).readAsString().then((content)&#123;</span><br><span class="line">      <span class="built_in">print</span>(content);</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="comment">// Future. 内部就是调用了 scheduleMicrotask</span></span><br><span class="line">  Future.microtask(()&#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;future: excute microtask&quot;</span>);</span><br><span class="line">  &#125;);</span><br><span class="line"><span class="comment">//  scheduleMicrotask(()&#123;</span></span><br><span class="line"><span class="comment">//    print(&quot;&quot;);</span></span><br><span class="line"><span class="comment">//  &#125;);</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Future"><a href="#Future" class="headerlink" title="Future"></a>Future</h3><p>在 Dart 库中随处可见 <code>Future</code> 对象，通常异步函数返回的对象就是一个 <code>Future</code>。当一个 <code>Future</code> 执行完后，它里面的值就可以使用了，可以使用 <strong>then()</strong> 来在 <code>Future</code> 完成的时候执行其他代码。<code>Future</code> 对象其实就代表了在事件队列中的一个事件的结果。</p>
<h3 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h3><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 当给到一个不存在的文件地址时会发生异常，这时候可以利用 catchError 捕获此异常。</span></span><br><span class="line"><span class="comment">// then().catchError() 模式就是异步的 try-catch。</span></span><br><span class="line"><span class="keyword">new</span> File(<span class="string">&quot;~/a1.txt&quot;</span>).readAsString().then((content) &#123;</span><br><span class="line">    <span class="built_in">print</span>(content);</span><br><span class="line">  &#125;).catchError((e, s) &#123;</span><br><span class="line">    <span class="built_in">print</span>(s);</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure>

<h3 id="组合"><a href="#组合" class="headerlink" title="组合"></a>组合</h3><p><code>then()</code> 的返回值同样是一个 <code>Future</code> 对象，可以利用队列的原理进行组合异步任务。</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> File(<span class="string">&quot;~/a.txt&quot;</span>).readAsString().then((content) &#123;</span><br><span class="line">  <span class="built_in">print</span>(content);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">1</span>; <span class="comment">// 1 被转化为 Future&lt;int&gt; 类型返回</span></span><br><span class="line">&#125;).then((i) &#123;</span><br><span class="line">  <span class="built_in">print</span>(i);</span><br><span class="line">&#125;).catchError((e, s) &#123;</span><br><span class="line">  <span class="built_in">print</span>(s);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>上面的方式是等待执行完成读取文件之后，再执行一个新的 <code>Future</code>。如果我们需要等待一组任务都执行完成再统一处理一些事情，可以通过 <code>wait()</code> 完成。</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">Future readDone = <span class="keyword">new</span> File(<span class="string">&quot;~/a.txt&quot;</span>).readAsString();</span><br><span class="line"> <span class="comment">// 延迟 3s</span></span><br><span class="line"> Future delayedDone = Future.delayed(<span class="built_in">Duration</span>(seconds: <span class="number">3</span>));</span><br><span class="line"></span><br><span class="line"> Future.wait([readDone, delayedDone]).then((values) &#123;</span><br><span class="line">    <span class="built_in">print</span>(values[<span class="number">0</span>]); <span class="comment">// 第一个 Future 的结果</span></span><br><span class="line">    <span class="built_in">print</span>(values[<span class="number">1</span>]); <span class="comment">// 第二个 Future 的结果</span></span><br><span class="line"> &#125;);</span><br></pre></td></tr></table></figure>

<h2 id="Stream"><a href="#Stream" class="headerlink" title="Stream"></a>Stream</h2><p>Stream(流) 在 Dart API 中也经常出现，表示发出的一系列的异步数据。 Stream 是一个异步数据源，它是 Dart 中处理异步事件流的统一 API。</p>
<p>Future 表示稍后获得的一个数据，所有异步的操作的返回值都用 Future 来表示。但是 Future 只能表示一次异步获得的数据。而 Stream 表示多次异步获得的数据。比如 IO 处理的时候，每次只会读取一部分数据和一次性读取整个文件的内容相比，Stream 的好处是处理过程中内存占用较小。而 File 的 <code>readAsString()</code> 是一次性读取整个文件的内容进来，虽然获得完整内容处理起来比较方便，但是如果文件很大的话就会导致内存占用过大的问题。</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> File(<span class="string">&quot;~/app-release.apk&quot;</span>).openRead().listen((<span class="built_in">List</span>&lt;<span class="built_in">int</span>&gt; bytes) &#123;</span><br><span class="line">	<span class="built_in">print</span>(<span class="string">&quot;stream 执行&quot;</span>);  <span class="comment">// 执行多次</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> File(<span class="string">&quot;~/app-release.apk&quot;</span>).readAsBytes().then((_)&#123;</span><br><span class="line">	<span class="built_in">print</span>(<span class="string">&quot;future执行&quot;</span>); <span class="comment">// 执行 1 次</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p><code>listen()</code> 其实就是订阅这个 Stream，它会返回一个 <code>StreamSubscription</code> 订阅者。订阅者肯定就提供了取消订阅的 <code>cancel()</code>，去掉后我们的 <code>listen</code> 中就接不到任何信息了。除了 <code>cancel()</code> 取消方法之外，我们还可以使用 <code>onData()</code> 重置 <code>listene</code> 方法，<code>onDone</code> 监听完成等等操作。</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">StreamSubscription&lt;<span class="built_in">List</span>&lt;<span class="built_in">int</span>&gt;&gt; listen = <span class="keyword">new</span> File(<span class="string">&quot;~/app-release.apk&quot;</span>).openRead().listen((<span class="built_in">List</span>&lt;<span class="built_in">int</span>&gt; bytes) &#123;</span><br><span class="line">	<span class="built_in">print</span>(<span class="string">&quot;stream 执行&quot;</span>);</span><br><span class="line">&#125;);</span><br><span class="line">listen.onData((_)&#123;</span><br><span class="line">	<span class="built_in">print</span>(<span class="string">&quot;替代 listene&quot;</span>);</span><br><span class="line">&#125;);</span><br><span class="line">listen.onDone(()&#123;</span><br><span class="line">	<span class="built_in">print</span>(<span class="string">&quot;结束&quot;</span>);</span><br><span class="line">&#125;);</span><br><span class="line">listen.onError((e,s)&#123;</span><br><span class="line">	<span class="built_in">print</span>(<span class="string">&quot;异常&quot;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 暂停，如果没有继续则会退出程序</span></span><br><span class="line">listen.pause();</span><br><span class="line"><span class="comment">// 继续</span></span><br><span class="line">listen.resume();</span><br></pre></td></tr></table></figure>

<h3 id="广播模式"><a href="#广播模式" class="headerlink" title="广播模式"></a>广播模式</h3><p>​	Stream 有两种订阅模式：<strong>单订阅</strong> 和 <strong>多订阅</strong>。<strong>单订阅</strong> 就是只能有一个订阅者，上面的使用我们都是单订阅模式，而广播是可以有多个订阅者。通过 <strong>Stream.asBroadcastStream()</strong> 可以将一个单订阅模式的 Stream 转换成一个多订阅模式的 Stream，isBroadcast 属性可以判断当前 Stream 所处的模式。</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> stream = <span class="keyword">new</span> File(<span class="string">&quot;~/app-release.apk&quot;</span>).openRead();</span><br><span class="line">stream.listen((<span class="built_in">List</span>&lt;<span class="built_in">int</span>&gt; bytes) &#123;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 错误 单订阅只能有一个订阅者</span></span><br><span class="line"><span class="comment">//  stream.listen((_)&#123;</span></span><br><span class="line"><span class="comment">//    print(&quot;stream执行&quot;);</span></span><br><span class="line"><span class="comment">//  &#125;);</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> broadcastStream = <span class="keyword">new</span> File(<span class="string">&quot;/Users/enjoy/app-release.apk&quot;</span>).openRead().asBroadcastStream();</span><br><span class="line">broadcastStream.listen((_)&#123;</span><br><span class="line">	<span class="built_in">print</span>(<span class="string">&quot;订阅者1&quot;</span>);</span><br><span class="line">&#125;);</span><br><span class="line">broadcastStream.listen((_)&#123;</span><br><span class="line">	<span class="built_in">print</span>(<span class="string">&quot;订阅者2&quot;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>需要注意的是，多订阅模式如果没有及时添加订阅者则可能丢数据。</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 默认是单订阅</span></span><br><span class="line"><span class="keyword">var</span> stream = Stream.fromIterable([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]);</span><br><span class="line"><span class="comment">// 3s 后添加订阅者 不会丢失数据</span></span><br><span class="line"><span class="keyword">new</span> Timer(<span class="keyword">new</span> <span class="built_in">Duration</span>(seconds: <span class="number">3</span>), () =&gt; stream.listen(<span class="built_in">print</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个流管理器 对一个 stream 进行管理</span></span><br><span class="line"><span class="keyword">var</span> streamController = StreamController.broadcast();</span><br><span class="line"><span class="comment">// 添加</span></span><br><span class="line">streamController.add(<span class="number">1</span>);</span><br><span class="line"><span class="comment">// 先发出事件再订阅 无法接到通知</span></span><br><span class="line">streamController.stream.listen((i)&#123;</span><br><span class="line">	<span class="built_in">print</span>(<span class="string">&quot;broadcast:<span class="subst">$i</span>&quot;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 记得关闭</span></span><br><span class="line">streamController.close();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这里没有丢失，因为 stream 通过 asBroadcastStream 转为了多订阅，但是本质是单订阅流，并不改变原始 stream 的实现特性</span></span><br><span class="line"><span class="keyword">var</span> broadcastStream = Stream.fromIterable([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]).asBroadcastStream();</span><br><span class="line"><span class="keyword">new</span> Timer(<span class="keyword">new</span> <span class="built_in">Duration</span>(seconds: <span class="number">3</span>), () =&gt; broadcastStream.listen(<span class="built_in">print</span>));</span><br></pre></td></tr></table></figure>

<h2 id="async-await"><a href="#async-await" class="headerlink" title="async&#x2F;await"></a>async&#x2F;await</h2><p>使用 <code>async</code> 和 <code>await</code> 的代码是异步的，但是看起来很像同步代码。当我们需要获得 A 的结果，再执行 B，时，你需要 <code>then()-&gt;then()</code>，但是利用 <code>async</code> 与 <code>await</code> 能够非常好的解决回调地狱的问题：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="comment">// async 表示这是一个异步方法，await 必须再 async 方法中使用</span></span><br><span class="line"><span class="comment">// 异步方法只能返回 void 和 Future</span></span><br><span class="line">Future&lt;<span class="built_in">String</span>&gt; readFile() <span class="keyword">async</span> &#123;</span><br><span class="line">  <span class="comment">// await 等待 future 执行完成再执行后续代码</span></span><br><span class="line">  <span class="built_in">String</span> content = <span class="keyword">await</span> <span class="keyword">new</span> File(<span class="string">&quot;~/a.txt&quot;</span>).readAsString();</span><br><span class="line">  <span class="built_in">String</span> content2 = <span class="keyword">await</span> <span class="keyword">new</span> File(<span class="string">&quot;~/a.txt&quot;</span>).readAsString();</span><br><span class="line">  <span class="comment">// 自动转换为 future</span></span><br><span class="line">  <span class="keyword">return</span> content;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
  </div>
  <!--评论块-->
    

</article>
<nav class="post-nav">
  <!-- Prev Nav -->
    
  <a href="/2021/12/15/Flutter/路由与导航/" id="post_nav-newer" class="post-nav-content prev-content">
      <上一篇
  </a>
    


  <!-- Next Nav -->
    
  <a href="/2021/09/29/Flutter/Dart 基础/" id="post_nav-older" class="post-nav-content next-content">
      下一篇>
  </a>
    
</nav>
<div class="post-toc-btn"><i class="material-icons">format_list_numbered</i></div>
<div class="post-toc-none"><p>(无)</p></div>
<div class="post-toc-box">
    <ol class="post-toc"><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#%E7%B1%BB"><span class="post-toc-text">类</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#%E5%91%BD%E5%90%8D%E8%A7%84%E5%88%99"><span class="post-toc-text">命名规则</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="post-toc-text">构造函数</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#%E5%91%BD%E5%90%8D%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="post-toc-text">命名构造函数</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#%E5%B8%B8%E9%87%8F%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95"><span class="post-toc-text">常量构造方法</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#%E5%B7%A5%E5%8E%82%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95"><span class="post-toc-text">工厂构造方法</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD"><span class="post-toc-text">运算符重载</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#%E6%B7%B7%E5%90%88"><span class="post-toc-text">混合</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#%E5%BC%82%E6%AD%A5"><span class="post-toc-text">异步</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#isolate-%E6%9C%BA%E5%88%B6"><span class="post-toc-text">isolate 机制</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#event-loop"><span class="post-toc-text">event-loop</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#Future"><span class="post-toc-text">Future</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#%E5%BC%82%E5%B8%B8"><span class="post-toc-text">异常</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#%E7%BB%84%E5%90%88"><span class="post-toc-text">组合</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#Stream"><span class="post-toc-text">Stream</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#%E5%B9%BF%E6%92%AD%E6%A8%A1%E5%BC%8F"><span class="post-toc-text">广播模式</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#async-await"><span class="post-toc-text">async&#x2F;await</span></a></li></ol>
</div>
<!--<div class="post-back"><i class="material-icons">arrow_back</i></div>-->
<script type="text/javascript">
    menu();
</script>
  </div>
</div>
<div id="bottom-outer">
  <div id="bottom-inner">
    <a  id="top-button" onfocus="this.blur();"><div class="up upinbody" style="background-color:#26A69A"><i class="material-icons material-up">vertical_align_top</i></div></a>


<p >Copyright ©  2017  Walker Denial</p>
<!-- <p >Powered by <a href="https://hexo.io/" target="_blank"> Hexo </a> & Theme - <a href="https://github.com/moumao/hexo-theme-Vateral" target="_blank">Vateral</a></p> -->
<p style="font-size: 10px; margin-top: 0" id="footer-times" data-time="01/10/2017 00:00:00"></p>
<script>
    var beginTime=document.getElementById("footer-times").dataset.time
    function show_date_time(){
        var span=document.getElementById("footer-times")
        window.setTimeout("show_date_time()", 1000);
        BirthDay=new Date(beginTime);//初始日期
        today=new Date();
        timeold=(today.getTime()-BirthDay.getTime());
        sectimeold=timeold/1000
        secondsold=Math.floor(sectimeold);
        msPerDay=24*60*60*1000
        e_daysold=timeold/msPerDay
        daysold=Math.floor(e_daysold);
        e_hrsold=(e_daysold-daysold)*24;
        hrsold=Math.floor(e_hrsold);
        e_minsold=(e_hrsold-hrsold)*60;
        minsold=Math.floor((e_hrsold-hrsold)*60);
        seconds=Math.floor((e_minsold-minsold)*60);
        span.innerHTML="本站已运行"+daysold+"天"+hrsold+"小时"+minsold+"分"+seconds+"秒";
    }
    show_date_time();
</script>

  </div>
</div>

<!--影集界面需要的资源-->



<!-- scripts list from theme config.yml -->

<script src="/js/jquery-3.1.1.min.js"></script>

<script src="/js/materialize.min.js"></script>

<script src="/js/main.min.js"></script>


<script>
    NProgress.start();
    NProgress.done();
    lazy();
    links();
    window.onpopstate = menu();
    //pjax操作
    $(document).pjax('a:not(.nopjax)', '#content-inner', {fragment:'#content-inner', timeout:8000});
    $(document).on('pjax:start', NProgress.start).on('pjax:end', NProgress.done)
        .on('pjax:end', () => {
            dowmdiv();
            lazy();
            toc();
            links();
            menu();
        });
</script>

</body>
</html>
