<!DOCTYPE html>
<html lang="">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
  
  <meta name="keywords" content="Walker Denial">
  <meta name="description" content="This is Walker Denial&#39;s blog!">
  
  <title>Walker Denial</title>
  
    <!-- stylesheets list from config.yml -->
    
      <link rel="stylesheet" href="/css/materialize.min.css">
    
      <link rel="stylesheet" href="/css/main.min.css">
    
  
  <style type="text/css">
      html{
          font-family: sans-serif;
          font-weight: 300;
      }
      @font-face {
          font-family: 'Material Icons';
          font-style: normal;
          font-weight: 400;
          src: url(/fonts/MaterialIcons-Regular.eot);
          src: url(/fonts/MaterialIcons-Regular.woff2) format('woff2'),
          url(/fonts/MaterialIcons-Regular.woff) format('woff'),
          url(/fonts/MaterialIcons-Regular.ttf) format('truetype')
      }
  </style>
<meta name="generator" content="Hexo 7.0.0-rc2"><link rel="stylesheet" href="/css/prism.css" type="text/css">
<link rel="stylesheet" href="/css/prism-line-numbers.css" type="text/css"></head>
<body>
<div id="menu-box"><a href="javascript:void(0)" id="menu" data-activates="slide-out" class="button-collapse menu" ><span class="nav-btn"></span></a></div>
<div id="menu-outer">
  <div id="menu-inner">
      <ul id="slide-out" class="side-nav" >
    <div class="nav-header"  style="background-image: url(/images/header-bg.png);background-color:#26A69A">
    <div class="header-box"><img src="/images/profile.png" ondragstart="return false;"></div>
    <p>Walker Denial</p>
    <div class="nav-link">
        
        <a href="https://twitter.com/WalkerDenial" target="_blank"> <div class="link-box twitter"></div></a>
        
        
        <a  href="https://github.com/WalkerDenial" target="_blank"><div class="link-box github"></div></a>
        
        
        <a href="mailto:mailto:WalkerDenial@gmail.com"><div class="link-box email"></div></a>
        
        
        <a href="http://weibo.com/u/3213135930" target="_blank"><div class="link-box weibo"></div></a>
        
        
        <a href="https://www.zhihu.com/people/walkerdenial/activities" target="_blank"> <div class="link-box zhihu"></div></a>
        
    </div>
    <div class="nav-search">
        <form id="search-form"> <!-- 搜索框相关 -->
            <input type="text" id="local-search-input" name="q" results="0" placeholder="搜索..." class="search form-control" autocomplete="off" autocorrect="off"/>
            <div class="nav-search-img"><i class="material-icons">search</i></div>
        </form>
        <div id="local-search-result"></div> <!-- 搜索结果区 -->
        <p class='no-result'>无搜索结果</p>
    </div>
</div>
    <!--Homepage-->

<li class="nav-list">
    <a href="/" target="_self">
        <div class="nav-ico"><i class="material-icons">home</i> </div><p>主页</p>
    </a>
</li>

<!--archives-->

<li class="nav-list dropdown-btn">
    <a  class=""  target="_self">
        <div class="nav-ico"><i class="material-icons">assignment</i></div><p>归档</p><div class="dropdown-ico"><i class="material-icons">arrow_drop_down</i></div>
    </a>
</li>

<ul class="dropdown-menu dropdown" >
    <li class="nav-dropdown-list">
        <a class="archive-link" href="/archives/2022/06/">June 2022<span class="archive-count">1</span></a></li><li class="nav-dropdown-list"><a class="archive-link" href="/archives/2022/05/">May 2022<span class="archive-count">1</span></a></li><li class="nav-dropdown-list"><a class="archive-link" href="/archives/2022/04/">April 2022<span class="archive-count">4</span></a></li><li class="nav-dropdown-list"><a class="archive-link" href="/archives/2022/03/">March 2022<span class="archive-count">2</span></a></li><li class="nav-dropdown-list"><a class="archive-link" href="/archives/2021/12/">December 2021<span class="archive-count">3</span></a></li><li class="nav-dropdown-list"><a class="archive-link" href="/archives/2021/11/">November 2021<span class="archive-count">1</span></a></li><li class="nav-dropdown-list"><a class="archive-link" href="/archives/2021/09/">September 2021<span class="archive-count">3</span></a></li><li class="nav-dropdown-list"><a class="archive-link" href="/archives/2021/08/">August 2021<span class="archive-count">3</span></a></li><li class="nav-dropdown-list"><a class="archive-link" href="/archives/2021/04/">April 2021<span class="archive-count">1</span></a></li><li class="nav-dropdown-list"><a class="archive-link" href="/archives/2021/03/">March 2021<span class="archive-count">12</span></a></li><li class="nav-dropdown-list"><a class="archive-link" href="/archives/2021/02/">February 2021<span class="archive-count">2</span></a></li><li class="nav-dropdown-list"><a class="archive-link" href="/archives/2021/01/">January 2021<span class="archive-count">6</span></a></li><li class="nav-dropdown-list"><a class="archive-link" href="/archives/2020/12/">December 2020<span class="archive-count">5</span></a></li><li class="nav-dropdown-list"><a class="archive-link" href="/archives/2020/11/">November 2020<span class="archive-count">6</span></a></li><li class="nav-dropdown-list"><a class="archive-link" href="/archives/2020/04/">April 2020<span class="archive-count">2</span></a></li><li class="nav-dropdown-list"><a class="archive-link" href="/archives/2018/01/">January 2018<span class="archive-count">2</span></a></li><li class="nav-dropdown-list"><a class="archive-link" href="/archives/2017/12/">December 2017<span class="archive-count">1</span></a></li><li class="nav-dropdown-list"><a class="archive-link" href="/archives/2017/11/">November 2017<span class="archive-count">6</span></a></li><li class="nav-dropdown-list"><a class="archive-link" href="/archives/2017/08/">August 2017<span class="archive-count">1</span></a></li><li class="nav-dropdown-list"><a class="archive-link" href="/archives/2017/07/">July 2017<span class="archive-count">1</span></a></li><li class="nav-dropdown-list"><a class="archive-link" href="/archives/2017/03/">March 2017<span class="archive-count">6</span></a></li><li class="nav-dropdown-list"><a class="archive-link" href="/archives/2017/02/">February 2017<span class="archive-count">20</span></a></li><li class="nav-dropdown-list"><a class="archive-link" href="/archives/2017/01/">January 2017<span class="archive-count">2</span></a>
    </li>
</ul>
<!--categories-->

<li class="nav-list dropdown-btn">
    <a   class=""  target="_self">
        <div class="nav-ico"><i class="material-icons">dashboard</i></div><p>分类</p><div class="dropdown-ico"><i class="material-icons">arrow_drop_down</i></div>
    </a>
</li>

<ul class="dropdown-menu dropdown" >
    <li class="nav-dropdown-list">
        <a class="category-link" href="/categories/Algorithm/">Algorithm<span class="category-count">1</span></a></li><li class="nav-dropdown-list"><a class="category-link" href="/categories/ES6/">ES6<span class="category-count">2</span></a></li><li class="nav-dropdown-list"><a class="category-link" href="/categories/Flutter/">Flutter<span class="category-count">7</span></a></li><li class="nav-dropdown-list"><a class="category-link" href="/categories/Gradle/">Gradle<span class="category-count">2</span></a></li><li class="nav-dropdown-list"><a class="category-link" href="/categories/Java/">Java<span class="category-count">6</span></a></li><li class="nav-dropdown-list"><a class="category-link" href="/categories/Kotlin/">Kotlin<span class="category-count">4</span></a></li><li class="nav-dropdown-list"><a class="category-link" href="/categories/RPC/">RPC<span class="category-count">3</span></a></li><li class="nav-dropdown-list"><a class="category-link" href="/categories/UML/">UML<span class="category-count">1</span></a></li><li class="nav-dropdown-list"><a class="category-link" href="/categories/%E5%85%B6%E4%BB%96/">其他<span class="category-count">2</span></a></li><li class="nav-dropdown-list"><a class="category-link" href="/categories/%E5%86%99%E4%BD%9C/">写作<span class="category-count">1</span></a></li><li class="nav-dropdown-list"><a class="category-link" href="/categories/%E5%89%8D%E7%AB%AF/">前端<span class="category-count">10</span></a></li><li class="nav-dropdown-list"><a class="category-link" href="/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">操作系统<span class="category-count">7</span></a></li><li class="nav-dropdown-list"><a class="category-link" href="/categories/%E8%87%AA%E5%AD%A6/">自学<span class="category-count">9</span></a></li><li class="nav-dropdown-list"><a class="category-link" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84/">计算机系统结构<span class="category-count">7</span></a></li><li class="nav-dropdown-list"><a class="category-link" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">计算机网络<span class="category-count">2</span></a></li><li class="nav-dropdown-list"><a class="category-link" href="/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/">设计模式<span class="category-count">27</span></a>
    </li>
</ul>
<!--tags-->

<li class="nav-list">
    <a href="/archives" target="_self">
        <div class="nav-ico"><i class="material-icons">bookmark</i> </div><p>标签</p>
    </a>
</li>

<!--photo-->

<!--friends-->

<!--about-->

<li class="nav-list">
    <a href="/about" target="_self">
        <div class="nav-ico"><i class="material-icons">copyright</i> </div><p>关于</p>
    </a>
</li>


</ul>

  </div>
</div>

<div id="content-outer">
  <div id="content-inner">
    
<article id="post">
  <div class="post-page-title"  style="background-color:#26A69A;background-image:url(/images/random/vateral-5.png)" >
  <h2>多线程</h2>
    
  <p>作者 : Walker Denial &nbsp&nbsp 发布于 : <time datetime="2020-12-30T15:07:00.000Z">
          2020-12-30
    </time>
  </p>
    
  </div>
  <div class="post-page-content">
  <p>在开发过程中，遇到 IO 操作、网络请求等耗时操作，通常都会放到子线程中去处理，如果有多个操作，就涉及到了 <strong>多线程</strong>，现在就来扒一扒 <strong>多线程</strong>，然后基于扒皮之后的结果，进行线程优化。</p>
<p>在进入正题之前，先介绍一下基础概念，不仅要知其然，还要知其所以然。</p>
<h1 id="1-基础概念"><a href="#1-基础概念" class="headerlink" title="1. 基础概念"></a>1. 基础概念</h1><blockquote>
<p><code>时钟频率</code>：时钟频率（又译：时钟频率速度，英语：clock rate），是指同步电路中时钟的基础频率，它以「若干次周期每秒」来度量，量度单位采用 SI 单位赫兹（Hz）。</p>
<p><code>主频</code>：主频即 CPU 的时钟频率，计算机的操作在时钟信号的控制下分步执行，每个时钟信号周期完成一步操作，时钟频率的高低在很大程度上反映了 CPU 速度的快慢。</p>
<p><code>外频</code>：是 CPU 外部的工作频率，是由主板提供的基准时钟频率。</p>
<p><code>FSB 频率</code>：是连接 CPU 和主板芯片组中的北桥芯片的前端总线（Front Side Bus）上的数据传输频率。</p>
<p>CPU 的主频和外频间存在这样的关系：主频 &#x3D; 外频 × 倍频。</p>
<p><code>进程</code>：进程（Process）是计算机中的程序关于某数据集合上的一次运行活动，是系统进行资源分配和调度的基本单位，是操作系统结构的基础。</p>
<p><code>线程</code>：线程（英语：thread）是操作系统能够进行运算调度的最小单位。</p>
<p><code>并发</code>：在同一个时间段内，两个或多个程序执行，有时间上的重叠（宏观上是同时，微观上仍是顺序执行）。</p>
<p><code>并行</code>：一组程序按独立异步的速度执行，不等于时间上的重叠（同一个时刻发生)。</p>
</blockquote>
<p>从理论上来讲，<strong>主频</strong> 越高，CPU 运算能力越强，再根据 <code>摩尔定律</code> 来看，每过 18 个月计算机性能就会翻一倍，那么岂不是只管提升 <strong>主频</strong> 就行了，还有 <strong>多线程</strong> 什么事情啊。</p>
<p>其实不然，到目前的发展状况来看，由于CPU是在半导体硅片上制造的，在硅片上的元件之间需要导线进行联接，由于在高频状态下要求导线越细越短越好，这样才能减小导线分布电容等杂散干扰以保证 CPU 运算正确。因此制造工艺的限制，是 CPU 主频发展的最大障碍之一。</p>
<p>举个栗子就明白了。以前的绿皮火车特别特别慢，导致在一个时间周期内，只能跑一次运输，相当于早期的 CPU；后来，列车速度不断提升，有了快车；再后来，有了动车；现在，有了高铁和复兴号。在同一个时间周期内，绿皮火车只能完成一次运输，复兴号却可以完成 4~5 次运输（相当于主频提升），效率大大提升。可是当达到一定的速度后，再想提升速度就很难了。</p>
<p>那么…性能提升发展到此停止了吗？</p>
<p>不存在的，既然 <strong>主频</strong> 提升困难，那多个 CPU 一起运行，不也可以提升性能嘛，多核就涉及到了多线程，也就是今天要讲的主题的由来。</p>
<p>接上个🌰，铺设多条轨道，同时跑多列车，性能不就提升起来了嘛。</p>
<h1 id="2-查看线程信息示例"><a href="#2-查看线程信息示例" class="headerlink" title="2. 查看线程信息示例"></a>2. 查看线程信息示例</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="comment">// 虚拟机线程管理接口</span></span><br><span class="line">    <span class="type">ThreadMXBean</span> <span class="variable">threadMXBean</span> <span class="operator">=</span> ManagementFactory.getThreadMXBean();</span><br><span class="line">    <span class="comment">// 获去线程信息</span></span><br><span class="line">    ThreadInfo[] threadInfos = threadMXBean.dumpAllThreads(<span class="literal">false</span>, <span class="literal">false</span>);</span><br><span class="line">    <span class="comment">// 输出线程信息</span></span><br><span class="line">    <span class="keyword">for</span> (ThreadInfo threadInfo : threadInfos) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;[&quot;</span> + threadInfo.getThreadId() + <span class="string">&quot;]&quot;</span> + <span class="string">&quot; &quot;</span> + threadInfo.getThreadName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>调用上述方法后，会输出虚拟机中的线程信息，我电脑上的输出信息如下：</p>
<pre><code>[4] Signal Dispatcher // 信令分发
[3] Finalizer // 对象被销毁时调用，但是不一定百分比调用成功
[2] Reference Handler // 引用处理
[1] main // 主线程
</code></pre>
<h1 id="3-线程的使用"><a href="#3-线程的使用" class="headerlink" title="3. 线程的使用"></a>3. 线程的使用</h1><p>一般来讲，想使用线程，有 3 种方式：</p>
<p>方式 1：继承 Thread</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 1. 派生 Thread</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">UseThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.run();</span><br><span class="line">        System.out.println(<span class="string">&quot;I am extends Thread&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>方式 2：实现 Runnable</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">UseRun</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;I am implements Runnable&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>方式 3：实现 Callable，有返回值</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">UseCall</span> <span class="keyword">implements</span> <span class="title class_">Callable</span>&lt;String&gt; &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">call</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;I am implements Callable&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Call result&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实际而言，只有第一种才能算称得上 <code>线程</code>，Runnable 和 Callable 表示的是 <code>线程</code> 中的 <strong>任务</strong>，而非线程，还是需要传递到 <code>线程</code> 中，通过 <code>线程</code> 的 start() 方法启动线程。</p>
<p>测试代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 测试方法</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> args</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> ExecutionException</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> InterruptedException</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 实际而言，只有 Thread 才能代表线程；</span></span><br><span class="line"><span class="comment"> * Runnable、Callable 表示的是任务</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 基于 Thread 派生启动线程</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">UseThread</span> <span class="variable">useThread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UseThread</span>();</span><br><span class="line">    useThread.start();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 基于 Runnable 启动线程</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">UseRun</span> <span class="variable">useRun</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UseRun</span>();</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Thread</span>(useRun).start();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 通过 Callable 可以获取回调信息</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">UseCall</span> <span class="variable">useCall</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UseCall</span>();</span><br><span class="line">    FutureTask&lt;String&gt; futureTask = <span class="keyword">new</span> <span class="title class_">FutureTask</span>&lt;&gt;(useCall);</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Thread</span>(futureTask).start();</span><br><span class="line">    System.out.println(futureTask.get());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意：start() 方法不一定代表线程立即执行，只是告诉线程目前处于就绪状态，具体什么时间执行是等待系统通知的。</p>
<h1 id="4-线程的停止"><a href="#4-线程的停止" class="headerlink" title="4. 线程的停止"></a>4. 线程的停止</h1><p>前面讲了开启 <code>线程</code>，那么线程也要能停止才行啊。</p>
<p>在讲停止之前，先补充一下 <strong>抢占式</strong> 任务基本信息：在调用 stop() 方法之后，线程直接停止，加入线程现在在处理的信息是否重要，可能会造成丢失，比如正在写一个关键文件，已经写入 90%，如果此时停止，文件就会出现异常，导致信息丢失。</p>
<p>由于 <strong>抢占式任务</strong> 的种种弊端，现已废弃 <strong>stop()</strong> 方法，改为 <strong>协作式任务</strong>。这就温柔的多了，只是告诉 <code>线程</code>，你被打断了，线程可以继续执行任务，也可以择时停止，这样就能避免信息丢失，同时，对开发人员的要求也提高了不少。</p>
<p>下面，简单介绍一下几个方法，避免混淆；</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Interrupts this thread.</span></span><br><span class="line"><span class="comment"> * Unless the current thread is interrupting itself, which is always permitted, the checkAccess method of this thread is invoked, which may cause a SecurityException to be thrown.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">interrupt</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span> != Thread.currentThread())</span><br><span class="line">        checkAccess();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">synchronized</span> (blockerLock) &#123;</span><br><span class="line">        <span class="type">Interruptible</span> <span class="variable">b</span> <span class="operator">=</span> blocker;</span><br><span class="line">        <span class="keyword">if</span> (b != <span class="literal">null</span>) &#123;</span><br><span class="line">            interrupt0(); <span class="comment">// Just to set the interrupt flag，注意这个官方注释哟，这里其实只是设置了 interrupt 标识符，具体是否停止要看线程本身。</span></span><br><span class="line">            b.interrupt(<span class="built_in">this</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    interrupt0();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 这是一个 native 方法，主要作用是测试线程是否 interrupted，注意传的参数，如果为 true，则会清空当前 interrupted 状态，千万要注意</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">native</span> <span class="type">boolean</span> <span class="title function_">isInterrupted</span><span class="params">(<span class="type">boolean</span> ClearInterrupted)</span>;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 其实就是调用了上面的 isInterrupted 方法，并表示不清除 interrupted 状态</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isInterrupted</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> isInterrupted(<span class="literal">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 同上，与  isInterrupted() 的区别就是：会清除 interrupted 状态</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">interrupted</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> currentThread().isInterrupted(<span class="literal">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="5-线程常用方法"><a href="#5-线程常用方法" class="headerlink" title="5. 线程常用方法"></a>5. 线程常用方法</h1><p>前面介绍了开始、结束，再介绍一下线程的其它常用方法。</p>
<table>
<thead>
<tr>
<th align="center">方法</th>
<th align="center">介绍</th>
</tr>
</thead>
<tbody><tr>
<td align="center">yield()</td>
<td align="center">native 方法，线程从运行状态切换为可运行状态，也就是就绪状态</td>
</tr>
<tr>
<td align="center">sleep()</td>
<td align="center">native 方法，线程会切换为阻塞状态</td>
</tr>
<tr>
<td align="center">join()</td>
<td align="center">实际上内部调用了 wait 方法，线程切换为阻塞状态</td>
</tr>
</tbody></table>
<h1 id="6-线程锁"><a href="#6-线程锁" class="headerlink" title="6. 线程锁"></a>6. 线程锁</h1><p>前面讲到过，进程下的资源对所有子线程共享，那么子线程就可以对资源进行读写，多个线程同时抢夺资源，就会出现数据错乱。</p>
<p>在讲锁之前，先说说 <strong>等待和通知的标准范式</strong>：</p>
<p><strong>等待方</strong>：</p>
<ol>
<li>获取对象的锁；</li>
<li>如果条件不满足，那么调用对象的 wait() 方法，被通知后仍要检查条件；<br>3、如果条件满足则执行对应的逻辑；</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">synchronized</span>(Object) &#123;</span><br><span class="line">    <span class="keyword">while</span>(条件不满足) &#123;</span><br><span class="line">        Object.wait();</span><br><span class="line">    &#125;</span><br><span class="line">    对应的处理逻辑</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>接收方</strong>:</p>
<ol>
<li>获得对象的锁；</li>
<li>改变条件；</li>
<li>通知所有等待在对象上的线程。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">synchronized</span>(Object) &#123;</span><br><span class="line">    改变条件</span><br><span class="line">    对象.notifyAll();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>先列举一个示例代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SynTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">long</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">long</span> <span class="title function_">getCount</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setCount</span><span class="params">(<span class="type">long</span> count)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.count = count;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对 count 进行累加，由于没有加锁，计算的结果会偏小，不正确</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">incCount1</span><span class="params">()</span> &#123;</span><br><span class="line">        count++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 加方法锁</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">incCount2</span><span class="params">()</span> &#123;</span><br><span class="line">        count++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 加指定对象锁</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">incCount3</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (obj) &#123;</span><br><span class="line">            count++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 加当前对象锁</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">incCount4</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">            count++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 开启线程进行操作</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Count</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> SynTest synTest;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">Count</span><span class="params">(SynTest test)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.synTest = test;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++) &#123;</span><br><span class="line">                synTest.incCount1();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">SynTest</span> <span class="variable">synTest</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SynTest</span>();</span><br><span class="line">        <span class="comment">// 启动两个线程对 count 进行操作</span></span><br><span class="line">        <span class="type">Count</span> <span class="variable">thread1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Count</span>(synTest);</span><br><span class="line">        <span class="type">Count</span> <span class="variable">thread2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Count</span>(synTest);</span><br><span class="line">        thread1.start();</span><br><span class="line">        thread2.start();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">50</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(synTest.getCount());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>加锁除了 synchronized，还有显示锁 Lock。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LockDemo</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">Lock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">increment</span><span class="params">()</span> &#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            count++;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">LockDemo</span> <span class="variable">demo</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LockDemo</span>();</span><br><span class="line">        demo.increment();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Lock 是进行加锁，但是对于频繁读、少量写的 IO 操作，就会大大降低性能，ReadWriteLock 就是用来处理这类问题，性能至少是 10 倍提升，其实 ReadWriteLock 也很简单，先看看代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ReadWriteLock</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns the lock used for reading.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the lock used for reading</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    Lock <span class="title function_">readLock</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns the lock used for writing.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the lock used for writing</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    Lock <span class="title function_">writeLock</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>就是由 1 把锁变为 2 把锁，读锁相互之间不干扰，写锁控制所有锁，这样就可能将性能大幅提升。</p>
<p>先来展示 Synchronized 方式示例代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UseSyn</span> <span class="keyword">implements</span> <span class="title class_">GoodsService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> GoodsInfo goodsInfo;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">UseSyn</span><span class="params">(GoodsInfo goodsInfo)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.goodsInfo = goodsInfo;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> GoodsInfo <span class="title function_">getNum</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">5</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>.goodsInfo;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">setNum</span><span class="params">(<span class="type">int</span> number)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">5</span>);</span><br><span class="line">            goodsInfo.changeNumber(number);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出结果为：</span></span><br><span class="line">Thread-<span class="number">22</span>写商品数据耗时：<span class="number">2247</span> ms----</span><br><span class="line">Thread-<span class="number">26</span>读取商品数据耗时：<span class="number">3051</span> ms</span><br><span class="line">Thread-<span class="number">15</span>读取商品数据耗时：<span class="number">5433</span> ms</span><br><span class="line">Thread-<span class="number">13</span>读取商品数据耗时：<span class="number">6265</span> ms</span><br><span class="line">Thread-<span class="number">16</span>读取商品数据耗时：<span class="number">6594</span> ms</span><br><span class="line">Thread-<span class="number">21</span>读取商品数据耗时：<span class="number">7508</span> ms</span><br><span class="line">Thread-<span class="number">25</span>读取商品数据耗时：<span class="number">7780</span> ms</span><br><span class="line">Thread-<span class="number">30</span>读取商品数据耗时：<span class="number">9123</span> ms</span><br><span class="line">Thread-<span class="number">32</span>读取商品数据耗时：<span class="number">9894</span> ms</span><br><span class="line">Thread-<span class="number">9</span>读取商品数据耗时：<span class="number">10379</span> ms</span><br><span class="line">Thread-<span class="number">5</span>读取商品数据耗时：<span class="number">11117</span> ms</span><br><span class="line">Thread-<span class="number">4</span>读取商品数据耗时：<span class="number">11264</span> ms</span><br><span class="line">Thread-<span class="number">3</span>读取商品数据耗时：<span class="number">11828</span> ms</span><br><span class="line">Thread-<span class="number">7</span>读取商品数据耗时：<span class="number">12215</span> ms</span><br><span class="line">Thread-<span class="number">10</span>读取商品数据耗时：<span class="number">12448</span> ms</span><br><span class="line">Thread-<span class="number">11</span>写商品数据耗时：<span class="number">12506</span> ms----</span><br><span class="line">Thread-<span class="number">24</span>读取商品数据耗时：<span class="number">12630</span> ms</span><br><span class="line">Thread-<span class="number">0</span>写商品数据耗时：<span class="number">12819</span> ms----</span><br><span class="line">Thread-<span class="number">14</span>读取商品数据耗时：<span class="number">13211</span> ms</span><br><span class="line">Thread-<span class="number">17</span>读取商品数据耗时：<span class="number">13617</span> ms</span><br><span class="line">Thread-<span class="number">18</span>读取商品数据耗时：<span class="number">14142</span> ms</span><br><span class="line">Thread-<span class="number">23</span>读取商品数据耗时：<span class="number">15084</span> ms</span><br><span class="line">Thread-<span class="number">27</span>读取商品数据耗时：<span class="number">15282</span> ms</span><br><span class="line">Thread-<span class="number">29</span>读取商品数据耗时：<span class="number">15700</span> ms</span><br><span class="line">Thread-<span class="number">1</span>读取商品数据耗时：<span class="number">16594</span> ms</span><br><span class="line">Thread-<span class="number">8</span>读取商品数据耗时：<span class="number">16966</span> ms</span><br><span class="line">Thread-<span class="number">6</span>读取商品数据耗时：<span class="number">17235</span> ms</span><br><span class="line">Thread-<span class="number">31</span>读取商品数据耗时：<span class="number">17336</span> ms</span><br><span class="line">Thread-<span class="number">28</span>读取商品数据耗时：<span class="number">17639</span> ms</span><br><span class="line">Thread-<span class="number">20</span>读取商品数据耗时：<span class="number">17919</span> ms</span><br><span class="line">Thread-<span class="number">19</span>读取商品数据耗时：<span class="number">18386</span> ms</span><br><span class="line">Thread-<span class="number">2</span>读取商品数据耗时：<span class="number">18631</span> ms</span><br><span class="line">Thread-<span class="number">12</span>读取商品数据耗时：<span class="number">18687</span> ms</span><br></pre></td></tr></table></figure>

<p>接下来展示 ReadWriteLock 方式代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UseRwLock</span> <span class="keyword">implements</span> <span class="title class_">GoodsService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> GoodsInfo goodsInfo;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">ReadWriteLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantReadWriteLock</span>();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Lock</span> <span class="variable">readLock</span> <span class="operator">=</span> lock.readLock();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Lock</span> <span class="variable">writeLock</span> <span class="operator">=</span> lock.writeLock();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">UseRwLock</span><span class="params">(GoodsInfo goodsInfo)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.goodsInfo = goodsInfo;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> GoodsInfo <span class="title function_">getNum</span><span class="params">()</span> &#123;</span><br><span class="line">        readLock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">5</span>);</span><br><span class="line">            <span class="keyword">return</span> goodsInfo;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            readLock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setNum</span><span class="params">(<span class="type">int</span> number)</span> &#123;</span><br><span class="line">        writeLock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">5</span>);</span><br><span class="line">            goodsInfo.changeNumber(number);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            writeLock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出结果为：</span></span><br><span class="line">Thread-<span class="number">11</span>写商品数据耗时：<span class="number">219</span> ms----</span><br><span class="line">Thread-<span class="number">22</span>写商品数据耗时：<span class="number">219</span> ms----</span><br><span class="line">Thread-<span class="number">0</span>写商品数据耗时：<span class="number">274</span> ms----</span><br><span class="line">Thread-<span class="number">7</span>读取商品数据耗时：<span class="number">780</span> ms</span><br><span class="line">Thread-<span class="number">1</span>读取商品数据耗时：<span class="number">781</span> ms</span><br><span class="line">Thread-<span class="number">4</span>读取商品数据耗时：<span class="number">780</span> ms</span><br><span class="line">Thread-<span class="number">6</span>读取商品数据耗时：<span class="number">780</span> ms</span><br><span class="line">Thread-<span class="number">9</span>读取商品数据耗时：<span class="number">781</span> ms</span><br><span class="line">Thread-<span class="number">3</span>读取商品数据耗时：<span class="number">782</span> ms</span><br><span class="line">Thread-<span class="number">5</span>读取商品数据耗时：<span class="number">786</span> ms</span><br><span class="line">Thread-<span class="number">2</span>读取商品数据耗时：<span class="number">787</span> ms</span><br><span class="line">Thread-<span class="number">18</span>读取商品数据耗时：<span class="number">780</span> ms</span><br><span class="line">Thread-<span class="number">15</span>读取商品数据耗时：<span class="number">780</span> ms</span><br><span class="line">Thread-<span class="number">12</span>读取商品数据耗时：<span class="number">780</span> ms</span><br><span class="line">Thread-<span class="number">8</span>读取商品数据耗时：<span class="number">786</span> ms</span><br><span class="line">Thread-<span class="number">10</span>读取商品数据耗时：<span class="number">786</span> ms</span><br><span class="line">Thread-<span class="number">17</span>读取商品数据耗时：<span class="number">780</span> ms</span><br><span class="line">Thread-<span class="number">21</span>读取商品数据耗时：<span class="number">785</span> ms</span><br><span class="line">Thread-<span class="number">13</span>读取商品数据耗时：<span class="number">785</span> ms</span><br><span class="line">Thread-<span class="number">14</span>读取商品数据耗时：<span class="number">785</span> ms</span><br><span class="line">Thread-<span class="number">20</span>读取商品数据耗时：<span class="number">785</span> ms</span><br><span class="line">Thread-<span class="number">19</span>读取商品数据耗时：<span class="number">785</span> ms</span><br><span class="line">Thread-<span class="number">16</span>读取商品数据耗时：<span class="number">785</span> ms</span><br><span class="line">Thread-<span class="number">28</span>读取商品数据耗时：<span class="number">784</span> ms</span><br><span class="line">Thread-<span class="number">31</span>读取商品数据耗时：<span class="number">783</span> ms</span><br><span class="line">Thread-<span class="number">30</span>读取商品数据耗时：<span class="number">784</span> ms</span><br><span class="line">Thread-<span class="number">27</span>读取商品数据耗时：<span class="number">784</span> ms</span><br><span class="line">Thread-<span class="number">29</span>读取商品数据耗时：<span class="number">784</span> ms</span><br><span class="line">Thread-<span class="number">24</span>读取商品数据耗时：<span class="number">784</span> ms</span><br><span class="line">Thread-<span class="number">23</span>读取商品数据耗时：<span class="number">784</span> ms</span><br><span class="line">Thread-<span class="number">25</span>读取商品数据耗时：<span class="number">784</span> ms</span><br><span class="line">Thread-<span class="number">26</span>读取商品数据耗时：<span class="number">790</span> ms</span><br><span class="line">Thread-<span class="number">32</span>读取商品数据耗时：<span class="number">789</span> ms</span><br></pre></td></tr></table></figure>

<p>做同样的时，耗时由 18687 ms 降低为 790 ms，由此可见性能提升之巨大，小伙伴们在加锁的时候，要注意选择合适的锁，避免性能浪费。</p>
<h1 id="7-线程变量"><a href="#7-线程变量" class="headerlink" title="7. 线程变量"></a>7. 线程变量</h1><p>锁保证了操作资源的原子性，那么在一个类中，希望每个线程拿到的值都是一样的初始值，而不是被别的线程改变过后的值，如何解决呢？例子如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 期望每个线程拿到这个值都是指定值，然后进行处理，而不被其它线程所干扰</span></span><br><span class="line"><span class="keyword">static</span> <span class="type">Integer</span> <span class="variable">count</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 启动 3 个线程</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">startThreadArray</span><span class="params">()</span> &#123;</span><br><span class="line">    Thread[] runs = <span class="keyword">new</span> <span class="title class_">Thread</span>[<span class="number">3</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; runs.length; i++) &#123;</span><br><span class="line">        runs[i] = <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">TestTask</span>(i));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; runs.length; i++) &#123;</span><br><span class="line">        runs[i].start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述代码中，是无法满足要求的，如何处理呢？</p>
<p>在翻阅了源码后发现，有一个 <strong>ThreadLocal</strong>，即 <code>线程变量</code>，是一个以 <strong>ThreadLocal</strong> 对象为键、任意对象为值的存储结构。这个结构被附带在线程上，也就是说一个线程可以根据一个 <strong>ThreadLocal</strong> 对象查询到绑定在这个线程上的一个值，用来实现变量在线程之间的隔离。</p>
<p>修改后如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 改动后，即可满足要求</span></span><br><span class="line"><span class="keyword">static</span> ThreadLocal&lt;Integer&gt; count = ThreadLocal.withInitial(() -&gt; <span class="number">1</span>);</span><br></pre></td></tr></table></figure>

<h1 id="8-线程池"><a href="#8-线程池" class="headerlink" title="8. 线程池"></a>8. 线程池</h1><p><code>线程池</code> 是一种多线程处理形式，处理过程中将任务添加到队列，然后在创建线程后自动启动这些任务。</p>
<p>简单一点来说，由于 <em>创建线程</em> 和 <em>销毁线程</em> 是比较消耗资源的，对于执行任务内容较少且数量较多时，效率偏低，如果将资源提前创建并缓存到资源池中，每次使用的时候即拿即用，效率会得到大幅提升，并且也能有效的管理线程资源。</p>
<p>线程池优点：</p>
<ol>
<li>降低资源消耗；</li>
<li>提高响应速度；</li>
<li>提高线程的可管理性；</li>
</ol>
<p>在 Java 中，系统提供的有线程池：ThreadPoolExecutor，通过构造函数，我们知道线程池几个核心的控制数据。</p>
<blockquote>
<p>corePoolSize: 线程池中的核心线程数量，如果 <code>线程池</code> 中的线程数量大于等于这个数值后，继续提交的任务会被保存到阻塞队列中，等待被执行；</p>
<p>maximumPoolSize: <strong>线程池</strong> 中允许的最大线程数，如果当前阻塞队列满了，并且继续提交任务，则创建新的线程执行任务，但是这个数量要小于 maximumPoolSize；</p>
<p>keepAliveTime: 非核心线程空闲时存活时间；</p>
<p>unit: keepAliveTime 的时间单位；</p>
<p>workQueue: 必须是 BlockQuene 阻塞队列，当线程池中的线程数超过 corePoolSize 时，线程会进入阻塞队列进行阻塞等待。</p>
<p>threadFactory: 创建线程的工厂，可以自定义增加更多控制、资源信息；</p>
<p>handler: 饱和策略，当阻塞队列满了，且没有空闲的工作线程，如果继续提交任务，必须采用一种策略处理该任务，线程池提供了 4 种策略:</p>
<ol>
<li><p>AbortPolicy: 直接抛出异常，默认策略；</p>
</li>
<li><p>CallerRunsPolicy：用调用者所在的线程执行任务；</p>
</li>
<li><p>DiscardOldestPolicy：丢弃阻塞队列中靠最前的任务，并执行当前任务；</p>
</li>
<li><p>DiscardPolicy: 直接丢弃任务；</p>
</li>
</ol>
<p>补充：除了这 4 种策略外，还可以自定义策略，哪怕不新增处理方案，可以记录到文件中，待合适时机从文件中读取任务继续执行，或者记录日志，留备以后分析使用。</p>
</blockquote>
<p>线程池清楚了，那么如何合理配置线程池呢？最终要的是分析任务特性，可以从以下几个方面进行分析：</p>
<ol>
<li>任务的性质：CPU 密集型、IO 密集型和混合任务型；</li>
<li>任务的优先级：高、中和低；</li>
<li>任务的执行时间：长、中和短；</li>
<li>任务的依赖性：是否依赖其他的系统资源，如数据库连接；</li>
</ol>

  </div>
  <!--评论块-->
    

</article>
<nav class="post-nav">
  <!-- Prev Nav -->
    
  <a href="/2021/01/04/Java/从字节码分析 i++ 与 ++i 的区别/" id="post_nav-newer" class="post-nav-content prev-content">
      <上一篇
  </a>
    


  <!-- Next Nav -->
    
  <a href="/2020/12/25/Java/代理与动态代理/" id="post_nav-older" class="post-nav-content next-content">
      下一篇>
  </a>
    
</nav>
<div class="post-toc-btn"><i class="material-icons">format_list_numbered</i></div>
<div class="post-toc-none"><p>(无)</p></div>
<div class="post-toc-box">
    <ol class="post-toc"><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#1-%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5"><span class="post-toc-text">1. 基础概念</span></a></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#2-%E6%9F%A5%E7%9C%8B%E7%BA%BF%E7%A8%8B%E4%BF%A1%E6%81%AF%E7%A4%BA%E4%BE%8B"><span class="post-toc-text">2. 查看线程信息示例</span></a></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#3-%E7%BA%BF%E7%A8%8B%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="post-toc-text">3. 线程的使用</span></a></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#4-%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%81%9C%E6%AD%A2"><span class="post-toc-text">4. 线程的停止</span></a></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#5-%E7%BA%BF%E7%A8%8B%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95"><span class="post-toc-text">5. 线程常用方法</span></a></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#6-%E7%BA%BF%E7%A8%8B%E9%94%81"><span class="post-toc-text">6. 线程锁</span></a></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#7-%E7%BA%BF%E7%A8%8B%E5%8F%98%E9%87%8F"><span class="post-toc-text">7. 线程变量</span></a></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#8-%E7%BA%BF%E7%A8%8B%E6%B1%A0"><span class="post-toc-text">8. 线程池</span></a></li></ol>
</div>
<!--<div class="post-back"><i class="material-icons">arrow_back</i></div>-->
<script type="text/javascript">
    menu();
</script>
  </div>
</div>
<div id="bottom-outer">
  <div id="bottom-inner">
    <a  id="top-button" onfocus="this.blur();"><div class="up upinbody" style="background-color:#26A69A"><i class="material-icons material-up">vertical_align_top</i></div></a>


<p >Copyright ©  2017  Walker Denial</p>
<!-- <p >Powered by <a href="https://hexo.io/" target="_blank"> Hexo </a> & Theme - <a href="https://github.com/moumao/hexo-theme-Vateral" target="_blank">Vateral</a></p> -->
<p style="font-size: 10px; margin-top: 0" id="footer-times" data-time="01/10/2017 00:00:00"></p>
<script>
    var beginTime=document.getElementById("footer-times").dataset.time
    function show_date_time(){
        var span=document.getElementById("footer-times")
        window.setTimeout("show_date_time()", 1000);
        BirthDay=new Date(beginTime);//初始日期
        today=new Date();
        timeold=(today.getTime()-BirthDay.getTime());
        sectimeold=timeold/1000
        secondsold=Math.floor(sectimeold);
        msPerDay=24*60*60*1000
        e_daysold=timeold/msPerDay
        daysold=Math.floor(e_daysold);
        e_hrsold=(e_daysold-daysold)*24;
        hrsold=Math.floor(e_hrsold);
        e_minsold=(e_hrsold-hrsold)*60;
        minsold=Math.floor((e_hrsold-hrsold)*60);
        seconds=Math.floor((e_minsold-minsold)*60);
        span.innerHTML="本站已运行"+daysold+"天"+hrsold+"小时"+minsold+"分"+seconds+"秒";
    }
    show_date_time();
</script>

  </div>
</div>

<!--影集界面需要的资源-->



<!-- scripts list from theme config.yml -->

<script src="/js/jquery-3.1.1.min.js"></script>

<script src="/js/materialize.min.js"></script>

<script src="/js/main.min.js"></script>


<script>
    NProgress.start();
    NProgress.done();
    lazy();
    links();
    window.onpopstate = menu();
    //pjax操作
    $(document).pjax('a:not(.nopjax)', '#content-inner', {fragment:'#content-inner', timeout:8000});
    $(document).on('pjax:start', NProgress.start).on('pjax:end', NProgress.done)
        .on('pjax:end', () => {
            dowmdiv();
            lazy();
            toc();
            links();
            menu();
        });
</script>

</body>
</html>
